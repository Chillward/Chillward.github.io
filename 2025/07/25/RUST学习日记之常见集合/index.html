<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":true,"pangu":true,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="RUST标准库中给我们提供了很多集合,这里介绍三种最常见的:   vector String hash map  可能是类似于CPP中的STL,标准库提供了一些别的数据类型,方便我们使用. Vector第一个类型是 Vec&lt;T&gt;，也被称为 vector。vector 允许我们在一个单独的数据结构中储存多个值，所有值在内存中彼此相邻排列。vector 只能储存相同类型的值。它们在拥有一">
<meta property="og:type" content="article">
<meta property="og:title" content="RUST学习日记之常见集合">
<meta property="og:url" content="http://example.com/2025/07/25/RUST%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0%E4%B9%8B%E5%B8%B8%E8%A7%81%E9%9B%86%E5%90%88/index.html">
<meta property="og:site_name" content="Chillward的博客">
<meta property="og:description" content="RUST标准库中给我们提供了很多集合,这里介绍三种最常见的:   vector String hash map  可能是类似于CPP中的STL,标准库提供了一些别的数据类型,方便我们使用. Vector第一个类型是 Vec&lt;T&gt;，也被称为 vector。vector 允许我们在一个单独的数据结构中储存多个值，所有值在内存中彼此相邻排列。vector 只能储存相同类型的值。它们在拥有一">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2025-07-24T23:56:03.000Z">
<meta property="article:modified_time" content="2025-07-25T01:33:23.266Z">
<meta property="article:author" content="Chillward">
<meta property="article:tag" content="RUST">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/2025/07/25/RUST%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0%E4%B9%8B%E5%B8%B8%E8%A7%81%E9%9B%86%E5%90%88/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>RUST学习日记之常见集合 | Chillward的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Chillward的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/07/25/RUST%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0%E4%B9%8B%E5%B8%B8%E8%A7%81%E9%9B%86%E5%90%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.png">
      <meta itemprop="name" content="Chillward">
      <meta itemprop="description" content="谁躺在漆黑的舞台上，用身体迎接着光芒">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chillward的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          RUST学习日记之常见集合
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-07-25 07:56:03 / 修改时间：09:33:23" itemprop="dateCreated datePublished" datetime="2025-07-25T07:56:03+08:00">2025-07-25</time>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>15k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>27 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <blockquote>
<p>RUST标准库中给我们提供了很多集合,这里介绍三种最常见的:</p>
</blockquote>
<ol>
<li>vector</li>
<li>String</li>
<li>hash map</li>
</ol>
<p>可能是类似于CPP中的STL,标准库提供了一些别的数据类型,方便我们使用.</p>
<h2 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h2><p>第一个类型是 <code>Vec&lt;T&gt;</code>，也被称为 <em>vector</em>。vector 允许我们在一个单独的数据结构中储存多个值，所有值在内存中彼此相邻排列。vector 只能储存相同类型的值。它们在拥有一系列项的场景下非常实用，例如文件中的文本行或购物车中商品的价格。</p>
<h3 id="Vector的初始化"><a href="#Vector的初始化" class="headerlink" title="Vector的初始化"></a>Vector的初始化</h3><ol>
<li><code>  ler v:Vec[i32] = Vec::new();</code> 新建一个空的Vec来存储i32类型的值.</li>
<li><code>let v = vec![1,2,3];</code> 利用vec!宏来使用初始值来创建一个Vec.此时Rust可以自动推断出v的类型.</li>
</ol>
<h3 id="Vector的更新"><a href="#Vector的更新" class="headerlink" title="Vector的更新"></a>Vector的更新</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#![allow(unused)]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v</span> = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">v.<span class="title function_ invoke__">push</span>(<span class="number">5</span>);</span><br><span class="line">v.<span class="title function_ invoke__">push</span>(<span class="number">6</span>);</span><br><span class="line">v.<span class="title function_ invoke__">push</span>(<span class="number">7</span>);</span><br><span class="line">v.<span class="title function_ invoke__">push</span>(<span class="number">8</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>很明显,v.push是将值推入Vec中的方法</p>
<p>我们需要注意的一点是:与其他结构类似,当vector离开他的作用域时会被销毁,并且当存在一个有效的不可变引用时,是没办法通过push向vec中新增值的.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">first</span> = &amp;v[<span class="number">0</span>];</span><br><span class="line">v.<span class="title function_ invoke__">push</span>(<span class="number">6</span>);</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;The first element is: &#123;&#125;&quot;</span>, first);</span><br></pre></td></tr></table></figure>



<h3 id="Vector元素的读取"><a href="#Vector元素的读取" class="headerlink" title="Vector元素的读取"></a>Vector元素的读取</h3><ol>
<li>通过索引来读取值</li>
<li>通过.get来读取值</li>
</ol>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#![allow(unused)]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">third</span>: &amp;<span class="type">i32</span> = &amp;v[<span class="number">2</span>];</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;The third element is &#123;&#125;&quot;</span>, third);</span><br><span class="line"></span><br><span class="line"><span class="keyword">match</span> v.<span class="title function_ invoke__">get</span>(<span class="number">2</span>) &#123;</span><br><span class="line">    <span class="title function_ invoke__">Some</span>(third) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;The third element is &#123;&#125;&quot;</span>, third),</span><br><span class="line">    <span class="literal">None</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;There is no third element.&quot;</span>),</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里有两个需要注意的地方。首先，我们使用索引值 <code>2</code> 来获取第三个元素，索引是从 0 开始的。其次，这两个不同的获取第三个元素的方式分别为：使用 <code>&amp;</code> 和 <code>[]</code> 返回一个引用；或者使用 <code>get</code> 方法以索引作为参数来返回一个 <code>Option&lt;&amp;T&gt;</code>。</p>
<blockquote>
<p>使用.get方法可能是更优的,因为当索引越界时,.get方法会返回None,然后你就可以处理而不至于使程序崩溃</p>
</blockquote>
<h3 id="遍历Vector中的元素"><a href="#遍历Vector中的元素" class="headerlink" title="遍历Vector中的元素"></a>遍历Vector中的元素</h3><p>如果想要依次访问 vector 中的每一个元素，我们可以遍历其所有的元素而无需通过索引一次一个的访问。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">100</span>, <span class="number">32</span>, <span class="number">57</span>];</span><br><span class="line"><span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> &amp;v &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们也可以遍历可变 vector 的每一个元素的可变引用以便能改变他们。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">100</span>, <span class="number">32</span>, <span class="number">57</span>];</span><br><span class="line"><span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> &amp;<span class="keyword">mut</span> v &#123;</span><br><span class="line">    *i += <span class="number">50</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了修改可变引用所指向的值，在使用 <code>+=</code> 运算符之前必须使用解引用运算符（<code>*</code>）获取 <code>i</code> 中的值。</p>
<h3 id="使用枚举来储存多种类型"><a href="#使用枚举来储存多种类型" class="headerlink" title="使用枚举来储存多种类型"></a>使用枚举来储存多种类型</h3><p>在本章的开始，我们提到 vector 只能储存相同类型的值。这是很不方便的；绝对会有需要储存一系列不同类型的值的用例。幸运的是，枚举的成员都被定义为相同的枚举类型，所以当需要在 vector 中储存不同类型值时，我们可以定义并使用一个枚举！</p>
<p>例如，假如我们想要从电子表格的一行中获取值，而这一行的有些列包含数字，有些包含浮点值，还有些是字符串。我们可以定义一个枚举，其成员会存放这些不同类型的值，同时所有这些枚举成员都会被当作相同类型，那个枚举的类型。接着可以创建一个储存枚举值的 vector，这样最终就能够储存不同类型的值了。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">SpreadsheetCell</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Int</span>(<span class="type">i32</span>),</span><br><span class="line">    <span class="title function_ invoke__">Float</span>(<span class="type">f64</span>),</span><br><span class="line">    <span class="title function_ invoke__">Text</span>(<span class="type">String</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">row</span> = <span class="built_in">vec!</span>[</span><br><span class="line">    SpreadsheetCell::<span class="title function_ invoke__">Int</span>(<span class="number">3</span>),</span><br><span class="line">    SpreadsheetCell::<span class="title function_ invoke__">Text</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;blue&quot;</span>)),</span><br><span class="line">    SpreadsheetCell::<span class="title function_ invoke__">Float</span>(<span class="number">10.12</span>),</span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<p>Rust 在编译时就必须准确的知道 vector 中类型的原因在于它需要知道储存每个元素到底需要多少内存。第二个好处是可以准确的知道这个  vector 中允许什么类型。如果 Rust 允许 vector 存放任意类型，那么当对 vector  元素执行操作时一个或多个类型的值就有可能会造成错误。使用枚举外加 <code>match</code> 意味着 Rust 能在编译时就保证总是会处理所有可能的情况，正如第 6 章讲到的那样。</p>
<p>如果在编写程序时不能确切无遗地知道运行时会储存进 vector 的所有类型，枚举技术就行不通了。相反，你可以使用 trait 对象，第 17 章会讲到它。</p>
<p>现在我们了解了一些使用 vector 的最常见的方式，请一定去看看标准库中 <code>Vec</code> 定义的很多其他实用方法的 API 文档。例如，除了 <code>push</code> 之外还有一个 <code>pop</code> 方法，它会移除并返回 vector 的最后一个元素。</p>
<h2 id="String类型"><a href="#String类型" class="headerlink" title="String类型"></a>String类型</h2><p>在 Rust 中，字符串并非单一类型，而是通常指两种主要的 UTF-8 编码类型：<strong><code>str</code>（字符串 slice）</strong> 和 <strong><code>String</code></strong>。</p>
<p>具体来说，它涵盖了以下几个要点：</p>
<ul>
<li><strong><code>str</code> (字符串 slice)</strong>：<ul>
<li>这是 Rust <strong>核心语言</strong>中唯一的字符串类型。</li>
<li>它通常以 <strong>被借用的形式 <code>&amp;str</code></strong> 出现。</li>
<li><code>&amp;str</code> 是对储存在<strong>别处</strong>（例如程序二进制输出中的字符串字面量）的 UTF-8 编码字符串数据的<strong>引用</strong>。它们是不可变且固定大小的。</li>
</ul>
</li>
<li><strong><code>String</code></strong>：<ul>
<li>这是由 Rust <strong>标准库提供</strong>的类型，不属于核心语言。</li>
<li>它是一种<strong>可增长的、可变的、有所有权</strong>的 UTF-8 编码字符串类型。</li>
<li><code>String</code> 类型的数据存储在堆上，可以根据需要进行扩展和修改。</li>
</ul>
</li>
<li><strong>“字符串”的通用指代</strong>：<ul>
<li>当 Rust 开发者（Rustacean）提到“字符串”时，通常指的是 <strong><code>String</code> 和 <code>&amp;str</code> 这两种类型</strong>，而不是特指其中一个。</li>
<li>这两种类型在 Rust 标准库中都非常常用，且都使用 <strong>UTF-8 编码</strong>。</li>
</ul>
</li>
<li><strong>其他字符串类型</strong>：<ul>
<li>除了 <code>String</code> 和 <code>&amp;str</code>，Rust 标准库还提供了其他字符串类型，如 <code>OsString</code>、<code>OsStr</code>、<code>CString</code> 和 <code>CStr</code>。</li>
<li>这些类型通常以 <code>String</code> 或 <code>Str</code> 结尾，分别对应其所有权（<code>String</code> 变体）和可借用（<code>Str</code> 变体）的特性。</li>
<li>它们可能用于存储不同编码或内存表示形式的文本内容（例如与操作系统或 C 语言交互时）。</li>
</ul>
</li>
</ul>
<blockquote>
<p>官方文档下头这段写得还是很像人话的,我们之间复制过来,需要注意的是,rust中的字符串默认是UTF-8而不是ASCII,所以会出现一些在C语言中不会出现的问题,C语言中与之对应的知识是wchar,即宽字符.</p>
</blockquote>
<h3 id="新建字符串"><a href="#新建字符串" class="headerlink" title="新建字符串"></a><a target="_blank" rel="noopener" href="https://rustwiki.org/zh-CN/book/ch08-02-strings.html#%E6%96%B0%E5%BB%BA%E5%AD%97%E7%AC%A6%E4%B8%B2">新建字符串</a></h3><p>很多 <code>Vec</code> 可用的操作在 <code>String</code> 中同样可用，从 <code>new</code> 函数创建字符串开始，如示例 8-11 所示。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br></pre></td></tr></table></figure>

<p>示例 8-11：新建一个空的 <code>String</code></p>
<p>这新建了一个叫做 <code>s</code> 的空的字符串，接着我们可以向其中装载数据。通常字符串会有初始数据，因为我们希望一开始就有这个字符串。为此，可以使用 <code>to_string</code> 方法，它能用于任何实现了 <code>Display</code> trait 的类型，字符串字面量也实现了它。示例 8-12 展示了两个例子。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">data</span> = <span class="string">&quot;initial contents&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = data.<span class="title function_ invoke__">to_string</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 该方法也可直接用于字符串字面量：</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="string">&quot;initial contents&quot;</span>.<span class="title function_ invoke__">to_string</span>();</span><br></pre></td></tr></table></figure>

<p>示例 8-12：使用 <code>to_string</code> 方法从字符串字面量创建 <code>String</code></p>
<p>这些代码会创建包含 <code>initial contents</code> 的字符串。</p>
<p>也可以使用 <code>String::from</code> 函数来从字符串字面量创建 <code>String</code>。示例 8-13 中的代码等同于使用 <code>to_string</code>。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;initial contents&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>示例 8-13：使用 <code>String::from</code> 函数从字符串字面量创建 <code>String</code></p>
<p>因为字符串应用广泛，这里有很多不同的用于字符串的通用 API 可供选择。其中一些可能看起来多余，不过都有其用武之地！在这个例子中，<code>String::from</code> 和 <code>to_string</code> 最终做到了完全相同的事情，所以如何选择，就是风格问题了。</p>
<p>请记住，字符串是 UTF-8 编码的，所以可以包含任何正确编码的数据，如示例 8-14 所示。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">hello</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;السلام عليكم&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">hello</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Dobrý den&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">hello</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">hello</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;שָׁלוֹם&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">hello</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;नमस्ते&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">hello</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;こんにちは&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">hello</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;안녕하세요&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">hello</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;你好&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">hello</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Olá&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">hello</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Здравствуйте&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">hello</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hola&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>示例 8-14：在字符串中储存不同语言的问候语</p>
<p>所有这些都是有效的 <code>String</code> 值。</p>
<h3 id="更新字符串"><a href="#更新字符串" class="headerlink" title="更新字符串"></a><a target="_blank" rel="noopener" href="https://rustwiki.org/zh-CN/book/ch08-02-strings.html#%E6%9B%B4%E6%96%B0%E5%AD%97%E7%AC%A6%E4%B8%B2">更新字符串</a></h3><p><code>String</code> 的大小可以增加，其内容也可以改变，就像可以放入更多数据来改变 <code>Vec</code> 的内容一样。另外，可以方便的使用 <code>+</code> 运算符或 <code>format!</code> 宏来拼接 <code>String</code> 值。</p>
<h4 id="使用-push-str-和-push-附加字符串"><a href="#使用-push-str-和-push-附加字符串" class="headerlink" title="使用 push_str 和 push 附加字符串"></a><a target="_blank" rel="noopener" href="https://rustwiki.org/zh-CN/book/ch08-02-strings.html#%E4%BD%BF%E7%94%A8-push_str-%E5%92%8C-push-%E9%99%84%E5%8A%A0%E5%AD%97%E7%AC%A6%E4%B8%B2">使用 <code>push_str</code> 和 <code>push</code> 附加字符串</a></h4><p>可以通过 <code>push_str</code> 方法来附加字符串 slice，从而使 <code>String</code> 变长，如示例 8-15 所示。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line">s.<span class="title function_ invoke__">push_str</span>(<span class="string">&quot;bar&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>示例 8-15：使用 <code>push_str</code> 方法向 <code>String</code> 附加字符串 slice</p>
<p>执行这两行代码之后，<code>s</code> 将会包含 <code>foobar</code>。<code>push_str</code> 方法采用字符串 slice，因为我们并不需要获取参数的所有权。例如，示例 8-16 展示了如果将 <code>s2</code> 的内容附加到 <code>s1</code> 之后，自身不能被使用就糟糕了。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s2</span> = <span class="string">&quot;bar&quot;</span>;</span><br><span class="line">s1.<span class="title function_ invoke__">push_str</span>(s2);</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;s2 is &#123;&#125;&quot;</span>, s2);</span><br></pre></td></tr></table></figure>

<p>示例 8-16：将字符串 slice 的内容附加到 <code>String</code> 后使用它</p>
<p>如果 <code>push_str</code> 方法获取了 <code>s2</code> 的所有权，就不能在最后一行打印出其值了。好在代码如我们期望那样工作！</p>
<p><code>push</code> 方法被定义为获取一个单独的字符作为参数，并附加到 <code>String</code> 中。示例 8-17 展示了使用 <code>push</code> 方法将字母 <em>l</em> 加入 <code>String</code> 的代码。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;lo&quot;</span>);</span><br><span class="line">s.<span class="title function_ invoke__">push</span>(<span class="string">&#x27;l&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>示例 8-17：使用 <code>push</code> 将一个字符加入 <code>String</code> 值中</p>
<p>执行这些代码之后，<code>s</code> 将会包含 <code>lol</code>。</p>
<h4 id="使用-运算符或-format-宏拼接字符串"><a href="#使用-运算符或-format-宏拼接字符串" class="headerlink" title="使用 + 运算符或 format! 宏拼接字符串"></a><a target="_blank" rel="noopener" href="https://rustwiki.org/zh-CN/book/ch08-02-strings.html#%E4%BD%BF%E7%94%A8--%E8%BF%90%E7%AE%97%E7%AC%A6%E6%88%96-format-%E5%AE%8F%E6%8B%BC%E6%8E%A5%E5%AD%97%E7%AC%A6%E4%B8%B2">使用 <code>+</code> 运算符或 <code>format!</code> 宏拼接字符串</a></h4><p>通常你会希望将两个已知的字符串合并在一起。一种办法是像这样使用 <code>+</code> 运算符，如示例 8-18 所示。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello, &quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s2</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;world!&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s3</span> = s1 + &amp;s2; <span class="comment">// 注意 s1 被移动了，不能继续使用</span></span><br></pre></td></tr></table></figure>

<p>示例 8-18：使用 <code>+</code> 运算符将两个 <code>String</code> 值合并到一个新的 <code>String</code> 值中</p>
<p>执行完这些代码之后，字符串 <code>s3</code> 将会包含 <code>Hello, world!</code>。<code>s1</code> 在相加后不再有效的原因，和使用 <code>s2</code> 的引用的原因，与使用 <code>+</code> 运算符时调用的函数签名有关。<code>+</code> 运算符使用了 <code>add</code> 函数，这个函数签名看起来像这样：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">add</span>(<span class="keyword">self</span>, s: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br></pre></td></tr></table></figure>

<p>这并不是标准库中实际的签名；标准库中的 <code>add</code> 使用泛型定义。这里我们看到的 <code>add</code> 的签名使用具体类型代替了泛型，这也正是当使用 <code>String</code> 值调用这个方法会发生的。第 10 章会讨论泛型。这个签名提供了理解 <code>+</code> 运算那微妙部分的线索。</p>
<p>首先，<code>s2</code> 使用了 <code>&amp;</code>，意味着我们使用第二个字符串的 <strong>引用</strong> 与第一个字符串相加。这是因为 <code>add</code> 函数的 <code>s</code> 参数：只能将 <code>&amp;str</code> 和 <code>String</code> 相加，不能将两个 <code>String</code> 值相加。不过等一下 —— 正如 <code>add</code> 的第二个参数所指定的，<code>&amp;s2</code> 的类型是 <code>&amp;String</code> 而不是 <code>&amp;str</code>。那么为什么示例 8-18 还能编译呢？</p>
<p>之所以能够在 <code>add</code> 调用中使用 <code>&amp;s2</code> 是因为 <code>&amp;String</code> 可以被 <strong>强转</strong>（<em>coerced</em>）成 <code>&amp;str</code>。当 <code>add</code> 函数被调用时，Rust 使用了一个被称为 <strong>解引用强制转换</strong>（<em>deref coercion</em>）的技术，你可以将其理解为它把 <code>&amp;s2</code> 变成了 <code>&amp;s2[..]</code>。第 15 章会更深入的讨论解引用强制转换。因为 <code>add</code> 没有获取参数的所有权，所以 <code>s2</code> 在这个操作后仍然是有效的 <code>String</code>。</p>
<p>其次，可以发现签名中 <code>add</code> 获取了 <code>self</code> 的所有权，因为 <code>self</code> <strong>没有</strong> 使用 <code>&amp;</code>。这意味着示例 8-18 中的 <code>s1</code> 的所有权将被移动到 <code>add</code> 调用中，之后就不再有效。虽然 <code>let s3 = s1 + &amp;s2;</code> 看起来就像它会复制两个字符串并创建一个新的字符串，而实际上这个语句会获取 <code>s1</code> 的所有权，附加上从 <code>s2</code> 中拷贝的内容，并返回结果的所有权。换句话说，它看起来好像生成了很多拷贝，不过实际上并没有：这个实现比拷贝要更高效。</p>
<p>如果想要级联多个字符串，<code>+</code> 的行为就显得笨重了：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;tic&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s2</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;tac&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s3</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;toe&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = s1 + <span class="string">&quot;-&quot;</span> + &amp;s2 + <span class="string">&quot;-&quot;</span> + &amp;s3;</span><br></pre></td></tr></table></figure>

<p>这时 <code>s</code> 的内容会是 <code>tic-tac-toe</code>。在有这么多 <code>+</code> 和 <code>&quot;</code> 字符的情况下，很难理解具体发生了什么。对于更为复杂的字符串连接，可以使用 <code>format!</code> 宏：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;tic&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s2</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;tac&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s3</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;toe&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125;-&#123;&#125;-&#123;&#125;&quot;</span>, s1, s2, s3);</span><br></pre></td></tr></table></figure>

<p>这些代码也会将 <code>s</code> 设置为 “tic-tac-toe”。<code>format!</code> 与 <code>println!</code> 的工作原理相同，不过不同于将输出打印到屏幕上，它返回一个带有结果内容的 <code>String</code>。这个版本就好理解的多，并且不会获取任何参数的所有权。</p>
<h3 id="索引字符串"><a href="#索引字符串" class="headerlink" title="索引字符串"></a><a target="_blank" rel="noopener" href="https://rustwiki.org/zh-CN/book/ch08-02-strings.html#%E7%B4%A2%E5%BC%95%E5%AD%97%E7%AC%A6%E4%B8%B2">索引字符串</a></h3><p>在很多语言中，通过索引来引用字符串中的单独字符是有效且常见的操作。然而在 Rust 中，如果你尝试使用索引语法访问 <code>String</code> 的一部分，会出现一个错误。考虑一下如示例 8-19 中所示的无效代码。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">h</span> = s1[<span class="number">0</span>];</span><br></pre></td></tr></table></figure>

<p>示例 8-19：尝试对字符串使用索引语法</p>
<p>这段代码会导致如下错误：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">error[E0277]: the trait bound `std::string::String: std::ops::Index&lt;&#123;integer&#125;&gt;` is not satisfied</span><br><span class="line"> --&gt;</span><br><span class="line">  |</span><br><span class="line">3 |     let h = s1[0];</span><br><span class="line">  |             ^^^^^ the type `std::string::String` cannot be indexed by `&#123;integer&#125;`</span><br><span class="line">  |</span><br><span class="line">  = help: the trait `std::ops::Index&lt;&#123;integer&#125;&gt;` is not implemented for `std::string::String`</span><br></pre></td></tr></table></figure>

<p>错误和提示说明了全部问题：Rust 的字符串不支持索引。那么接下来的问题是，为什么不支持呢？为了回答这个问题，我们必须先聊一聊 Rust 是如何在内存中储存字符串的。</p>
<h4 id="内部表现"><a href="#内部表现" class="headerlink" title="内部表现"></a><a target="_blank" rel="noopener" href="https://rustwiki.org/zh-CN/book/ch08-02-strings.html#%E5%86%85%E9%83%A8%E8%A1%A8%E7%8E%B0">内部表现</a></h4><p><code>String</code> 是一个 <code>Vec&lt;u8&gt;</code> 的封装。让我们看看示例 8-14 中一些正确编码的字符串的例子。首先是这一个：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">len</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hola&quot;</span>).<span class="title function_ invoke__">len</span>();</span><br></pre></td></tr></table></figure>

<p>在这里，<code>len</code> 的值是 4 ，这意味着储存字符串 “Hola” 的 <code>Vec</code> 的长度是 4 个字节：这里每一个字母的 UTF-8 编码都占用 1 个字节。那下面这个例子又如何呢？（注意这个字符串中的首字母是西里尔字母的 Ze，而不是阿拉伯数字 3 。）</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">len</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Здравствуйте&quot;</span>).<span class="title function_ invoke__">len</span>();</span><br></pre></td></tr></table></figure>

<p>当问及这个字符是多长的时候有人可能会说是 12。然而，Rust 的回答是 24。这是使用 UTF-8 编码 “Здравствуйте”  所需要的字节数，这是因为每个 Unicode 标量值需要 2 个字节存储。因此一个字符串字节值的索引并不总是对应一个有效的 Unicode  标量值。作为演示，考虑如下无效的 Rust 代码：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">hello</span> = <span class="string">&quot;Здравствуйте&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">answer</span> = &amp;hello[<span class="number">0</span>];</span><br></pre></td></tr></table></figure>

<p><code>answer</code> 的值应该是什么呢？它应该是第一个字符 <code>З</code> 吗？当使用 UTF-8 编码时，<code>З</code> 的第一个字节 <code>208</code>，第二个是 <code>151</code>，所以 <code>answer</code> 实际上应该是 <code>208</code>，不过 <code>208</code> 自身并不是一个有效的字母。返回 <code>208</code> 可不是一个请求字符串第一个字母的人所希望看到的，不过它是 Rust 在字节索引 0 位置所能提供的唯一数据。用户通常不会想要一个字节值被返回，即便这个字符串只有拉丁字母： 即便 <code>&amp;&quot;hello&quot;[0]</code> 是返回字节值的有效代码，它也应当返回 <code>104</code> 而不是 <code>h</code>。为了避免返回意外的值并造成不能立刻发现的 bug，Rust 根本不会编译这些代码，并在开发过程中及早杜绝了误会的发生。</p>
<h4 id="字节、标量值和字形簇！天呐！"><a href="#字节、标量值和字形簇！天呐！" class="headerlink" title="字节、标量值和字形簇！天呐！"></a><a target="_blank" rel="noopener" href="https://rustwiki.org/zh-CN/book/ch08-02-strings.html#%E5%AD%97%E8%8A%82%E6%A0%87%E9%87%8F%E5%80%BC%E5%92%8C%E5%AD%97%E5%BD%A2%E7%B0%87%E5%A4%A9%E5%91%90">字节、标量值和字形簇！天呐！</a></h4><p>这引起了关于 UTF-8 的另外一个问题：从 Rust 的角度来讲，事实上有三种相关方式可以理解字符串：字节、标量值和字形簇（最接近人们眼中 <strong>字母</strong> 的概念）。</p>
<p>比如这个用梵文书写的印度语单词 “नमस्ते”，最终它储存在 vector 中的 <code>u8</code> 值看起来像这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[224, 164, 168, 224, 164, 174, 224, 164, 184, 224, 165, 141, 224, 164, 164, 224, 165, 135]</span><br></pre></td></tr></table></figure>

<p>这里有 18 个字节，也就是计算机最终会储存的数据。如果从 Unicode 标量值的角度理解它们，也就像 Rust 的 <code>char</code> 类型那样，这些字节看起来像这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&#x27;न&#x27;, &#x27;म&#x27;, &#x27;स&#x27;, &#x27;्&#x27;, &#x27;त&#x27;, &#x27;े&#x27;]</span><br></pre></td></tr></table></figure>

<p>这里有六个 <code>char</code>，不过第四个和第六个都不是字母，它们是发音符号本身并没有任何意义。最后，如果以字形簇的角度理解，就会得到人们所说的构成这个单词的四个字母：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&quot;न&quot;, &quot;म&quot;, &quot;स्&quot;, &quot;ते&quot;]</span><br></pre></td></tr></table></figure>

<p>Rust 提供了多种不同的方式来解释计算机储存的原始字符串数据，这样程序就可以选择它需要的表现方式，而无所谓是何种人类语言。</p>
<p>最后一个 Rust 不允许使用索引获取 <code>String</code> 字符的原因是，索引操作预期总是需要常数时间 (O(1))。但是对于 <code>String</code> 不可能保证这样的性能，因为 Rust 必须从开头到索引位置遍历来确定有多少有效的字符。</p>
<h3 id="字符串-slice"><a href="#字符串-slice" class="headerlink" title="字符串 slice"></a><a target="_blank" rel="noopener" href="https://rustwiki.org/zh-CN/book/ch08-02-strings.html#%E5%AD%97%E7%AC%A6%E4%B8%B2-slice">字符串 slice</a></h3><p>索引字符串通常是一个坏点子，因为字符串索引应该返回的类型是不明确的：字节值、字符、字形簇或者字符串  slice。因此，如果你真的希望使用索引创建字符串 slice 时，Rust 会要求你更明确一些。为了更明确索引并表明你需要一个字符串  slice，相比使用 <code>[]</code> 和单个值的索引，可以使用 <code>[]</code> 和一个 range 来创建含特定字节的字符串 slice：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">hello</span> = <span class="string">&quot;Здравствуйте&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = &amp;hello[<span class="number">0</span>..<span class="number">4</span>];</span><br></pre></td></tr></table></figure>

<p>这里，<code>s</code> 会是一个 <code>&amp;str</code>，它包含字符串的头 4 个字节。早些时候，我们提到了这些字母都是 2 个字节长的，所以这意味着 <code>s</code> 将会是 “Зд”。</p>
<p>如果获取 <code>&amp;hello[0..1]</code> 会发生什么呢？答案是：Rust 在运行时会 panic，就跟访问 vector 中的无效索引时一样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thread &#x27;main&#x27; panicked at &#x27;byte index 1 is not a char boundary; it is inside &#x27;З&#x27; (bytes 0..2) of `Здравствуйте`&#x27;, src/libcore/str/mod.rs:2188:4</span><br></pre></td></tr></table></figure>

<p>你应该小心谨慎的使用这个操作，因为这么做可能会使你的程序崩溃。</p>
<h3 id="遍历字符串的方法"><a href="#遍历字符串的方法" class="headerlink" title="遍历字符串的方法"></a><a target="_blank" rel="noopener" href="https://rustwiki.org/zh-CN/book/ch08-02-strings.html#%E9%81%8D%E5%8E%86%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%96%B9%E6%B3%95">遍历字符串的方法</a></h3><p>幸运的是，这里还有其他获取字符串元素的方式。</p>
<p>如果你需要操作单独的 Unicode 标量值，最好的选择是使用 <code>chars</code> 方法。对 “नमस्ते” 调用 <code>chars</code> 方法会将其分开并返回六个 <code>char</code> 类型的值，接着就可以遍历其结果来访问每一个元素了：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="variable">c</span> <span class="keyword">in</span> <span class="string">&quot;नमस्ते&quot;</span>.<span class="title function_ invoke__">chars</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这些代码会打印出如下内容：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">न</span><br><span class="line">म</span><br><span class="line">स</span><br><span class="line">्</span><br><span class="line">त</span><br><span class="line">े</span><br></pre></td></tr></table></figure>

<p><code>bytes</code> 方法返回每一个原始字节，这可能会适合你的使用场景：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="variable">b</span> <span class="keyword">in</span> <span class="string">&quot;नमस्ते&quot;</span>.<span class="title function_ invoke__">bytes</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这些代码会打印出组成 <code>String</code> 的 18 个字节：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">224</span></span><br><span class="line"><span class="number">164</span></span><br><span class="line"><span class="comment">// --snip--</span></span><br><span class="line"><span class="number">165</span></span><br><span class="line"><span class="number">135</span></span><br></pre></td></tr></table></figure>

<p>不过请记住有效的 Unicode 标量值可能会由不止一个字节组成。</p>
<p>从字符串中获取字形簇是很复杂的，所以标准库并没有提供这个功能。<a target="_blank" rel="noopener" href="https://crates.io/">crates.io</a> 上有些提供这样功能的 crate。</p>
<h3 id="字符串并不简单"><a href="#字符串并不简单" class="headerlink" title="字符串并不简单"></a><a target="_blank" rel="noopener" href="https://rustwiki.org/zh-CN/book/ch08-02-strings.html#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B9%B6%E4%B8%8D%E7%AE%80%E5%8D%95">字符串并不简单</a></h3><p>总而言之，字符串还是很复杂的。不同的语言选择了不同的向开发者展示其复杂性的方式。Rust 选择了以准确的方式处理 <code>String</code> 数据作为所有 Rust 程序的默认行为，这意味着开发者们必须更多的思考如何预先处理 UTF-8 数据。这种权衡取舍相比其他语言更多的暴露出了字符串的复杂性，不过也使你在开发生命周期后期免于处理涉及非 ASCII 字符的错误。</p>
<blockquote>
<p>哈希map,我在C语言编程时没怎么接触过这个东西,所以不太熟悉,等用到的时候再回来看吧</p>
</blockquote>
<h2 id="哈希-map-储存键值对"><a href="#哈希-map-储存键值对" class="headerlink" title="哈希 map 储存键值对"></a><a target="_blank" rel="noopener" href="https://rustwiki.org/zh-CN/book/ch08-03-hash-maps.html#%E5%93%88%E5%B8%8C-map-%E5%82%A8%E5%AD%98%E9%94%AE%E5%80%BC%E5%AF%B9">哈希 map 储存键值对</a></h2><p>最后介绍的常用集合类型是 <strong>哈希 map</strong>（<em>hash map</em>）。<code>HashMap&lt;K, V&gt;</code> 类型储存了一个键类型 <code>K</code> 对应一个值类型 <code>V</code> 的映射。它通过一个 <strong>哈希函数</strong>（<em>hashing function</em>）来实现映射，决定如何将键和值放入内存中。很多编程语言支持这种数据结构，不过通常有不同的名字：哈希、map、对象、哈希表或者关联数组，仅举几例。</p>
<p>哈希 map 可以用于需要任何类型作为键来寻找数据的情况，而不是像 vector 那样通过索引。例如，在一个游戏中，你可以将每个团队的分数记录到哈希 map 中，其中键是队伍的名字而值是每个队伍的分数。给出一个队名，就能得到他们的得分。</p>
<p>本章我们会介绍哈希 map 的基本 API，不过还有更多吸引人的功能隐藏于标准库在 <code>HashMap&lt;K, V&gt;</code> 上定义的函数中。一如既往请查看标准库文档来了解更多信息。</p>
<h3 id="新建一个哈希-map"><a href="#新建一个哈希-map" class="headerlink" title="新建一个哈希 map"></a><a target="_blank" rel="noopener" href="https://rustwiki.org/zh-CN/book/ch08-03-hash-maps.html#%E6%96%B0%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%93%88%E5%B8%8C-map">新建一个哈希 map</a></h3><p>可以使用 <code>new</code> 创建一个空的 <code>HashMap</code>，并使用 <code>insert</code> 增加元素。在示例 8-20 中我们记录两支队伍的分数，分别是蓝队和黄队。蓝队开始有 10 分而黄队开始有 50 分：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">scores</span> = HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line">scores.<span class="title function_ invoke__">insert</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Blue&quot;</span>), <span class="number">10</span>);</span><br><span class="line">scores.<span class="title function_ invoke__">insert</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Yellow&quot;</span>), <span class="number">50</span>);</span><br></pre></td></tr></table></figure>

<p>示例 8-20：新建一个哈希 map 并插入一些键值对</p>
<p>注意必须首先 <code>use</code> 标准库中集合部分的 <code>HashMap</code>。在这三个常用集合中，<code>HashMap</code> 是最不常用的，所以并没有被 prelude 自动引用。标准库中对 <code>HashMap</code> 的支持也相对较少，例如，并没有内建的构建宏。</p>
<p>像 vector 一样，哈希 map 将它们的数据储存在堆上，这个 <code>HashMap</code> 的键类型是 <code>String</code> 而值类型是 <code>i32</code>。类似于 vector，哈希 map 是同质的：所有的键必须是相同类型，值也必须都是相同类型。</p>
<p>另一个构建哈希 map 的方法是使用一个元组的 vector 的 <code>collect</code> 方法，其中每个元组包含一个键值对。<code>collect</code> 方法可以将数据收集进一系列的集合类型，包括 <code>HashMap</code>。例如，如果队伍的名字和初始分数分别在两个 vector 中，可以使用 <code>zip</code> 方法来创建一个元组的 vector，其中 “Blue” 与 10 是一对，依此类推。接着就可以使用 <code>collect</code> 方法将这个元组 vector 转换成一个 <code>HashMap</code>，如示例 8-21 所示：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">teams</span>  = <span class="built_in">vec!</span>[<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Blue&quot;</span>), <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Yellow&quot;</span>)];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">initial_scores</span> = <span class="built_in">vec!</span>[<span class="number">10</span>, <span class="number">50</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">scores</span>: HashMap&lt;_, _&gt; = teams.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">zip</span>(initial_scores.<span class="title function_ invoke__">iter</span>()).<span class="title function_ invoke__">collect</span>();</span><br></pre></td></tr></table></figure>

<p>示例 8-21：用队伍列表和分数列表创建哈希 map</p>
<p>这里 <code>HashMap&lt;_, _&gt;</code> 类型标注是必要的，因为 <code>collect</code> 有可能当成多种不同的数据结构，而除非显式指定否则 Rust 无从得知你需要的类型。但是对于键和值的类型参数来说，可以使用下划线占位，而 Rust 能够根据 vector 中数据的类型推断出 <code>HashMap</code> 所包含的类型。</p>
<h3 id="哈希-map-和所有权"><a href="#哈希-map-和所有权" class="headerlink" title="哈希 map 和所有权"></a><a target="_blank" rel="noopener" href="https://rustwiki.org/zh-CN/book/ch08-03-hash-maps.html#%E5%93%88%E5%B8%8C-map-%E5%92%8C%E6%89%80%E6%9C%89%E6%9D%83">哈希 map 和所有权</a></h3><p>对于像 <code>i32</code> 这样的实现了 <code>Copy</code> trait 的类型，其值可以拷贝进哈希 map。对于像 <code>String</code> 这样拥有所有权的值，其值将被移动而哈希 map 会成为这些值的所有者，如示例 8-22 所示：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">field_name</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Favorite color&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">field_value</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Blue&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">map</span> = HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line">map.<span class="title function_ invoke__">insert</span>(field_name, field_value);</span><br><span class="line"><span class="comment">// 这里 field_name 和 field_value 不再有效，</span></span><br><span class="line"><span class="comment">// 尝试使用它们看看会出现什么编译错误！</span></span><br></pre></td></tr></table></figure>

<p>示例 8-22：展示一旦键值对被插入后就为哈希 map 所拥有</p>
<p>当 <code>insert</code> 调用将 <code>field_name</code> 和 <code>field_value</code> 移动到哈希 map 中后，将不能使用这两个绑定。</p>
<p>如果将值的引用插入哈希 map，这些值本身将不会被移动进哈希 map。但是这些引用指向的值必须至少在哈希 map 有效时也是有效的。第 10 章 <a target="_blank" rel="noopener" href="https://rustwiki.org/zh-CN/book/ch10-03-lifetime-syntax.html#validating-references-with-lifetimes">“生命周期与引用有效性”</a> 部分将会更多的讨论这个问题。</p>
<h3 id="访问哈希-map-中的值"><a href="#访问哈希-map-中的值" class="headerlink" title="访问哈希 map 中的值"></a><a target="_blank" rel="noopener" href="https://rustwiki.org/zh-CN/book/ch08-03-hash-maps.html#%E8%AE%BF%E9%97%AE%E5%93%88%E5%B8%8C-map-%E4%B8%AD%E7%9A%84%E5%80%BC">访问哈希 map 中的值</a></h3><p>可以通过 <code>get</code> 方法并提供对应的键来从哈希 map 中获取值，如示例 8-23 所示：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">scores</span> = HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line">scores.<span class="title function_ invoke__">insert</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Blue&quot;</span>), <span class="number">10</span>);</span><br><span class="line">scores.<span class="title function_ invoke__">insert</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Yellow&quot;</span>), <span class="number">50</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">team_name</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Blue&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">score</span> = scores.<span class="title function_ invoke__">get</span>(&amp;team_name);</span><br></pre></td></tr></table></figure>

<p>示例 8-23：访问哈希 map 中储存的蓝队分数</p>
<p>这里，<code>score</code> 是与蓝队分数相关的值，应为 <code>Some(10)</code>。因为 <code>get</code> 返回 <code>Option&lt;V&gt;</code>，所以结果被装进 <code>Some</code>；如果某个键在哈希 map 中没有对应的值，<code>get</code> 会返回 <code>None</code>。这时就要用某种第 6 章提到的方法之一来处理 <code>Option</code>。</p>
<p>可以使用与 vector 类似的方式来遍历哈希 map 中的每一个键值对，也就是 <code>for</code> 循环：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">scores</span> = HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line">scores.<span class="title function_ invoke__">insert</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Blue&quot;</span>), <span class="number">10</span>);</span><br><span class="line">scores.<span class="title function_ invoke__">insert</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Yellow&quot;</span>), <span class="number">50</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (key, value) <span class="keyword">in</span> &amp;scores &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;: &#123;&#125;&quot;</span>, key, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这会以任意顺序打印出每一个键值对：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Yellow: <span class="number">50</span></span><br><span class="line">Blue: <span class="number">10</span></span><br></pre></td></tr></table></figure>

<h3 id="更新哈希-map"><a href="#更新哈希-map" class="headerlink" title="更新哈希 map"></a><a target="_blank" rel="noopener" href="https://rustwiki.org/zh-CN/book/ch08-03-hash-maps.html#%E6%9B%B4%E6%96%B0%E5%93%88%E5%B8%8C-map">更新哈希 map</a></h3><p>尽管键值对的数量是可以增长的，不过任何时候，每个键只能关联一个值。当我们想要改变哈希 map 中的数据时，必须决定如何处理一个键已经有值了的情况。可以选择完全无视旧值并用新值代替旧值。可以选择保留旧值而忽略新值，并只在键 <strong>没有</strong> 对应值时增加新值。或者可以结合新旧两值。让我们看看这分别该如何处理！</p>
<h4 id="覆盖一个值"><a href="#覆盖一个值" class="headerlink" title="覆盖一个值"></a><a target="_blank" rel="noopener" href="https://rustwiki.org/zh-CN/book/ch08-03-hash-maps.html#%E8%A6%86%E7%9B%96%E4%B8%80%E4%B8%AA%E5%80%BC">覆盖一个值</a></h4><p>如果我们插入了一个键值对，接着用相同的键插入一个不同的值，与这个键相关联的旧值将被替换。即便示例 8-24 中的代码调用了两次 <code>insert</code>，哈希 map 也只会包含一个键值对，因为两次都是对蓝队的键插入的值：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">scores</span> = HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line">scores.<span class="title function_ invoke__">insert</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Blue&quot;</span>), <span class="number">10</span>);</span><br><span class="line">scores.<span class="title function_ invoke__">insert</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Blue&quot;</span>), <span class="number">25</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, scores);</span><br></pre></td></tr></table></figure>

<p>示例 8-24：替换以特定键储存的值</p>
<p>这会打印出 <code>&#123;&quot;Blue&quot;: 25&#125;</code>。原始的值 <code>10</code> 则被覆盖了。</p>
<h4 id="只在键没有对应值时插入"><a href="#只在键没有对应值时插入" class="headerlink" title="只在键没有对应值时插入"></a><a target="_blank" rel="noopener" href="https://rustwiki.org/zh-CN/book/ch08-03-hash-maps.html#%E5%8F%AA%E5%9C%A8%E9%94%AE%E6%B2%A1%E6%9C%89%E5%AF%B9%E5%BA%94%E5%80%BC%E6%97%B6%E6%8F%92%E5%85%A5">只在键没有对应值时插入</a></h4><p>我们经常会检查某个特定的键是否有值，如果没有就插入一个值。为此哈希 map 有一个特有的 API，叫做 <code>entry</code>，它获取我们想要检查的键作为参数。<code>entry</code> 函数的返回值是一个枚举，<code>Entry</code>，它代表了可能存在也可能不存在的值。比如说我们想要检查黄队的键是否关联了一个值。如果没有，就插入值 50，对于蓝队也是如此。使用 entry API 的代码看起来像示例 8-25 这样：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">scores</span> = HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line">scores.<span class="title function_ invoke__">insert</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Blue&quot;</span>), <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">scores.<span class="title function_ invoke__">entry</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Yellow&quot;</span>)).<span class="title function_ invoke__">or_insert</span>(<span class="number">50</span>);</span><br><span class="line">scores.<span class="title function_ invoke__">entry</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Blue&quot;</span>)).<span class="title function_ invoke__">or_insert</span>(<span class="number">50</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, scores);</span><br></pre></td></tr></table></figure>

<p>示例 8-25：使用 <code>entry</code> 方法只在键没有对应一个值时插入</p>
<p><code>Entry</code> 的 <code>or_insert</code> 方法在键对应的值存在时就返回这个值的可变引用，如果不存在则将参数作为新值插入并返回新值的可变引用。这比编写自己的逻辑要简明的多，另外也与借用检查器结合得更好。</p>
<p>运行示例 8-25 的代码会打印出 <code>&#123;&quot;Yellow&quot;: 50, &quot;Blue&quot;: 10&#125;</code>。第一个 <code>entry</code> 调用会插入黄队的键和值 <code>50</code>，因为黄队并没有一个值。第二个 <code>entry</code> 调用不会改变哈希 map 因为蓝队已经有了值 <code>10</code>。</p>
<h4 id="根据旧值更新一个值"><a href="#根据旧值更新一个值" class="headerlink" title="根据旧值更新一个值"></a><a target="_blank" rel="noopener" href="https://rustwiki.org/zh-CN/book/ch08-03-hash-maps.html#%E6%A0%B9%E6%8D%AE%E6%97%A7%E5%80%BC%E6%9B%B4%E6%96%B0%E4%B8%80%E4%B8%AA%E5%80%BC">根据旧值更新一个值</a></h4><p>另一个常见的哈希 map 的应用场景是找到一个键对应的值并根据旧的值更新它。例如，示例 8-26  中的代码计数一些文本中每一个单词分别出现了多少次。我们使用哈希 map  以单词作为键并递增其值来记录我们遇到过几次这个单词。如果是第一次看到某个单词，就插入值 <code>0</code>。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">text</span> = <span class="string">&quot;hello world wonderful world&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">map</span> = HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="variable">word</span> <span class="keyword">in</span> text.<span class="title function_ invoke__">split_whitespace</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">count</span> = map.<span class="title function_ invoke__">entry</span>(word).<span class="title function_ invoke__">or_insert</span>(<span class="number">0</span>);</span><br><span class="line">    *count += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, map);</span><br></pre></td></tr></table></figure>

<p>示例 8-26：通过哈希 map 储存单词和计数来统计出现次数</p>
<p>这会打印出 <code>&#123;&quot;world&quot;: 2, &quot;hello&quot;: 1, &quot;wonderful&quot;: 1&#125;</code>，<code>or_insert</code> 方法事实上会返回这个键的值的一个可变引用（<code>&amp;mut V</code>）。这里我们将这个可变引用储存在 <code>count</code> 变量中，所以为了赋值必须首先使用星号（<code>*</code>）解引用 <code>count</code>。这个可变引用在 <code>for</code> 循环的结尾离开作用域，这样所有这些改变都是安全的并符合借用规则。</p>
<h3 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a><a target="_blank" rel="noopener" href="https://rustwiki.org/zh-CN/book/ch08-03-hash-maps.html#%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0">哈希函数</a></h3><p><code>HashMap</code> 默认使用一种 “密码学安全的”（“cryptographically strong” ）<a target="_blank" rel="noopener" href="https://rustwiki.org/zh-CN/book/ch08-03-hash-maps.html#siphash">1</a> 哈希函数，它可以抵抗拒绝服务（Denial of Service, DoS）攻击。然而这并不是可用的最快的算法，不过为了更高的安全性值得付出一些性能的代价。如果性能监测显示此哈希函数非常慢，以致于你无法接受，你可以指定一个不同的 <em>hasher</em> 来切换为其它函数。hasher 是一个实现了 <code>BuildHasher</code> trait 的类型。第 10 章会讨论 trait 和如何实现它们。你并不需要从头开始实现你自己的 hasher；<a target="_blank" rel="noopener" href="https://crates.io/">crates.io</a> 有其他人分享的实现了许多常用哈希算法的 hasher 的库。</p>

    </div>

    
    
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>Chillward
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://example.com/2025/07/25/RUST%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0%E4%B9%8B%E5%B8%B8%E8%A7%81%E9%9B%86%E5%90%88/" title="RUST学习日记之常见集合">http://example.com/2025/07/25/RUST学习日记之常见集合/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/zh-CN" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/RUST/" rel="tag"># RUST</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2025/07/24/RUST%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0%E4%B9%8B%E6%A8%A1%E5%9D%9703/" rel="prev" title="RUST学习日记之模块03">
      <i class="fa fa-chevron-left"></i> RUST学习日记之模块03
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Vector"><span class="nav-number">1.</span> <span class="nav-text">Vector</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Vector%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">1.1.</span> <span class="nav-text">Vector的初始化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Vector%E7%9A%84%E6%9B%B4%E6%96%B0"><span class="nav-number">1.2.</span> <span class="nav-text">Vector的更新</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Vector%E5%85%83%E7%B4%A0%E7%9A%84%E8%AF%BB%E5%8F%96"><span class="nav-number">1.3.</span> <span class="nav-text">Vector元素的读取</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%81%8D%E5%8E%86Vector%E4%B8%AD%E7%9A%84%E5%85%83%E7%B4%A0"><span class="nav-number">1.4.</span> <span class="nav-text">遍历Vector中的元素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%9E%9A%E4%B8%BE%E6%9D%A5%E5%82%A8%E5%AD%98%E5%A4%9A%E7%A7%8D%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.5.</span> <span class="nav-text">使用枚举来储存多种类型</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#String%E7%B1%BB%E5%9E%8B"><span class="nav-number">2.</span> <span class="nav-text">String类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B0%E5%BB%BA%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">2.1.</span> <span class="nav-text">新建字符串</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9B%B4%E6%96%B0%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">2.2.</span> <span class="nav-text">更新字符串</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-push-str-%E5%92%8C-push-%E9%99%84%E5%8A%A0%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">2.2.1.</span> <span class="nav-text">使用 push_str 和 push 附加字符串</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-%E8%BF%90%E7%AE%97%E7%AC%A6%E6%88%96-format-%E5%AE%8F%E6%8B%BC%E6%8E%A5%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">2.2.2.</span> <span class="nav-text">使用 + 运算符或 format! 宏拼接字符串</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">2.3.</span> <span class="nav-text">索引字符串</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%85%E9%83%A8%E8%A1%A8%E7%8E%B0"><span class="nav-number">2.3.1.</span> <span class="nav-text">内部表现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%97%E8%8A%82%E3%80%81%E6%A0%87%E9%87%8F%E5%80%BC%E5%92%8C%E5%AD%97%E5%BD%A2%E7%B0%87%EF%BC%81%E5%A4%A9%E5%91%90%EF%BC%81"><span class="nav-number">2.3.2.</span> <span class="nav-text">字节、标量值和字形簇！天呐！</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2-slice"><span class="nav-number">2.4.</span> <span class="nav-text">字符串 slice</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%81%8D%E5%8E%86%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">2.5.</span> <span class="nav-text">遍历字符串的方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B9%B6%E4%B8%8D%E7%AE%80%E5%8D%95"><span class="nav-number">2.6.</span> <span class="nav-text">字符串并不简单</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%93%88%E5%B8%8C-map-%E5%82%A8%E5%AD%98%E9%94%AE%E5%80%BC%E5%AF%B9"><span class="nav-number">3.</span> <span class="nav-text">哈希 map 储存键值对</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B0%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%93%88%E5%B8%8C-map"><span class="nav-number">3.1.</span> <span class="nav-text">新建一个哈希 map</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%93%88%E5%B8%8C-map-%E5%92%8C%E6%89%80%E6%9C%89%E6%9D%83"><span class="nav-number">3.2.</span> <span class="nav-text">哈希 map 和所有权</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BF%E9%97%AE%E5%93%88%E5%B8%8C-map-%E4%B8%AD%E7%9A%84%E5%80%BC"><span class="nav-number">3.3.</span> <span class="nav-text">访问哈希 map 中的值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9B%B4%E6%96%B0%E5%93%88%E5%B8%8C-map"><span class="nav-number">3.4.</span> <span class="nav-text">更新哈希 map</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A6%86%E7%9B%96%E4%B8%80%E4%B8%AA%E5%80%BC"><span class="nav-number">3.4.1.</span> <span class="nav-text">覆盖一个值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%AA%E5%9C%A8%E9%94%AE%E6%B2%A1%E6%9C%89%E5%AF%B9%E5%BA%94%E5%80%BC%E6%97%B6%E6%8F%92%E5%85%A5"><span class="nav-number">3.4.2.</span> <span class="nav-text">只在键没有对应值时插入</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%B9%E6%8D%AE%E6%97%A7%E5%80%BC%E6%9B%B4%E6%96%B0%E4%B8%80%E4%B8%AA%E5%80%BC"><span class="nav-number">3.4.3.</span> <span class="nav-text">根据旧值更新一个值</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0"><span class="nav-number">3.5.</span> <span class="nav-text">哈希函数</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Chillward"
      src="/uploads/avatar.png">
  <p class="site-author-name" itemprop="name">Chillward</p>
  <div class="site-description" itemprop="description">谁躺在漆黑的舞台上，用身体迎接着光芒</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">10</span>
          <span class="site-state-item-name">博客</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/zh-CN" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Chillward</span>
</div>
  <div class="powered-by">
    <!--由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动 -->
  </div>

<!-- 网站运行时间的设置 -->
<span id="timeDate">载入天数...</span>
<span id="times">载入时分秒...</span>
<script>
    var now = new Date();
    function createtime() {
        var grt= new Date("07/16/2025 10:00:00"); //此处修改你的建站时间或者网站上线时间
        now.setTime(now.getTime()+250);
        days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days);
        hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours);
        if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);
        mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;}
        seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
        snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;}
        document.getElementById("timeDate").innerHTML = "本站已安全运行 "+dnum+" 天 ";
        document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒.";
    }
setInterval("createtime()",250);
</script>
        








	 </div>
    </footer>
  </div>

  
  <script size="300" alpha="0.6" zIndex="-1" src="/lib/canvas-ribbon/canvas-ribbon.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/pjax/pjax.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/lozad@1/dist/lozad.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/pangu@4/dist/browser/pangu.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  




  
<script src="/js/local-search.js"></script>











<script data-pjax>
if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.initialize({
      theme    : 'dark',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    });
  }, window.mermaid);
}
</script>


    <div id="pjax">
  

  

    </div>
</body>
</html>
