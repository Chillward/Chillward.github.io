<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":true,"pangu":true,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="谁躺在漆黑的舞台上，用身体迎接着光芒">
<meta property="og:type" content="website">
<meta property="og:title" content="Chillward的博客">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Chillward的博客">
<meta property="og:description" content="谁躺在漆黑的舞台上，用身体迎接着光芒">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Chillward">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Chillward的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Chillward的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/07/21/RUST%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0%E4%B9%8B%E6%9E%9A%E4%B8%BE%E5%92%8C%E7%BB%93%E6%9E%84%E5%8C%B9%E9%85%8D/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.png">
      <meta itemprop="name" content="Chillward">
      <meta itemprop="description" content="谁躺在漆黑的舞台上，用身体迎接着光芒">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chillward的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/07/21/RUST%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0%E4%B9%8B%E6%9E%9A%E4%B8%BE%E5%92%8C%E7%BB%93%E6%9E%84%E5%8C%B9%E9%85%8D/" class="post-title-link" itemprop="url">RUST学习日记之枚举和结构匹配</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-07-21 16:34:40 / 修改时间：19:08:24" itemprop="dateCreated datePublished" datetime="2025-07-21T16:34:40+08:00">2025-07-21</time>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>17k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>31 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>RUST中的枚举远比C语言中的强大的多。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">IpAddrKind</span> &#123;</span><br><span class="line">    V4,</span><br><span class="line">    V6,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">four</span> = IpAddrKind::V4;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">six</span> = IpAddrKind::V6;</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">route</span>(IpAddrKind::V4);</span><br><span class="line">    <span class="title function_ invoke__">route</span>(IpAddrKind::V6);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">route</span>(ip_kind: IpAddrKind) &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>第一个巨大的不同之处就是:RUST的枚举可以关联不同类型和数量的数据</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">IpAddr</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">V4</span>(<span class="type">u8</span>, <span class="type">u8</span>, <span class="type">u8</span>, <span class="type">u8</span>),</span><br><span class="line">    <span class="title function_ invoke__">V6</span>(<span class="type">String</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">home</span> = IpAddr::<span class="title function_ invoke__">V4</span>(<span class="number">127</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">loopback</span> = IpAddr::<span class="title function_ invoke__">V6</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;::1&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>这无疑是非常灵活方便的，当然RUST的枚举可以关联结构体，甚至可以再关联一个枚举。</p>
<p>RUST还允许我们像给结构体定义方法一样给枚举定义方法</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">Message</span> &#123;</span><br><span class="line">        Quit,</span><br><span class="line">        Move &#123; x: <span class="type">i32</span>, y: <span class="type">i32</span> &#125;,</span><br><span class="line">        <span class="title function_ invoke__">Write</span>(<span class="type">String</span>),</span><br><span class="line">        <span class="title function_ invoke__">ChangeColor</span>(<span class="type">i32</span>, <span class="type">i32</span>, <span class="type">i32</span>),</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">impl</span> <span class="title class_">Message</span> &#123;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">call</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">            <span class="comment">// 在这里定义方法体</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">m</span> = Message::<span class="title function_ invoke__">Write</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>));</span><br><span class="line">    m.<span class="title function_ invoke__">call</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Option枚举"><a href="#Option枚举" class="headerlink" title="Option枚举"></a>Option枚举</h3><p>RUST中没有类似于C语言的NULL这种东西，在C语言中，假设你malloc&#x2F;calloc一个内存区域，如果失败了，会返回一个NULL，调用者需要手动处理NULL的情况，不然程序就会出现bug，而RUST通过Option枚举避免了这种问题。</p>
<p>问题不在于概念而在于具体的实现。为此，Rust 并没有空值，不过它确实拥有一个可以编码存在或不存在概念的枚举。这个枚举是 <code>Option&lt;T&gt;</code>，而且它<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/option/enum.Option.html">定义于标准库中</a>，如下：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#![allow(unused)]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Option</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="literal">None</span>,</span><br><span class="line">    <span class="title function_ invoke__">Some</span>(T),</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Option&lt;T&gt;</code> 枚举是如此有用以至于它甚至被包含在了 prelude 之中，无需将其显式引入作用域。另外，它的变体也是如此：可以不需要 <code>Option::</code> 前缀来直接使用 <code>Some</code> 和 <code>None</code>。即便如此 <code>Option&lt;T&gt;</code> 也仍是常规的枚举，<code>Some(T)</code> 和 <code>None</code> 仍是 <code>Option&lt;T&gt;</code> 的变体。</p>
<p><code>&lt;T&gt;</code> 语法是一个我们还未讲到的 Rust 功能。它是一个泛型类型参数，第十章会更详细的讲解泛型。目前，所有你需要知道的就是 <code>&lt;T&gt;</code> 意味着 <code>Option</code> 枚举的 <code>Some</code> 变体可以包含任意类型的数据，同时每一个用于 <code>T</code> 位置的具体类型使得 <code>Option&lt;T&gt;</code> 整体作为不同的类型。这里是一些包含数字类型和字符类型 <code>Option</code> 值的例子：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">some_number</span> = <span class="title function_ invoke__">Some</span>(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">some_char</span> = <span class="title function_ invoke__">Some</span>(<span class="string">&#x27;e&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">absent_number</span>: <span class="type">Option</span>&lt;<span class="type">i32</span>&gt; = <span class="literal">None</span>;</span><br></pre></td></tr></table></figure>

<p><code>some_number</code> 的类型是 <code>Option&lt;i32&gt;</code>。<code>some_char</code> 的类型是 <code>Option&lt;char&gt;</code>，是不同于 <code>some_number</code> 的类型。因为我们在 <code>Some</code> 变体中指定了值，Rust 可以推断其类型。对于 <code>absent_number</code>，Rust 需要我们指定 <code>Option</code> 整体的类型，因为编译器只通过 <code>None</code> 值无法推断出 <code>Some</code> 变体保存的值的类型。这里我们告诉 Rust 希望 <code>absent_number</code> 是 <code>Option&lt;i32&gt;</code> 类型的。</p>
<p>当有一个 <code>Some</code> 值时，我们就知道存在一个值，而这个值保存在 <code>Some</code> 中。当有个 <code>None</code> 值时，在某种意义上，它跟空值具有相同的意义：并没有一个有效的值。那么，<code>Option&lt;T&gt;</code> 为什么就比空值要好呢？</p>
<p>简而言之，因为 <code>Option&lt;T&gt;</code> 和 <code>T</code>（这里 <code>T</code> 可以是任何类型）是不同的类型，编译器不允许像一个肯定有效的值那样使用 <code>Option&lt;T&gt;</code>。例如，这段代码不能编译，因为它尝试将 <code>Option&lt;i8&gt;</code> 与 <code>i8</code> 相加：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">x</span>: <span class="type">i8</span> = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">y</span>: <span class="type">Option</span>&lt;<span class="type">i8</span>&gt; = <span class="title function_ invoke__">Some</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">sum</span> = x + y;</span><br></pre></td></tr></table></figure>

<p>如果运行这些代码，将得到类似这样的错误信息：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cargo run</span></span><br><span class="line">   Compiling enums v0.1.0 (file:///projects/enums)</span><br><span class="line">error[E0277]: cannot add `Option&lt;i8&gt;` to `i8`</span><br><span class="line"><span class="meta prompt_"> --&gt; </span><span class="language-bash">src/main.rs:5:17</span></span><br><span class="line">  |</span><br><span class="line">5 |     let sum = x + y;</span><br><span class="line">  |                 ^ no implementation for `i8 + Option&lt;i8&gt;`</span><br><span class="line">  |</span><br><span class="line">  = help: the trait `Add&lt;Option&lt;i8&gt;&gt;` is not implemented for `i8`</span><br><span class="line">  = help: the following other types implement trait `Add&lt;Rhs&gt;`:</span><br><span class="line">            `&amp;i8` implements `Add&lt;i8&gt;`</span><br><span class="line">            `&amp;i8` implements `Add`</span><br><span class="line">            `i8` implements `Add&lt;&amp;i8&gt;`</span><br><span class="line">            `i8` implements `Add`</span><br><span class="line"></span><br><span class="line">For more information about this error, try `rustc --explain E0277`.</span><br><span class="line">error: could not compile `enums` (bin &quot;enums&quot;) due to 1 previous error</span><br></pre></td></tr></table></figure>

<p>很好！事实上，错误信息意味着 Rust 不知道该如何将 <code>Option&lt;i8&gt;</code> 与 <code>i8</code> 相加，因为它们的类型不同。当在 Rust 中拥有一个像 <code>i8</code> 这样类型的值时，编译器确保它总是有一个有效的值。我们可以自信地使用而无需做空值检查。只有当使用 <code>Option&lt;i8&gt;</code>（或者任何用到的类型）的时候需要担心可能没有值，而编译器会确保我们在使用值之前处理了为空的情况。</p>
<p>换句话说，在对 <code>Option&lt;T&gt;</code> 进行运算之前必须将其转换为 <code>T</code>。通常这能帮助我们捕获到空值最常见的问题之一：假设某值不为空但实际上为空的情况。</p>
<p>消除了错误地假设一个非空值的风险，会让你对代码更加有信心。为了拥有一个可能为空的值，你必须要显式的将其放入对应类型的 <code>Option&lt;T&gt;</code> 中。接着，当使用这个值时，必须明确的处理值为空的情况。只要一个值不是 <code>Option&lt;T&gt;</code> 类型，你就<strong>可以</strong>安全的认定它的值不为空。这是 Rust 的一个经过深思熟虑的设计决策，来限制空值的泛滥以增加 Rust 代码的安全性。</p>
<p>那么当有一个 <code>Option&lt;T&gt;</code> 的值时，如何从 <code>Some</code> 变体中取出 <code>T</code> 的值来使用它呢？<code>Option&lt;T&gt;</code> 枚举拥有大量用于各种情况的方法：你可以查看<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/option/enum.Option.html">它的文档</a>。熟悉 <code>Option&lt;T&gt;</code> 的方法将对你的 Rust 之旅非常有用。</p>
<p>总的来说，为了使用 <code>Option&lt;T&gt;</code> 值，需要编写处理每个变体的代码。你想要一些代码只当拥有 <code>Some(T)</code> 值时运行，允许这些代码使用其中的 <code>T</code>。也希望一些代码只在值为 <code>None</code> 时运行，这些代码并没有一个可用的 <code>T</code> 值。<code>match</code> 表达式就是这么一个处理枚举的控制流结构：它会根据枚举的变体运行不同的代码，这些代码可以使用匹配到的值中的数据。</p>
<p>除了match跟if let外，还有以下方法可以提取Option&lt;&gt;中的值</p>
<h3 id="unwrap-和-expect"><a href="#unwrap-和-expect" class="headerlink" title="unwrap() 和 expect()"></a><code>unwrap()</code> 和 <code>expect()</code></h3><p><code>unwrap()</code> 和 <code>expect()</code> 是提取 <code>Option</code> 值的直接方法，但它们是不安全的，因为它们在 <code>Option</code> 是 <code>None</code> 时会<strong>panic</strong>（导致程序崩溃）。</p>
<ul>
<li><p><strong><code>unwrap()</code></strong>: 如果 <code>Option</code> 是 <code>Some(T)</code>，它会返回 <code>T</code>。如果 <code>Option</code> 是 <code>None</code>，它会 panic。</p>
<p>Rust</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let some_value = Some(100);</span><br><span class="line">    let value = some_value.unwrap(); // value is 100</span><br><span class="line">    println!(&quot;Unwrapped value: &#123;&#125;&quot;, value);</span><br><span class="line"></span><br><span class="line">    let none_value: Option&lt;i32&gt; = None;</span><br><span class="line">    // let another_value = none_value.unwrap(); // 这行代码会导致 panic!</span><br><span class="line">    // println!(&quot;Another unwrapped value: &#123;&#125;&quot;, another_value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>expect(&quot;自定义错误信息&quot;)</code></strong>: 和 <code>unwrap()</code> 类似，但允许你提供一个自定义的 panic 错误信息，这在调试时很有用。</p>
<p>Rust</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let file_content = Some(String::from(&quot;Some text in the file.&quot;));</span><br><span class="line">    let content = file_content.expect(&quot;文件内容不存在！&quot;);</span><br><span class="line">    println!(&quot;文件内容: &#123;&#125;&quot;, content);</span><br><span class="line"></span><br><span class="line">    let empty_file: Option&lt;String&gt; = None;</span><br><span class="line">    // let empty_content = empty_file.expect(&quot;读取文件失败，文件为空或不存在。&quot;); // 这行代码会导致 panic!</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>重要提示：</strong> 除非你百分之百确定 <code>Option</code> 永远不会是 <code>None</code>（或者在 <code>None</code> 的情况下程序崩溃是可以接受的），否则<strong>应避免使用 <code>unwrap()</code> 和 <code>expect()</code></strong>。它们主要用于原型开发、测试或在明确知道 <code>None</code> 是一个不可恢复的错误时。</p>
<h3 id="unwrap-or-unwrap-or-default-unwrap-or-else"><a href="#unwrap-or-unwrap-or-default-unwrap-or-else" class="headerlink" title="unwrap_or(), unwrap_or_default(), unwrap_or_else()"></a><code>unwrap_or()</code>, <code>unwrap_or_default()</code>, <code>unwrap_or_else()</code></h3><p>这些方法提供了在 <code>Option</code> 是 <code>None</code> 时提供一个默认值或通过闭包计算一个默认值的方式，而不会 panic。</p>
<ul>
<li><p><strong><code>unwrap_or(default_value)</code></strong>: 如果 <code>Option</code> 是 <code>Some(T)</code>，返回 <code>T</code>。如果 <code>Option</code> 是 <code>None</code>，返回提供的 <code>default_value</code>。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">user_input</span> = <span class="title function_ invoke__">Some</span>(<span class="string">&quot;Hello&quot;</span>.<span class="title function_ invoke__">to_string</span>());</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span> = user_input.<span class="title function_ invoke__">unwrap_or</span>(<span class="string">&quot;Guest&quot;</span>.<span class="title function_ invoke__">to_string</span>());</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;欢迎: &#123;&#125;&quot;</span>, result); <span class="comment">// 输出: 欢迎: Hello</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">no_input</span>: <span class="type">Option</span>&lt;<span class="type">String</span>&gt; = <span class="literal">None</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result_none</span> = no_input.<span class="title function_ invoke__">unwrap_or</span>(<span class="string">&quot;Guest&quot;</span>.<span class="title function_ invoke__">to_string</span>());</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;欢迎: &#123;&#125;&quot;</span>, result_none); <span class="comment">// 输出: 欢迎: Guest</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>unwrap_or_default()</code></strong>: 如果 <code>Option</code> 是 <code>Some(T)</code>，返回 <code>T</code>。如果 <code>Option</code> 是 <code>None</code>，返回 <code>T</code> 类型的默认值（要求 <code>T</code> 实现 <code>Default</code> trait）。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">count</span> = <span class="title function_ invoke__">Some</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">num</span> = count.<span class="title function_ invoke__">unwrap_or_default</span>(); <span class="comment">// num 是 5</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Count: &#123;&#125;&quot;</span>, num);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">no_count</span>: <span class="type">Option</span>&lt;<span class="type">u32</span>&gt; = <span class="literal">None</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">default_num</span> = no_count.<span class="title function_ invoke__">unwrap_or_default</span>(); <span class="comment">// default_num 是 0 (u32 的默认值)</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Default Count: &#123;&#125;&quot;</span>, default_num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>unwrap_or_else(|| &#123; /\* 闭包计算默认值 \*/ &#125;)</code></strong>: 如果 <code>Option</code> 是 <code>Some(T)</code>，返回 <code>T</code>。如果 <code>Option</code> 是 <code>None</code>，执行提供的闭包并返回其结果。这在计算默认值比较复杂或有副作用时很有用。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">get_default_username</span>() <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;正在生成默认用户名...&quot;</span>);</span><br><span class="line">    <span class="string">&quot;Anonymous&quot;</span>.<span class="title function_ invoke__">to_string</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">username</span> = <span class="title function_ invoke__">Some</span>(<span class="string">&quot;Alice&quot;</span>.<span class="title function_ invoke__">to_string</span>());</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">final_username</span> = username.<span class="title function_ invoke__">unwrap_or_else</span>(|| <span class="title function_ invoke__">get_default_username</span>());</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;用户: &#123;&#125;&quot;</span>, final_username);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">no_username</span>: <span class="type">Option</span>&lt;<span class="type">String</span>&gt; = <span class="literal">None</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">final_no_username</span> = no_username.<span class="title function_ invoke__">unwrap_or_else</span>(|| <span class="title function_ invoke__">get_default_username</span>());</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;用户: &#123;&#125;&quot;</span>, final_no_username);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="5-其他辅助方法"><a href="#5-其他辅助方法" class="headerlink" title="5. 其他辅助方法"></a>5. 其他辅助方法</h3><p><code>Option</code> 还提供了许多其他有用的方法，例如：</p>
<ul>
<li><strong><code>is_some()</code></strong>: 返回 <code>true</code> 如果是 <code>Some</code>，否则返回 <code>false</code>。</li>
<li><strong><code>is_none()</code></strong>: 返回 <code>true</code> 如果是 <code>None</code>，否则返回 <code>false</code>。</li>
<li><strong><code>map(|value| new_value)</code></strong>: 如果是 <code>Some(T)</code>，应用闭包到 <code>T</code> 并返回 <code>Some(U)</code>；如果是 <code>None</code>，返回 <code>None</code>。用于转换 <code>Option</code> 内的值类型。</li>
<li><strong><code>and_then(|value| Option&lt;U&gt;)</code></strong>: 如果是 <code>Some(T)</code>，应用闭包到 <code>T</code>（闭包返回另一个 <code>Option</code>）并返回结果；如果是 <code>None</code>，返回 <code>None</code>。常用于链式处理多个可能失败的操作。</li>
</ul>
<h2 id="match-控制流结构"><a href="#match-控制流结构" class="headerlink" title="match 控制流结构"></a><a target="_blank" rel="noopener" href="https://kaisery.github.io/trpl-zh-cn/ch06-02-match.html#match-%E6%8E%A7%E5%88%B6%E6%B5%81%E7%BB%93%E6%9E%84"><code>match</code> 控制流结构</a></h2><p>Rust 有一个叫做 <code>match</code> 的极为强大的控制流运算符，它允许我们将一个值与一系列的模式相比较，并根据相匹配的模式执行相应代码。模式可由字面值、变量、通配符和许多其他内容构成；<a target="_blank" rel="noopener" href="https://kaisery.github.io/trpl-zh-cn/ch19-00-patterns.html">第十九章</a>会涉及到所有不同种类的模式以及它们的作用。<code>match</code> 的力量来源于模式的表现力，以及编译器能够确认所有可能情况均已被覆盖。</p>
<p>可以把 <code>match</code> 表达式想象成某种硬币分类器：硬币滑入有着不同大小孔洞的轨道，每一个硬币都会掉入符合它大小的孔洞。同样地，值也会通过 <code>match</code> 的每一个模式，并且在遇到第一个 “符合” 的模式时，值会进入相关联的代码块并在执行中被使用。</p>
<p>因为刚刚提到了硬币，让我们用它们来作为一个使用 <code>match</code> 的例子！我们可以编写一个函数来获取一个未知的美国硬币，并以一种类似验钞机的方式，确定它是何种硬币并返回它的美分值，如示例 6-3 中所示。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Coin</span> &#123;</span><br><span class="line">    Penny,</span><br><span class="line">    Nickel,</span><br><span class="line">    Dime,</span><br><span class="line">    Quarter,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">value_in_cents</span>(coin: Coin) <span class="punctuation">-&gt;</span> <span class="type">u8</span> &#123;</span><br><span class="line">    <span class="keyword">match</span> coin &#123;</span><br><span class="line">        Coin::Penny =&gt; <span class="number">1</span>,</span><br><span class="line">        Coin::Nickel =&gt; <span class="number">5</span>,</span><br><span class="line">        Coin::Dime =&gt; <span class="number">10</span>,</span><br><span class="line">        Coin::Quarter =&gt; <span class="number">25</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例 6-3：一个枚举和一个以枚举变体作为模式的 <code>match</code> 表达式</p>
<p>拆开 <code>value_in_cents</code> 函数中的 <code>match</code> 来看。首先，我们列出 <code>match</code> 关键字后跟一个表达式，在这个例子中是 <code>coin</code> 的值。这看起来非常像 <code>if</code> 所使用的条件表达式，不过这里有一个非常大的区别：对于 <code>if</code>，表达式必须返回一个布尔值，而这里它可以是任何类型的。例子中的 <code>coin</code> 的类型是示例 6-3 中定义的 <code>Coin</code> 枚举。</p>
<p>接下来是 <code>match</code> 的分支。一个分支有两个部分：一个模式和一些代码。第一个分支的模式是值 <code>Coin::Penny</code> 而之后的 <code>=&gt;</code> 运算符将模式和将要运行的代码分开。这里的代码就仅仅是值 <code>1</code>。每一个分支之间使用逗号分隔。</p>
<p>当 <code>match</code> 表达式执行时，它将结果值按顺序与每一个分支的模式相比较。如果模式匹配了这个值，这个模式相关联的代码将被执行。如果模式并不匹配这个值，将继续执行下一个分支，非常类似一个硬币分类器。可以拥有任意多的分支：示例 6-3 中的 <code>match</code> 有四个分支。</p>
<p>每个分支相关联的代码是一个表达式，而表达式的结果值将作为整个 <code>match</code> 表达式的返回值。</p>
<p>如果分支代码较短的话通常不使用大括号，正如示例 6-3 中的每个分支都只是返回一个值。如果想要在分支中运行多行代码，可以使用大括号，而分支后的逗号是可选的。例如，如下代码在每次使用<code>Coin::Penny</code> 调用时都会打印出 “Lucky penny!”，同时仍然返回代码块最后的值，<code>1</code>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">value_in_cents</span>(coin: Coin) <span class="punctuation">-&gt;</span> <span class="type">u8</span> &#123;</span><br><span class="line">    <span class="keyword">match</span> coin &#123;</span><br><span class="line">        Coin::Penny =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Lucky penny!&quot;</span>);</span><br><span class="line">            <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        Coin::Nickel =&gt; <span class="number">5</span>,</span><br><span class="line">        Coin::Dime =&gt; <span class="number">10</span>,</span><br><span class="line">        Coin::Quarter =&gt; <span class="number">25</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="绑定值的模式"><a href="#绑定值的模式" class="headerlink" title="绑定值的模式"></a><a target="_blank" rel="noopener" href="https://kaisery.github.io/trpl-zh-cn/ch06-02-match.html#%E7%BB%91%E5%AE%9A%E5%80%BC%E7%9A%84%E6%A8%A1%E5%BC%8F">绑定值的模式</a></h3><p>匹配分支的另一个有用的功能是可以绑定匹配的模式的部分值。这也就是如何从枚举变体中提取值的。</p>
<p>作为一个例子，让我们修改枚举的一个变体来存放数据。1999 年到 2008 年间，美国在 25 美分的硬币的一侧为 50 个州的每一个都印刷了不同的设计。其他的硬币都没有这种区分州的设计，所以只有这些 25 美分硬币有特殊的价值。可以将这些信息加入我们的 <code>enum</code>，通过改变 <code>Quarter</code> 变体来包含一个 <code>State</code> 值，示例 6-4 中完成了这些修改：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span> <span class="comment">// 这样可以立刻看到州的名称</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">UsState</span> &#123;</span><br><span class="line">    Alabama,</span><br><span class="line">    Alaska,</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Coin</span> &#123;</span><br><span class="line">    Penny,</span><br><span class="line">    Nickel,</span><br><span class="line">    Dime,</span><br><span class="line">    <span class="title function_ invoke__">Quarter</span>(UsState),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例 6-4：<code>Quarter</code> 变体也存放了一个 <code>UsState</code> 值的 <code>Coin</code> 枚举</p>
<p>想象一下我们的一个朋友尝试收集所有 50 个州的 25 美分硬币。在根据硬币类型分类零钱的同时，也可以报告出每个 25 美分硬币所对应的州名称，这样如果我们的朋友没有的话，他可以将其加入收藏。</p>
<p>在这些代码的匹配表达式中，我们在匹配 <code>Coin::Quarter</code> 变体的分支的模式中增加了一个叫做 <code>state</code> 的变量。当匹配到 <code>Coin::Quarter</code> 时，变量 <code>state</code> 将会绑定 25 美分硬币所对应州的值。接着在那个分支的代码中使用 <code>state</code>，如下：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">value_in_cents</span>(coin: Coin) <span class="punctuation">-&gt;</span> <span class="type">u8</span> &#123;</span><br><span class="line">    <span class="keyword">match</span> coin &#123;</span><br><span class="line">        Coin::Penny =&gt; <span class="number">1</span>,</span><br><span class="line">        Coin::Nickel =&gt; <span class="number">5</span>,</span><br><span class="line">        Coin::Dime =&gt; <span class="number">10</span>,</span><br><span class="line">        Coin::<span class="title function_ invoke__">Quarter</span>(state) =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;State quarter from &#123;state:?&#125;!&quot;</span>);</span><br><span class="line">            <span class="number">25</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果调用 <code>value_in_cents(Coin::Quarter(UsState::Alaska))</code>，<code>coin</code> 将是 <code>Coin::Quarter(UsState::Alaska)</code>。当将值与每个分支相比较时，没有分支会匹配，直到遇到 <code>Coin::Quarter(state)</code>。这时，<code>state</code> 绑定的将会是值 <code>UsState::Alaska</code>。接着就可以在 <code>println!</code> 表达式中使用这个绑定了，像这样就可以获取 <code>Coin</code> 枚举的 <code>Quarter</code> 变体中内部的州的值。</p>
<h3 id="匹配-Option"><a href="#匹配-Option" class="headerlink" title="匹配 Option"></a><a target="_blank" rel="noopener" href="https://kaisery.github.io/trpl-zh-cn/ch06-02-match.html#%E5%8C%B9%E9%85%8D-optiont">匹配 <code>Option</code></a></h3><p>我们在之前的部分中使用 <code>Option&lt;T&gt;</code> 时，是为了从 <code>Some</code> 中取出其内部的 <code>T</code> 值；我们还可以像处理 <code>Coin</code> 枚举那样使用 <code>match</code> 处理 <code>Option&lt;T&gt;</code>！只不过这回比较的不再是硬币，而是 <code>Option&lt;T&gt;</code> 的变体，但 <code>match</code> 表达式的工作方式保持不变。</p>
<p>比如我们想要编写一个函数，它获取一个 <code>Option&lt;i32&gt;</code> ，如果其中含有一个值，将其加一。如果其中没有值，函数应该返回 <code>None</code> 值，而不尝试执行任何操作。</p>
<p>得益于 <code>match</code>，编写这个函数非常简单，它将看起来像示例 6-5 中这样：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">plus_one</span>(x: <span class="type">Option</span>&lt;<span class="type">i32</span>&gt;) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="type">i32</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">match</span> x &#123;</span><br><span class="line">        <span class="literal">None</span> =&gt; <span class="literal">None</span>,</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(i) =&gt; <span class="title function_ invoke__">Some</span>(i + <span class="number">1</span>),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">five</span> = <span class="title function_ invoke__">Some</span>(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">six</span> = <span class="title function_ invoke__">plus_one</span>(five);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">none</span> = <span class="title function_ invoke__">plus_one</span>(<span class="literal">None</span>);</span><br></pre></td></tr></table></figure>

<p>示例 6-5：一个在 <code>Option&lt;i32&gt;</code> 上使用 <code>match</code> 表达式的函数</p>
<p>让我们更仔细地检查 <code>plus_one</code> 的第一行操作。当调用 <code>plus_one(five)</code> 时，<code>plus_one</code> 函数体中的 <code>x</code> 将会是值 <code>Some(5)</code>。接着将其与每个分支比较。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">None</span> =&gt; <span class="literal">None</span>,</span><br></pre></td></tr></table></figure>

<p>值 <code>Some(5)</code> 并不匹配模式 <code>None</code>，所以继续进行下一个分支。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_ invoke__">Some</span>(i) =&gt; <span class="title function_ invoke__">Some</span>(i + <span class="number">1</span>),</span><br></pre></td></tr></table></figure>

<p><code>Some(5)</code> 与 <code>Some(i)</code> 匹配吗？当然匹配！它们是相同的变体。<code>i</code> 绑定了 <code>Some</code> 中包含的值，所以 <code>i</code> 的值是 <code>5</code>。接着匹配分支的代码被执行，所以我们将 <code>i</code> 的值加一并返回一个含有值 <code>6</code> 的新 <code>Some</code>。</p>
<p>接着考虑下示例 6-5 中 <code>plus_one</code> 的第二个调用，这里 <code>x</code> 是 <code>None</code>。我们进入 <code>match</code> 并与第一个分支相比较。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">None</span> =&gt; <span class="literal">None</span>,</span><br></pre></td></tr></table></figure>

<p>匹配成功！这里没有值来加一，所以程序结束并返回 <code>=&gt;</code> 右侧的值 <code>None</code>，因为第一个分支就匹配到了，其他的分支将不再比较。</p>
<p>将 <code>match</code> 与枚举相结合在很多场景中都是有用的。你会在 Rust 代码中看到很多这样的模式：<code>match</code> 一个枚举，绑定其中的值到一个变量，接着根据其值执行代码。这在一开始有点复杂，不过一旦习惯了，你会希望所有语言都拥有它！这一直是用户的最爱。</p>
<h3 id="匹配是穷尽的"><a href="#匹配是穷尽的" class="headerlink" title="匹配是穷尽的"></a><a target="_blank" rel="noopener" href="https://kaisery.github.io/trpl-zh-cn/ch06-02-match.html#%E5%8C%B9%E9%85%8D%E6%98%AF%E7%A9%B7%E5%B0%BD%E7%9A%84">匹配是穷尽的</a></h3><p><code>match</code> 还有另一方面需要讨论：这些分支必须覆盖了所有的可能性。考虑一下 <code>plus_one</code> 函数的这个版本，它有一个 bug 并不能编译：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">plus_one</span>(x: <span class="type">Option</span>&lt;<span class="type">i32</span>&gt;) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="type">i32</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">match</span> x &#123;</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(i) =&gt; <span class="title function_ invoke__">Some</span>(i + <span class="number">1</span>),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们没有处理 <code>None</code> 的情况，所以这些代码会造成一个 bug。幸运的是，这是一个 Rust 知道如何处理的 bug。如果尝试编译这段代码，会得到这个错误：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cargo run</span></span><br><span class="line">   Compiling enums v0.1.0 (file:///projects/enums)</span><br><span class="line">error[E0004]: non-exhaustive patterns: `None` not covered</span><br><span class="line"><span class="meta prompt_"> --&gt; </span><span class="language-bash">src/main.rs:3:15</span></span><br><span class="line">  |</span><br><span class="line">3 |         match x &#123;</span><br><span class="line">  |               ^ pattern `None` not covered</span><br><span class="line">  |</span><br><span class="line">note: `Option&lt;i32&gt;` defined here</span><br><span class="line"><span class="meta prompt_"> --&gt; </span><span class="language-bash">/rustc/4eb161250e340c8f48f66e2b929ef4a5bed7c181/library/core/src/option.rs:572:1</span></span><br><span class="line"> ::: /rustc/4eb161250e340c8f48f66e2b929ef4a5bed7c181/library/core/src/option.rs:576:5</span><br><span class="line">  |</span><br><span class="line">  = note: not covered</span><br><span class="line">  = note: the matched value is of type `Option&lt;i32&gt;`</span><br><span class="line">help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown</span><br><span class="line">  |</span><br><span class="line">4 ~             Some(i) =&gt; Some(i + 1),</span><br><span class="line">5 ~             None =&gt; todo!(),</span><br><span class="line">  |</span><br><span class="line"></span><br><span class="line">For more information about this error, try `rustc --explain E0004`.</span><br><span class="line">error: could not compile `enums` (bin &quot;enums&quot;) due to 1 previous error</span><br></pre></td></tr></table></figure>

<p>Rust 知道我们没有覆盖所有可能的情况甚至知道哪些模式被忘记了！Rust 中的匹配是 <strong>穷尽的</strong>（<em>exhaustive</em>）：必须穷举到最后的可能性来使代码有效。特别的在这个 <code>Option&lt;T&gt;</code> 的例子中，Rust 防止我们忘记明确的处理 <code>None</code> 的情况，这让我们免于假设拥有一个实际上为空的值，从而使之前提到的价值亿万的错误不可能发生。</p>
<h3 id="通配模式和-占位符"><a href="#通配模式和-占位符" class="headerlink" title="通配模式和 _ 占位符"></a><a target="_blank" rel="noopener" href="https://kaisery.github.io/trpl-zh-cn/ch06-02-match.html#%E9%80%9A%E9%85%8D%E6%A8%A1%E5%BC%8F%E5%92%8C-_-%E5%8D%A0%E4%BD%8D%E7%AC%A6">通配模式和 <code>_</code> 占位符</a></h3><p>使用枚举，我们也可以针对少数几个特定值执行特殊操作，而对其他所有值采取默认操作。想象我们正在玩一个游戏，如果你掷出骰子的值为 3，角色不会移动，而是会得到一顶新奇的帽子。如果你掷出了 7，你的角色将失去一顶新奇的帽子。对于其他的数值，你的角色会在棋盘上移动相应的格子。这是一个实现了上述逻辑的 <code>match</code>，骰子的结果是硬编码而不是一个随机值，其他的逻辑部分使用了没有函数体的函数来表示，实现它们超出了本例的范围：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">dice_roll</span> = <span class="number">9</span>;</span><br><span class="line"><span class="keyword">match</span> dice_roll &#123;</span><br><span class="line">    <span class="number">3</span> =&gt; <span class="title function_ invoke__">add_fancy_hat</span>(),</span><br><span class="line">    <span class="number">7</span> =&gt; <span class="title function_ invoke__">remove_fancy_hat</span>(),</span><br><span class="line">    other =&gt; <span class="title function_ invoke__">move_player</span>(other),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">add_fancy_hat</span>() &#123;&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">remove_fancy_hat</span>() &#123;&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">move_player</span>(num_spaces: <span class="type">u8</span>) &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>对于前两个分支，匹配模式是字面值 <code>3</code> 和 <code>7</code>，最后一个分支则涵盖了所有其他可能的值，模式是我们命名为 <code>other</code> 的一个变量。<code>other</code> 分支的代码通过将其传递给 <code>move_player</code> 函数来使用这个变量。</p>
<p>即使我们没有列出 <code>u8</code> 所有可能的值，这段代码依然能够编译，因为最后一个模式将匹配所有未被特殊列出的值。这种通配模式满足了 <code>match</code> 必须被穷尽的要求。请注意，我们必须将通配分支放在最后，因为模式是按顺序匹配的。如果我们在通配分支后添加其他分支，Rust 将会警告我们，因为此后的分支永远不会被匹配到。</p>
<p>Rust 还提供了一个模式，当我们不想使用通配模式获取的值时，请使用 <code>_</code> ，这是一个特殊的模式，可以匹配任意值而不绑定到该值。这告诉 Rust 我们不会使用这个值，所以 Rust 也不会警告我们存在未使用的变量。</p>
<p>让我们改变游戏规则：现在，当你掷出的值不是 3 或 7 的时候，你必须再次掷出。这种情况下我们不需要使用这个值，所以我们改动代码使用 <code>_</code> 来替代变量 <code>other</code> ：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">dice_roll</span> = <span class="number">9</span>;</span><br><span class="line"><span class="keyword">match</span> dice_roll &#123;</span><br><span class="line">    <span class="number">3</span> =&gt; <span class="title function_ invoke__">add_fancy_hat</span>(),</span><br><span class="line">    <span class="number">7</span> =&gt; <span class="title function_ invoke__">remove_fancy_hat</span>(),</span><br><span class="line">    _ =&gt; <span class="title function_ invoke__">reroll</span>(),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">add_fancy_hat</span>() &#123;&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">remove_fancy_hat</span>() &#123;&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">reroll</span>() &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>这个例子也满足穷尽性要求，因为我们在最后一个分支中显式地忽略了其它值。我们没有忘记处理任何东西。</p>
<p>最后，让我们再次改变游戏规则，如果你掷出 3 或 7 以外的值，你的回合将无事发生。我们可以使用单元值（在<a target="_blank" rel="noopener" href="https://kaisery.github.io/trpl-zh-cn/ch03-02-data-types.html#%E5%85%83%E7%BB%84%E7%B1%BB%E5%9E%8B">“元组类型”</a>一节中提到的空元组）作为 <code>_</code> 分支的代码：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">dice_roll</span> = <span class="number">9</span>;</span><br><span class="line"><span class="keyword">match</span> dice_roll &#123;</span><br><span class="line">    <span class="number">3</span> =&gt; <span class="title function_ invoke__">add_fancy_hat</span>(),</span><br><span class="line">    <span class="number">7</span> =&gt; <span class="title function_ invoke__">remove_fancy_hat</span>(),</span><br><span class="line">    _ =&gt; (),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">add_fancy_hat</span>() &#123;&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">remove_fancy_hat</span>() &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>在这里，我们明确告诉 Rust 我们不会使用与前面模式不匹配的值，并且这种情况下我们不想运行任何代码。</p>
<h3 id="（下划线）"><a href="#（下划线）" class="headerlink" title="_（下划线）"></a><code>_</code>（下划线）</h3><p><code>_</code> 在 <code>match</code> 语句中是一个<strong>通配符模式</strong>。它的作用是：</p>
<ul>
<li><strong>匹配任何值，但不会将该值绑定到任何变量</strong>。这意味着你不在乎具体匹配到的值是什么，只要模式匹配成功就执行对应的代码块。</li>
<li><strong>表示剩余情况的穷尽匹配</strong>。它通常作为 <code>match</code> 表达式的最后一个分支，用来捕获所有之前没有明确处理的模式。</li>
</ul>
<p><strong><code>_</code> 的主要特点：</strong></p>
<ul>
<li><strong>不绑定</strong>：匹配到的值不会绑定到任何变量，因此你不能在该分支的代码块中使用它。</li>
<li><strong>不可驳斥</strong>：它总是会匹配成功。</li>
<li><strong>常用于默认或“包罗万象”的情况</strong>。</li>
</ul>
<p><strong>示例：</strong></p>
<p>Rust</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">fn process_number(x: i32) &#123;</span><br><span class="line">    match x &#123;</span><br><span class="line">        1 =&gt; println!(&quot;数字是1！&quot;),</span><br><span class="line">        2 =&gt; println!(&quot;数字是2！&quot;),</span><br><span class="line">        _ =&gt; println!(&quot;其他数字！&quot;), // 匹配任何其他 i32 值</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    process_number(1);</span><br><span class="line">    process_number(5);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>_</code> 处理了所有不是 <code>1</code> 或 <code>2</code> 的 <code>i32</code> 值。</p>
<h3 id="other（或任何其他标识符）"><a href="#other（或任何其他标识符）" class="headerlink" title="other（或任何其他标识符）"></a><code>other</code>（或任何其他标识符）</h3><p>当你使用 <code>other</code>（或 <code>x</code>、<code>value</code>、<code>remainder</code> 等）这样的标识符在 <code>match</code> 语句中时，它充当一个<strong>变量绑定模式</strong>。它的作用是：</p>
<ul>
<li><strong>匹配任何值并将其绑定到一个新的变量</strong>，变量名就是你指定的标识符。这允许你在该分支的代码块中使用匹配到的值。</li>
<li><strong>捕获值</strong>以便进一步处理。</li>
</ul>
<p><strong>标识符（如 <code>other</code>）的主要特点：</strong></p>
<ul>
<li><strong>绑定</strong>：匹配到的值会绑定到指定的变量，然后可以在该分支的代码中使用。</li>
<li><strong>可驳斥（但可以作为包罗万象的情况）</strong>：虽然如果放在最后它也可以作为包罗万象的分支，但它的主要目的是绑定值。</li>
<li><strong>当需要处理匹配到的值时非常有用</strong>。</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Result</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Success</span>(<span class="type">String</span>),</span><br><span class="line">    <span class="title function_ invoke__">Error</span>(<span class="type">u32</span>),</span><br><span class="line">    Loading,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">handle_result</span>(res: <span class="type">Result</span>) &#123;</span><br><span class="line">    <span class="keyword">match</span> res &#123;</span><br><span class="line">        <span class="type">Result</span>::<span class="title function_ invoke__">Success</span>(message) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;成功：&#123;&#125;&quot;</span>, message),</span><br><span class="line">        <span class="type">Result</span>::<span class="title function_ invoke__">Error</span>(code) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;错误码：&#123;&#125;&quot;</span>, code),</span><br><span class="line">        other =&gt; <span class="built_in">println!</span>(<span class="string">&quot;接收到其他状态：&#123;:?&#125;&quot;</span>, other), <span class="comment">// 将剩余的 Result 值绑定到 &#x27;other&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="title function_ invoke__">handle_result</span>(<span class="type">Result</span>::<span class="title function_ invoke__">Success</span>(<span class="string">&quot;操作完成&quot;</span>.<span class="title function_ invoke__">to_string</span>()));</span><br><span class="line">    <span class="title function_ invoke__">handle_result</span>(<span class="type">Result</span>::<span class="title function_ invoke__">Error</span>(<span class="number">404</span>));</span><br><span class="line">    <span class="title function_ invoke__">handle_result</span>(<span class="type">Result</span>::Loading); <span class="comment">// &#x27;Loading&#x27; 将被绑定到 &#x27;other&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，当匹配到 <code>Result::Loading</code> 时，<code>Loading</code> 变体本身被绑定到 <code>other</code> 变量，然后你可以在代码中打印或使用 <code>other</code>。</p>
<hr>
<h3 id="区别总结-📊"><a href="#区别总结-📊" class="headerlink" title="区别总结 📊"></a>区别总结 📊</h3><table>
<thead>
<tr>
<th>特征</th>
<th><code>_</code>（通配符）</th>
<th><code>other</code>（变量绑定）</th>
</tr>
</thead>
<tbody><tr>
<td><strong>目的</strong></td>
<td>忽略值；作为“包罗万象”的模式</td>
<td>将值绑定到变量以供使用</td>
</tr>
<tr>
<td><strong>值的使用</strong></td>
<td>不能在该分支中使用匹配到的值</td>
<td>可以使用匹配到的值（通过变量）在该分支中</td>
</tr>
<tr>
<td><strong>绑定</strong></td>
<td>不发生绑定</td>
<td>将匹配到的值绑定到标识符</td>
</tr>
<tr>
<td><strong>常见用例</strong></td>
<td>默认情况，忽略模式的特定部分</td>
<td>捕获和处理匹配到的值</td>
</tr>
</tbody></table>
<h2 id="什么是“愉快路径”（Happy-Path）？"><a href="#什么是“愉快路径”（Happy-Path）？" class="headerlink" title="什么是“愉快路径”（Happy Path）？"></a>什么是“愉快路径”（Happy Path）？</h2><p>首先，理解“愉快路径”的概念很重要。在编程中，“愉快路径”指的是程序在<strong>没有遇到错误、异常或意外情况</strong>时，按照预期顺利执行的流程。就像你在一条平坦的路上开车，没有堵车，没有故障，一路畅通。</p>
<p>相反，如果出现错误或不匹配的情况，我们就需要处理**“不愉快路径”**，比如报错、返回空值、退出程序等。</p>
<hr>
<h2 id="let-else-的核心思想"><a href="#let-else-的核心思想" class="headerlink" title="let...else 的核心思想"></a><code>let...else</code> 的核心思想</h2><p><code>let...else</code> 的核心目的是为了让你的代码在处理可能失败的操作时，能够<strong>清晰地把“愉快路径”的代码放在主线上，而把“不愉快路径”的退出逻辑快速处理掉</strong>。它就像一个“快速出口”，当条件不满足时，直接从函数中跳出，避免让主逻辑变得复杂。</p>
<h3 id="为什么需要-let-else？（C-语言类比：繁琐的错误检查）"><a href="#为什么需要-let-else？（C-语言类比：繁琐的错误检查）" class="headerlink" title="为什么需要 let...else？（C 语言类比：繁琐的错误检查）"></a>为什么需要 <code>let...else</code>？（C 语言类比：繁琐的错误检查）</h3><p>在 C 语言中，当你调用一个可能失败的函数，或者需要检查一个指针是否为 <code>NULL</code> 时，你通常会看到这样的模式：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C 语言示例：模拟一个可能失败的函数调用</span></span><br><span class="line"><span class="type">int</span>* <span class="title function_">get_data</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 假设这个函数可能返回 NULL 表示失败</span></span><br><span class="line">    <span class="keyword">if</span> (rand() % <span class="number">2</span> == <span class="number">0</span>) &#123; <span class="comment">// 模拟随机失败</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span>* data = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    *data = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">process_data</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span>* data = get_data(); <span class="comment">// 调用可能失败的函数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 经典 C 语言的错误检查模式：if (data == NULL) &#123; return; &#125;</span></span><br><span class="line">    <span class="keyword">if</span> (data == <span class="literal">NULL</span>) &#123; <span class="comment">// 检查“不愉快路径”</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;获取数据失败，提前返回。\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">// 从函数中提前返回</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 走到这里，data 肯定不是 NULL，这是“愉快路径”</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;成功获取数据: %d\n&quot;</span>, *data);</span><br><span class="line">    <span class="built_in">free</span>(data); <span class="comment">// 释放资源</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    srand(time(<span class="literal">NULL</span>)); <span class="comment">// 初始化随机数种子</span></span><br><span class="line">    process_data();</span><br><span class="line">    process_data();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的 C 语言代码中，<code>if (data == NULL)</code> 就是处理“不愉快路径”的代码。它打断了主逻辑（处理数据）的流畅性，因为你必须先进行检查，如果失败就 <code>return</code>。</p>
<p>如果有很多这样的检查，或者你需要从多个函数中获取数据并检查，你的代码可能会变成这样：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C 语言中嵌套的错误检查可能很丑陋</span></span><br><span class="line">TypeA* objA = get_obj_a();</span><br><span class="line"><span class="keyword">if</span> (objA == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> ERROR_A;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TypeB* objB = get_obj_b(objA);</span><br><span class="line"><span class="keyword">if</span> (objB == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> ERROR_B;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TypeC* objC = get_obj_c(objB);</span><br><span class="line"><span class="keyword">if</span> (objC == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> ERROR_C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只有当所有都成功时，才能执行核心逻辑</span></span><br><span class="line">process_final_data(objA, objB, objC);</span><br></pre></td></tr></table></figure>

<p>这就是 <code>if let</code> 有时显得“繁琐”或“不对称”的原因。它虽然能绑定值，但在处理不匹配时，如果你想提前返回，就需要在 <code>else</code> 块中明确写 <code>return</code>，让控制流看起来有点跳跃：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对应上面 C 语言的 if (data == NULL) &#123; return; &#125;</span></span><br><span class="line"><span class="comment">// Rust 的 if let 模拟：</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">describe_state_quarter_if_let</span>(coin: Coin) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="type">String</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">state</span> = <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Coin</span>::<span class="title function_ invoke__">Quarter</span>(s) = coin &#123;</span><br><span class="line">        s <span class="comment">// 匹配成功，绑定 state</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span>; <span class="comment">// 匹配失败，直接返回 None</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 只有匹配成功，才会执行到这里</span></span><br><span class="line">    <span class="comment">// 接下来是处理 state 的“愉快路径”代码</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="title function_ invoke__">Some</span>(<span class="built_in">format!</span>(<span class="string">&quot;&#123;state:?&#125;&quot;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段 <code>if let</code> 的代码虽然可以实现功能，但你会感觉 <code>let state = if let ... else &#123; return None; &#125;;</code> 这一行有点别扭。成功的逻辑是赋值，失败的逻辑是返回，两种控制流类型不一样。</p>
<h3 id="let-else-如何简化？（C-语言类比：更直接的错误处理）"><a href="#let-else-如何简化？（C-语言类比：更直接的错误处理）" class="headerlink" title="let...else 如何简化？（C 语言类比：更直接的错误处理）"></a><code>let...else</code> 如何简化？（C 语言类比：更直接的错误处理）</h3><p><code>let...else</code> 的出现就是为了让这种“如果模式匹配就绑定值，否则直接退出”的场景变得更简洁、更符合“愉快路径”的直觉。它强制 <code>else</code> 块必须包含一个<strong>非局部退出</strong>（Non-local Return），也就是跳出当前函数、循环或者直接使程序中断。</p>
<p>我们可以将 <code>let...else</code> 类比为 C 语言中结合了<strong>宏</strong>或<strong>特定的错误处理约定</strong>来简化这种“检查-退出”模式：</p>
<p>想象一下，在 C 语言中，你可能会定义一个宏来做这样的事情（虽然不完全一样，但思想相似）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 伪 C 语言宏类比 let...else</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CHECK_AND_GET_DATA(ptr_var, func_call) \</span></span><br><span class="line"><span class="meta">    ptr_var = func_call;                     \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> (ptr_var == NULL) &#123;                   \</span></span><br><span class="line"><span class="meta">        printf(<span class="string">&quot;错误，提前退出！\n&quot;</span>);         \</span></span><br><span class="line"><span class="meta">        return;                              \</span></span><br><span class="line"><span class="meta">    &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">process_data_simplified</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span>* data;</span><br><span class="line">    CHECK_AND_GET_DATA(data, get_data()); <span class="comment">// 使用宏，如果 get_data 失败就直接返回</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 走到这里，data 肯定有效，直接处理“愉快路径”</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;成功获取数据（简化版）: %d\n&quot;</span>, *data);</span><br><span class="line">    <span class="built_in">free</span>(data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Rust 的 <code>let...else</code> 就是把这种模式内置到了语言层面，让它安全且优雅。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">describe_state_quarter_let_else</span>(coin: Coin) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="type">String</span>&gt; &#123;</span><br><span class="line">    <span class="comment">// let Coin::Quarter(state) = coin else &#123; ... &#125;;</span></span><br><span class="line">    <span class="comment">// 尝试将 coin 匹配为 Coin::Quarter。</span></span><br><span class="line">    <span class="comment">// 如果匹配成功，那么 state 变量就会被绑定，程序会继续往下执行（“愉快路径”）。</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">Coin</span>::<span class="title function_ invoke__">Quarter</span>(state) = coin <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span>; <span class="comment">// 如果不匹配（比如 coin 是 Coin::Dime 或 Coin::Nickel），直接从函数返回 None。</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 只有当 coin 确实是 Coin::Quarter 时，代码才会执行到这里。</span></span><br><span class="line">    <span class="comment">// 此时 state 变量已经包含了 Quarter 中的 UsState 值。</span></span><br><span class="line">    <span class="comment">// 这就是我们的“愉快路径”：直接使用 state 进行后续操作。</span></span><br><span class="line">    <span class="keyword">if</span> state.<span class="title function_ invoke__">existed_in</span>(<span class="number">1900</span>) &#123;</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(<span class="built_in">format!</span>(<span class="string">&quot;&#123;state:?&#125; is pretty old, for America!&quot;</span>))</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(<span class="built_in">format!</span>(<span class="string">&quot;&#123;state:?&#125; is relatively new.&quot;</span>))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><code>let...else</code> 的优点：</strong></p>
<ol>
<li><strong>保持“愉快路径”的简洁性</strong>：它允许你的主要逻辑（即成功时执行的代码）保持在左对齐的、不被中断的块中。那些会导致函数退出的“不愉快路径”逻辑被清晰地隔离在 <code>else</code> 块里，而且这个块必须执行一个非局部返回，避免了遗漏。</li>
<li><strong>更清晰的控制流</strong>：一眼就能看出如果模式不匹配，函数会立即退出，避免了 <code>if let</code> 某些情况下可能出现的控制流跳跃或分支逻辑不一致的问题。这使得代码更易读、易懂。</li>
</ol>
<p>简而言之，<code>let...else</code> 是 Rust 语言为处理“如果能成功解构就继续，否则立即退出”这种常见模式提供的一个语法糖，让代码在面对潜在失败时，依然能保持“愉快路径”的简洁和直观。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/07/20/RUST%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0%E4%B9%8B%E7%BB%93%E6%9E%84%E4%BD%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.png">
      <meta itemprop="name" content="Chillward">
      <meta itemprop="description" content="谁躺在漆黑的舞台上，用身体迎接着光芒">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chillward的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/07/20/RUST%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0%E4%B9%8B%E7%BB%93%E6%9E%84%E4%BD%93/" class="post-title-link" itemprop="url">RUST学习日记之结构体</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-07-20 11:41:40 / 修改时间：15:56:53" itemprop="dateCreated datePublished" datetime="2025-07-20T11:41:40+08:00">2025-07-20</time>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>7.4k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>13 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="结构体的定义和示例化"><a href="#结构体的定义和示例化" class="headerlink" title="结构体的定义和示例化"></a>结构体的定义和示例化</h2><h3 id="结构体的定义以及实例化"><a href="#结构体的定义以及实例化" class="headerlink" title="结构体的定义以及实例化"></a>结构体的定义以及实例化</h3><p>定义语法:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    active: <span class="type">bool</span>,</span><br><span class="line">    username: <span class="type">String</span>,</span><br><span class="line">    email: <span class="type">String</span>,</span><br><span class="line">    sign_in_count: <span class="type">u64</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>没有**;**，需要指明类型。</p>
<p>实例化语法:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">user1</span> = User &#123;</span><br><span class="line">    active: <span class="literal">true</span>,</span><br><span class="line">    username: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;someusername123&quot;</span>),</span><br><span class="line">    email: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;someone@example.com&quot;</span>),</span><br><span class="line">    sign_in_count: <span class="number">1</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>如果整个实例是可变的，那我们就可以通过<code>user1.email = String::from(&quot;anotheremail@example.com&quot;);</code>来修改实例中字段的值。</p>
<p>通过函数返回实例:</p>
<blockquote>
<p>另外需要注意同其他任何表达式一样，我们可以在函数体的最后一个表达式中构造一个结构体的新实例，来隐式地返回这个实例。</p>
</blockquote>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">build_user</span>(email: <span class="type">String</span>, username: <span class="type">String</span>) <span class="punctuation">-&gt;</span> User &#123;</span><br><span class="line">    User &#123;</span><br><span class="line">        active: <span class="literal">true</span>,</span><br><span class="line">        username: username,</span><br><span class="line">        email: email,</span><br><span class="line">        sign_in_count: <span class="number">1</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="字段初始化"><a href="#字段初始化" class="headerlink" title="字段初始化"></a>字段初始化</h3><p>我们可以通过<strong>字段初始化</strong>来简写语法,如下:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">build_user</span>(email: <span class="type">String</span>, username: <span class="type">String</span>) <span class="punctuation">-&gt;</span> User &#123;</span><br><span class="line">    User &#123;</span><br><span class="line">        active: <span class="literal">true</span>,</span><br><span class="line">        username,</span><br><span class="line">        email,</span><br><span class="line">        sign_in_count: <span class="number">1</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当参数与结构体中字段的名字相同时可以使用字段初始化来简写语法。</p>
<h3 id="结构体更新语法"><a href="#结构体更新语法" class="headerlink" title="结构体更新语法"></a>结构体更新语法</h3><p>结构体更新语法:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">user2</span> = User &#123;</span><br><span class="line">        email: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;another@example.com&quot;</span>),</span><br><span class="line">        ..user1</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请注意，结构更新语法就像带有 <code>=</code> 的赋值，因为它移动了数据，就像我们在“使用移动的变量与数据交互”部分讲到的一样。在这个例子中，总体上说我们在创建 <code>user2</code> 后就不能再使用 <code>user1</code> 了，因为 <code>user1</code> 的 <code>username</code> 字段中的 <code>String</code> 被移到 <code>user2</code> 中。如果我们给 <code>user2</code> 的 <code>email</code> 和 <code>username</code> 都赋予新的 <code>String</code> 值，从而只复用 <code>user1</code> 的 <code>active</code> 和 <code>sign_in_count</code> 值，那么 <code>user1</code> 在创建 <code>user2</code> 后仍然有效。<code>active</code> 和 <code>sign_in_count</code> 的类型是实现 <code>Copy</code> trait 的类型，所以我们在[“使用克隆的变量与数据交互”]部分讨论的行为同样适用。在本例中我们也可以继续使用 <code>user1.email</code>，因为它的值并未从 <code>user1</code> 中移动出去。</p>
<p><strong>如果想不影响原来实例的话，可以使用.clone()方法来复制数据。</strong></p>
<h3 id="使用没有命名字段的元组结构体来创建不同的类型"><a href="#使用没有命名字段的元组结构体来创建不同的类型" class="headerlink" title="使用没有命名字段的元组结构体来创建不同的类型"></a>使用没有命名字段的元组结构体来创建不同的类型</h3><p>也可以定义与元组类似的结构体，称为 <strong>元组结构体</strong>（<em>tuple structs</em>）。元组结构体有着结构体名称提供的含义，但没有具体的字段名，只有字段的类型。当你想给整个元组取一个名字，并使元组成为与其他元组不同的类型时，元组结构体是很有用的，这时像常规结构体那样为每个字段命名就显得多余和形式化了。</p>
<p>要定义元组结构体，以 <code>struct</code> 关键字和结构体名开头并后跟元组中的类型。例如，下面是两个分别叫做 <code>Color</code> 和 <code>Point</code> 元组结构体的定义和用法：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Color</span>(<span class="type">i32</span>, <span class="type">i32</span>, <span class="type">i32</span>);</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span>(<span class="type">i32</span>, <span class="type">i32</span>, <span class="type">i32</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">black</span> = <span class="title function_ invoke__">Color</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">origin</span> = <span class="title function_ invoke__">Point</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意 <code>black</code> 和 <code>origin</code> 值的类型不同，因为它们是不同的元组结构体的实例。你定义的每一个结构体有其自己的类型，即使结构体中的字段可能有着相同的类型。例如，一个获取 <code>Color</code> 类型参数的函数不能接受 <code>Point</code> 作为参数，即便这两个类型都由三个 <code>i32</code> 值组成。除此之外，元组结构体实例类似于元组，你可以将它们解构为单独的部分，也可以使用 <code>.</code> 后跟索引来访问单独的值。与元组不同的是，解构元组结构体时必须写明结构体的类型。例如，我们可以写 <code>let Point(x, y, z) = origin;</code>，将 <code>origin</code> 的值解构到名为 <code>x</code>、<code>y</code> 和 <code>z</code> 的变量中。</p>
<h3 id="类单元结构体"><a href="#类单元结构体" class="headerlink" title="类单元结构体"></a>类单元结构体</h3><p>暂时用不到，就先不写了</p>
<h3 id="结构体中字段的所有权"><a href="#结构体中字段的所有权" class="headerlink" title="结构体中字段的所有权"></a>结构体中字段的所有权</h3><p>目前就是注意一点，结构体字段中不要包含引用就好了。</p>
<hr>
<h3 id="打印结构体中所有值"><a href="#打印结构体中所有值" class="headerlink" title="打印结构体中所有值"></a>打印结构体中所有值</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    width: <span class="type">u32</span>,</span><br><span class="line">    height: <span class="type">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rect1</span> = Rectangle &#123;</span><br><span class="line">        width: <span class="number">30</span>,</span><br><span class="line">        height: <span class="number">50</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;rect1 is &#123;rect1:#?&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="结构体中的方法"><a href="#结构体中的方法" class="headerlink" title="结构体中的方法"></a>结构体中的方法</h2><blockquote>
<p>RUST官方教程中这一块写的非常清晰易懂，我直接复制下来了</p>
</blockquote>
<h2 id="方法语法"><a href="#方法语法" class="headerlink" title="方法语法"></a><a target="_blank" rel="noopener" href="https://kaisery.github.io/trpl-zh-cn/ch05-03-method-syntax.html#%E6%96%B9%E6%B3%95%E8%AF%AD%E6%B3%95">方法语法</a></h2><p><strong>方法</strong>（method）与函数类似：它们使用 <code>fn</code> 关键字和名称声明，可以拥有参数和返回值，同时包含在某处调用该方法时会执行的代码。不过方法与函数是不同的，因为它们在结构体的上下文中被定义（或者是枚举或 trait 对象的上下文，将分别在<a target="_blank" rel="noopener" href="https://kaisery.github.io/trpl-zh-cn/ch06-00-enums.html">第六章</a>和<a target="_blank" rel="noopener" href="https://kaisery.github.io/trpl-zh-cn/ch18-02-trait-objects.html">第十八章</a>讲解），并且它们第一个参数总是 <code>self</code>，它代表调用该方法的结构体实例。</p>
<h3 id="定义方法"><a href="#定义方法" class="headerlink" title="定义方法"></a><a target="_blank" rel="noopener" href="https://kaisery.github.io/trpl-zh-cn/ch05-03-method-syntax.html#%E5%AE%9A%E4%B9%89%E6%96%B9%E6%B3%95">定义方法</a></h3><p>让我们把前面实现的获取一个 <code>Rectangle</code> 实例作为参数的 <code>area</code> 函数，改写成一个定义于 <code>Rectangle</code> 结构体上的 <code>area</code> 方法，如示例 5-13 所示：</p>
<p>文件名：src&#x2F;main.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    width: <span class="type">u32</span>,</span><br><span class="line">    height: <span class="type">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">area</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">u32</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.width * <span class="keyword">self</span>.height</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rect1</span> = Rectangle &#123;</span><br><span class="line">        width: <span class="number">30</span>,</span><br><span class="line">        height: <span class="number">50</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(</span><br><span class="line">        <span class="string">&quot;The area of the rectangle is &#123;&#125; square pixels.&quot;</span>,</span><br><span class="line">        rect1.<span class="title function_ invoke__">area</span>()</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例 5-13：在 <code>Rectangle</code> 结构体上定义 <code>area</code> 方法</p>
<p>为了使函数定义于 <code>Rectangle</code> 的上下文中，我们开始了一个 <code>impl</code> 块（<code>impl</code> 是 <em>implementation</em> 的缩写），这个 <code>impl</code> 块中的所有内容都将与 <code>Rectangle</code> 类型相关联。接着将 <code>area</code> 函数移动到 <code>impl</code> 大括号中，并将签名中的第一个（在这里也是唯一一个）参数和函数体中其他地方的对应参数改成 <code>self</code>。然后在 <code>main</code> 中将我们先前调用 <code>area</code> 方法并传递 <code>rect1</code> 作为参数的地方，改成使用 <strong>方法语法</strong>（<em>method syntax</em>）在 <code>Rectangle</code> 实例上调用 <code>area</code> 方法。方法语法获取一个实例并加上一个点号，后跟方法名、圆括号以及任何参数。</p>
<p>在 <code>area</code> 的签名中，使用 <code>&amp;self</code> 来替代 <code>rectangle: &amp;Rectangle</code>，<code>&amp;self</code> 实际上是 <code>self: &amp;Self</code> 的缩写。在一个 <code>impl</code> 块中，<code>Self</code> 类型是 <code>impl</code> 块的类型的别名。方法的第一个参数必须有一个名为 <code>self</code> 的<code>Self</code> 类型的参数，所以 Rust 让你在第一个参数位置上只用 <code>self</code> 这个名字来简化。注意，我们仍然需要在 <code>self</code> 前面使用 <code>&amp;</code> 来表示这个方法借用了 <code>Self</code> 实例，就像我们在 <code>rectangle: &amp;Rectangle</code> 中做的那样。方法可以选择获得 <code>self</code> 的所有权，或者像我们这里一样不可变地借用 <code>self</code>，或者可变地借用 <code>self</code>，就跟其他参数一样。</p>
<p>这里选择 <code>&amp;self</code> 的理由跟在函数版本中使用 <code>&amp;Rectangle</code> 是相同的：我们并不想获取所有权，只希望能够读取结构体中的数据，而不是写入。如果想要在方法中改变调用方法的实例，需要将第一个参数改为 <code>&amp;mut self</code>。通过仅仅使用 <code>self</code> 作为第一个参数来使方法获取实例的所有权是很少见的；这种技术通常用在当方法将 <code>self</code> 转换成别的实例的时候，这时我们想要防止调用者在转换之后使用原始的实例。</p>
<p>使用方法替代函数，除了可使用方法语法和不需要在每个函数签名中重复 <code>self</code> 的类型之外，其主要好处在于组织性。我们将某个类型实例能做的所有事情都一起放入 <code>impl</code> 块中，而不是让将来的用户在我们的库中到处寻找 <code>Rectangle</code> 的功能。</p>
<p>请注意，我们可以选择将方法的名称与结构中的一个字段相同。例如，我们可以在 <code>Rectangle</code> 上定义一个方法，并命名为 <code>width</code>：</p>
<p>文件名：src&#x2F;main.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">width</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.width &gt; <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rect1</span> = Rectangle &#123;</span><br><span class="line">        width: <span class="number">30</span>,</span><br><span class="line">        height: <span class="number">50</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> rect1.<span class="title function_ invoke__">width</span>() &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;The rectangle has a nonzero width; it is &#123;&#125;&quot;</span>, rect1.width);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里，我们选择让 <code>width</code> 方法在实例的 <code>width</code> 字段的值大于 <code>0</code> 时返回 <code>true</code>，等于 <code>0</code> 时则返回 <code>false</code>：我们可以出于任何目的，在同名的方法中使用同名的字段。在 <code>main</code> 中，当我们在 <code>rect1.width</code> 后面加上括号时。Rust 知道我们指的是方法 <code>width</code>。当我们不使用圆括号时，Rust 知道我们指的是字段 <code>width</code>。</p>
<p>通常，但并不总是如此，与字段同名的方法将被定义为只返回字段中的值，而不做其他事情。这样的方法被称为 <em>getters</em>，Rust 并不像其他一些语言那样为结构字段自动实现它们。Getters 很有用，因为你可以把字段变成私有的，但方法是公共的，这样就可以把对字段的只读访问作为该类型公共 API 的一部分。我们将在<a target="_blank" rel="noopener" href="https://kaisery.github.io/trpl-zh-cn/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html#%E4%BD%BF%E7%94%A8-pub-%E5%85%B3%E9%94%AE%E5%AD%97%E6%9A%B4%E9%9C%B2%E8%B7%AF%E5%BE%84">第七章</a>中讨论什么是公有和私有，以及如何将一个字段或方法指定为公有或私有。</p>
<blockquote>
<h3 id="运算符到哪去了？"><a href="#运算符到哪去了？" class="headerlink" title="-&gt; 运算符到哪去了？"></a><a target="_blank" rel="noopener" href="https://kaisery.github.io/trpl-zh-cn/ch05-03-method-syntax.html#--%E8%BF%90%E7%AE%97%E7%AC%A6%E5%88%B0%E5%93%AA%E5%8E%BB%E4%BA%86"><code>-&gt;</code> 运算符到哪去了？</a></h3><p>在 C&#x2F;C++ 语言中，有两个不同的运算符来调用方法：<code>.</code> 直接在对象上调用方法，而 <code>-&gt;</code> 在一个对象的指针上调用方法，这时需要先解引用（dereference）指针。换句话说，如果 <code>object</code> 是一个指针，那么 <code>object-&gt;something()</code> 就像 <code>(*object).something()</code> 一样。</p>
<p>Rust 并没有一个与 <code>-&gt;</code> 等效的运算符；相反，Rust 有一个叫 <strong>自动引用和解引用</strong>（<em>automatic referencing and dereferencing</em>）的功能。方法调用是 Rust 中少数几个拥有这种行为的地方。</p>
<p>它是这样工作的：当使用 <code>object.something()</code> 调用方法时，Rust 会自动为 <code>object</code> 添加 <code>&amp;</code>、<code>&amp;mut</code> 或 <code>*</code> 以便使 <code>object</code> 与方法签名匹配。也就是说，这些代码是等价的：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p1.<span class="title function_ invoke__">distance</span>(&amp;p2);</span><br><span class="line">(&amp;p1).<span class="title function_ invoke__">distance</span>(&amp;p2);</span><br></pre></td></tr></table></figure>

<p>第一行看起来简洁的多。这种自动引用的行为之所以有效，是因为方法有一个明确的接收者———— <code>self</code> 的类型。在给出接收者和方法名的前提下，Rust 可以明确地计算出方法是仅仅读取（<code>&amp;self</code>），做出修改（<code>&amp;mut self</code>）或者是获取所有权（<code>self</code>）。事实上，Rust 对方法接收者的隐式借用让所有权在实践中更友好。</p>
</blockquote>
<h3 id="带有更多参数的方法"><a href="#带有更多参数的方法" class="headerlink" title="带有更多参数的方法"></a><a target="_blank" rel="noopener" href="https://kaisery.github.io/trpl-zh-cn/ch05-03-method-syntax.html#%E5%B8%A6%E6%9C%89%E6%9B%B4%E5%A4%9A%E5%8F%82%E6%95%B0%E7%9A%84%E6%96%B9%E6%B3%95">带有更多参数的方法</a></h3><p>让我们通过实现 <code>Rectangle</code> 结构体上的另一方法来练习使用方法。这回，我们让一个 <code>Rectangle</code> 的实例获取另一个 <code>Rectangle</code> 实例，如果 <code>self</code> （第一个 <code>Rectangle</code>）能完全包含第二个长方形则返回 <code>true</code>；否则返回 <code>false</code>。一旦我们定义了 <code>can_hold</code> 方法，就可以编写示例 5-14 中的代码。</p>
<p>文件名：src&#x2F;main.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rect1</span> = Rectangle &#123;</span><br><span class="line">        width: <span class="number">30</span>,</span><br><span class="line">        height: <span class="number">50</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rect2</span> = Rectangle &#123;</span><br><span class="line">        width: <span class="number">10</span>,</span><br><span class="line">        height: <span class="number">40</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rect3</span> = Rectangle &#123;</span><br><span class="line">        width: <span class="number">60</span>,</span><br><span class="line">        height: <span class="number">45</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Can rect1 hold rect2? &#123;&#125;&quot;</span>, rect1.<span class="title function_ invoke__">can_hold</span>(&amp;rect2));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Can rect1 hold rect3? &#123;&#125;&quot;</span>, rect1.<span class="title function_ invoke__">can_hold</span>(&amp;rect3));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同时我们希望看到如下输出，因为 <code>rect2</code> 的两个维度都小于 <code>rect1</code>，而 <code>rect3</code> 比 <code>rect1</code> 要宽：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Can rect1 hold rect2? true</span><br><span class="line">Can rect1 hold rect3? false</span><br></pre></td></tr></table></figure>

<p>因为我们想定义一个方法，所以它应该位于 <code>impl Rectangle</code> 块中。方法名是 <code>can_hold</code>，并且它会获取另一个 <code>Rectangle</code> 的不可变借用作为参数。通过观察调用方法的代码可以看出参数是什么类型的：<code>rect1.can_hold(&amp;rect2)</code> 传入了 <code>&amp;rect2</code>，它是一个 <code>Rectangle</code> 的实例 <code>rect2</code> 的不可变借用。这是可以理解的，因为我们只需要读取 <code>rect2</code>（而不是写入，这意味着我们需要一个不可变借用），而且希望 <code>main</code> 保持 <code>rect2</code> 的所有权，这样就可以在调用这个方法后继续使用它。<code>can_hold</code> 的返回值是一个布尔值，其实现会分别检查 <code>self</code> 的宽高是否都大于另一个 <code>Rectangle</code>。让我们在示例 5-13 的 <code>impl</code> 块中增加这个新的 <code>can_hold</code> 方法，如示例 5-15 所示：</p>
<p>文件名：src&#x2F;main.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">area</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">u32</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.width * <span class="keyword">self</span>.height</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">can_hold</span>(&amp;<span class="keyword">self</span>, other: &amp;Rectangle) <span class="punctuation">-&gt;</span> <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.width &gt; other.width &amp;&amp; <span class="keyword">self</span>.height &gt; other.height</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例 5-15：在 <code>Rectangle</code> 上实现 <code>can_hold</code> 方法，它获取另一个 <code>Rectangle</code> 实例作为参数</p>
<p>如果结合示例 5-14 的 <code>main</code> 函数来运行，就会看到期望的输出。在方法签名中，可以在 <code>self</code> 后增加多个参数，而且这些参数就像函数中的参数一样工作。</p>
<h3 id="关联函数"><a href="#关联函数" class="headerlink" title="关联函数"></a><a target="_blank" rel="noopener" href="https://kaisery.github.io/trpl-zh-cn/ch05-03-method-syntax.html#%E5%85%B3%E8%81%94%E5%87%BD%E6%95%B0">关联函数</a></h3><p>所有在 <code>impl</code> 块中定义的函数被称为 <strong>关联函数</strong>（<em>associated functions</em>），因为它们与 <code>impl</code> 后面命名的类型相关。我们可以定义不以 <code>self</code> 为第一参数的关联函数（因此不是方法），因为它们并不作用于一个结构体的实例。我们已经使用了一个这样的函数：在 <code>String</code> 类型上定义的 <code>String::from</code> 函数。</p>
<p>不是方法的关联函数经常被用作返回一个结构体新实例的构造函数。这些函数的名称通常为 <code>new</code> ，但 <code>new</code> 并不是一个关键字。例如我们可以提供一个叫做 <code>square</code> 关联函数，它接受一个维度参数并且同时作为宽和高，这样可以更轻松的创建一个正方形 <code>Rectangle</code> 而不必指定两次同样的值：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">square</span>(size: <span class="type">u32</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">Self</span> &#123;</span><br><span class="line">            width: size,</span><br><span class="line">            height: size,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关键字 <code>Self</code> 在函数的返回类型和函数体中，都是对 <code>impl</code> 关键字后所示类型的别名，这里是 <code>Rectangle</code>。</p>
<p>要调用这个关联函数，我们使用结构体名和 <code>::</code> 语法；比如 <code>let sq = Rectangle::square(3);</code>。这个函数位于结构体的命名空间中：<code>::</code> 语法用于关联函数和模块创建的命名空间。<a target="_blank" rel="noopener" href="https://kaisery.github.io/trpl-zh-cn/ch07-02-defining-modules-to-control-scope-and-privacy.html">第七章</a>会讲到模块。</p>
<h3 id="多个-impl-块"><a href="#多个-impl-块" class="headerlink" title="多个 impl 块"></a><a target="_blank" rel="noopener" href="https://kaisery.github.io/trpl-zh-cn/ch05-03-method-syntax.html#%E5%A4%9A%E4%B8%AA-impl-%E5%9D%97">多个 <code>impl</code> 块</a></h3><p>每个结构体都允许拥有多个 <code>impl</code> 块。例如，示例 5-15 中的代码等同于示例 5-16 中所示的代码，但后者每个方法有其自己的 <code>impl</code> 块。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">area</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">u32</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.width * <span class="keyword">self</span>.height</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">can_hold</span>(&amp;<span class="keyword">self</span>, other: &amp;Rectangle) <span class="punctuation">-&gt;</span> <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.width &gt; other.width &amp;&amp; <span class="keyword">self</span>.height &gt; other.height</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里没有理由将这些方法分散在多个 <code>impl</code> 块中，不过这是有效的语法。第十章讨论泛型和 trait 时会看到实用的多 <code>impl</code> 块的用例。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><a target="_blank" rel="noopener" href="https://kaisery.github.io/trpl-zh-cn/ch05-03-method-syntax.html#%E6%80%BB%E7%BB%93">总结</a></h2><p>结构体让你可以创建出在你的领域中有意义的自定义类型。通过结构体，我们可以将相关联的数据片段联系起来并命名它们，这样可以使得代码更加清晰。在 <code>impl</code> 块中，你可以定义与你的类型相关联的函数，而方法是一种相关联的函数，让你指定结构体的实例所具有的行为。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/07/20/RUST%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0%E4%B9%8B%E6%8E%A7%E5%88%B6%E6%B5%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.png">
      <meta itemprop="name" content="Chillward">
      <meta itemprop="description" content="谁躺在漆黑的舞台上，用身体迎接着光芒">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chillward的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/07/20/RUST%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0%E4%B9%8B%E6%8E%A7%E5%88%B6%E6%B5%81/" class="post-title-link" itemprop="url">RUST学习日记之控制流</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-07-20 09:21:17 / 修改时间：15:56:46" itemprop="dateCreated datePublished" datetime="2025-07-20T09:21:17+08:00">2025-07-20</time>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>4k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>7 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="if表达式"><a href="#if表达式" class="headerlink" title="if表达式"></a>if表达式</h3><p>rust中的if语句跟C语言中的是类似的，基本格式如下</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">number</span> = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">if</span> (number &lt; <span class="number">5</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;condition was true&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;condition was false&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但也有不同的地方：</p>
<ol>
<li>if后紧跟的条件必须是一个bool值，如果不是的话，程序会无法编译</li>
<li>在rust中，if是一个表达式而不是语句，二者之间的区别就是语句仅仅只是执行一个动作而不返回值，表达式会在执行后返回一个值。</li>
</ol>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = <span class="keyword">if</span> x &gt; <span class="number">5</span> &#123;</span><br><span class="line">        <span class="number">20</span> <span class="comment">// 这个块的值是 20</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="number">30</span> <span class="comment">// 这个块的值是 30</span></span><br><span class="line">    &#125;; <span class="comment">// 注意这里的分号，表示表达式的结束</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;y = &#123;&#125;&quot;</span>, y); <span class="comment">// 输出 y = 20</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 另一个例子：隐式返回</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">description</span> = <span class="keyword">if</span> x &gt; <span class="number">100</span> &#123;</span><br><span class="line">        <span class="string">&quot;非常大&quot;</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> x &gt; <span class="number">50</span> &#123;</span><br><span class="line">        <span class="string">&quot;比较大&quot;</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="string">&quot;不大&quot;</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;x 的值: &#123;&#125;&quot;</span>, description); <span class="comment">// 输出 x 的值: 不大</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>关键点：</strong></p>
<ol>
<li><p><strong>返回类型一致性</strong>：当 <code>if</code> 作为表达式使用时，所有分支（<code>if</code>、<code>else if</code> 和 <code>else</code>）必须返回<strong>相同类型</strong>的值。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">result</span> = <span class="keyword">if</span> <span class="literal">true</span> &#123;</span><br><span class="line">    <span class="number">10</span> <span class="comment">// 返回 i32</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="string">&quot;hello&quot;</span> <span class="comment">// 错误！返回 &amp;str，类型不匹配</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>编译器会报错，因为 <code>10</code> 是整数，而 <code>&quot;hello&quot;</code> 是字符串切片，它们的类型不同。</p>
</li>
<li><p><strong>块的最后一个表达式是返回值</strong>：在 Rust 中，一个代码块的值是其最后一个表达式的值（没有分号），没法使用return ***;的形式返回。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">value</span> = <span class="keyword">if</span> condition &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">temp</span> = <span class="number">10</span>;</span><br><span class="line">    temp + <span class="number">5</span> <span class="comment">// 这个表达式的值 15 就是整个 if 分支的返回值</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="number">20</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><p>rust中的循环分3种:</p>
<ol>
<li>loop</li>
<li>while</li>
<li>for</li>
</ol>
<p>需要注意的是，rust中是没有类似于C语言中do while()这种循环结构的，等效的功能可以由loop实现。</p>
<h4 id="loop"><a href="#loop" class="headerlink" title="loop:"></a>loop:</h4><p>loop循环类似于C语言中while(1)或者for(;;)，不手动用Break退出的话就会一直循环下去。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;again!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是,rust中有一个C语言中没有的特性:<strong>循环标签</strong></p>
<h5 id="循环标签-loop-labels-："><a href="#循环标签-loop-labels-：" class="headerlink" title="循环标签(loop labels)："></a>循环标签(loop labels)：</h5><p>语法:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">&#x27;label_name</span>: <span class="keyword">loop</span> &#123;</span><br><span class="line">    <span class="comment">// 循环体</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="symbol">&#x27;label_name</span>: <span class="keyword">while</span> condition &#123;</span><br><span class="line">    <span class="comment">// 循环体</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="symbol">&#x27;label_name</span>: <span class="keyword">for</span> <span class="variable">item</span> <span class="keyword">in</span> collection &#123;</span><br><span class="line">    <span class="comment">// 循环体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>循环标签的语法是在 <code>loop</code>、<code>while</code> 或 <code>for</code> 关键字之前加上一个<strong>单引号开头的名称</strong>，后面紧跟着一个<strong>冒号</strong>，然后在使用 <code>break</code> 或 <code>continue</code> 时指定这个标签，从而控制跳出或继续执行哪个具体的循环，即使它不是最内层循环。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">count</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="symbol">&#x27;outer_loop</span>: <span class="keyword">loop</span> &#123; <span class="comment">// 这是一个名为 &#x27;outer_loop 的循环</span></span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Outer loop count: &#123;count&#125;&quot;</span>);</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">inner_count</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="symbol">&#x27;inner_loop</span>: <span class="keyword">loop</span> &#123; <span class="comment">// 这是一个名为 &#x27;inner_loop 的循环</span></span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Inner loop count: &#123;inner_count&#125;&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> inner_count &gt;= <span class="number">2</span> &#123;</span><br><span class="line">                <span class="keyword">break</span> <span class="symbol">&#x27;inner_loop</span>; <span class="comment">// 跳出 &#x27;inner_loop</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> count &gt;= <span class="number">1</span> &#123;</span><br><span class="line">                <span class="keyword">break</span> <span class="symbol">&#x27;outer_loop</span>; <span class="comment">// 跳出 &#x27;outer_loop</span></span><br><span class="line">            &#125;</span><br><span class="line">            inner_count += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        count += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> count &gt;= <span class="number">3</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">// 跳出当前（外层）循环，这里其实效果和 break &#x27;outer_loop 一样，因为这是最外层循环</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Loop finished. Final count: &#123;count&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>rust的这种特性很好的避免了C语言中需要跳出复杂循环时需要设置标志位以及单独判断的情况。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> done = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">1</span> &amp;&amp; j == <span class="number">1</span>) &#123;</span><br><span class="line">            done = <span class="number">1</span>; <span class="comment">// 设置标志</span></span><br><span class="line">            <span class="keyword">break</span>;    <span class="comment">// 跳出内层循环</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i: %d, j: %d\n&quot;</span>, i, j);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (done) &#123;</span><br><span class="line">        <span class="keyword">break</span>; <span class="comment">// 根据标志跳出外层循环</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="while"><a href="#while" class="headerlink" title="while:"></a>while:</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Hello World&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>while循环的语法跟特性与C语言都是类似的，唯一的不同就是它的条件必须是一个bool量而不能是其他类型。</p>
<hr>
<h4 id="for"><a href="#for" class="headerlink" title="for:"></a>for:</h4><p>Rust的for循环与C语言的for循环有较大不同，Rust中的for循环类似于其他现代语言中的”for each”。</p>
<h2 id="核心差异总结"><a href="#核心差异总结" class="headerlink" title="核心差异总结"></a>核心差异总结</h2><table>
<thead>
<tr>
<th>特性</th>
<th align="center">C 语言的 <code>for</code> 循环</th>
<th align="center">Rust 的 <code>for</code> 循环</th>
</tr>
</thead>
<tbody><tr>
<td><strong>基础</strong></td>
<td align="center">基于<strong>计数器和条件</strong>，手动控制迭代过程</td>
<td align="center">基于<strong>迭代器</strong>，遍历集合中的每个元素</td>
</tr>
<tr>
<td><strong>语法</strong></td>
<td align="center"><code>for (init; condition; step)</code></td>
<td align="center"><code>for element in iterator</code></td>
</tr>
<tr>
<td><strong>安全性</strong></td>
<td align="center">容易出现索引越界和“差一错误”，需要手动管理</td>
<td align="center">Rust 的所有权和借用系统保证安全，避免越界访问</td>
</tr>
<tr>
<td><strong>简洁性</strong></td>
<td align="center">对于简单计数循环简洁，但遍历集合时需要额外索引管理</td>
<td align="center">遍历集合和范围时非常简洁，不需要手动索引或长度计算</td>
</tr>
<tr>
<td><strong>灵活性</strong></td>
<td align="center">可以实现任何循环逻辑，包括非标准迭代（但可能不清晰）</td>
<td align="center">通过迭代器适配器（<code>map</code>, <code>filter</code> 等）实现复杂迭代逻辑</td>
</tr>
<tr>
<td><strong>返回值</strong></td>
<td align="center">循环本身不返回值</td>
<td align="center">循环本身不返回值，但可以结合 <code>break</code> 来返回值</td>
</tr>
</tbody></table>
<p>语法如下:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> 元素 <span class="keyword">in</span> 迭代器 &#123;</span><br><span class="line">    <span class="comment">// 循环体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是简单的示例:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// Rust 示例：遍历向量（Vector）</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">numbers</span> = <span class="built_in">vec!</span>[<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// .iter() 方法返回一个迭代器，它产出对元素的不可变引用</span></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">number</span> <span class="keyword">in</span> numbers.<span class="title function_ invoke__">iter</span>() &#123;</span><br><span class="line">        <span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125; &quot;</span>, number);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(); <span class="comment">// 输出: 10 20 30 40 50</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Rust 示例：使用范围（Range）</span></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span>..<span class="number">5</span> &#123; <span class="comment">// 范围 [0, 5) 不包含 5</span></span><br><span class="line">        <span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125; &quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(); <span class="comment">// 输出: 0 1 2 3 4</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果需要索引，可以使用 .enumerate()</span></span><br><span class="line">    <span class="keyword">for</span> (index, number) <span class="keyword">in</span> numbers.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">enumerate</span>() &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Index: &#123;&#125;, Value: &#123;&#125;&quot;</span>, index, number);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>注意</strong>:Rust是可以通过break;在循环(for while loop)中返回值的，例子如下：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">counter</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// `loop` 作为一个表达式，通过 `break` 返回值</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span> = <span class="keyword">loop</span> &#123; <span class="comment">// 整个 loop 表达式将被赋值给 result</span></span><br><span class="line">        counter += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> counter == <span class="number">10</span> &#123;</span><br><span class="line">            <span class="keyword">break</span> counter * <span class="number">2</span>; <span class="comment">// 当 counter 等于 10 时，跳出循环，并将 counter * 2 作为 loop 表达式的值</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;; <span class="comment">// 注意这里的分号，表示表达式的结束</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The result is: &#123;&#125;&quot;</span>, result); <span class="comment">// 输出: The result is: 20</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The final counter value is: &#123;&#125;&quot;</span>, counter); <span class="comment">// 输出: The final counter value is: 10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/07/19/RUST%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0%E4%B9%8B%E6%89%80%E6%9C%89%E6%9D%83%E4%B8%8E%E5%BC%95%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.png">
      <meta itemprop="name" content="Chillward">
      <meta itemprop="description" content="谁躺在漆黑的舞台上，用身体迎接着光芒">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chillward的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/07/19/RUST%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0%E4%B9%8B%E6%89%80%E6%9C%89%E6%9D%83%E4%B8%8E%E5%BC%95%E7%94%A8/" class="post-title-link" itemprop="url">RUST学习日记之所有权与引用</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-07-19 10:22:13" itemprop="dateCreated datePublished" datetime="2025-07-19T10:22:13+08:00">2025-07-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-07-20 15:56:38" itemprop="dateModified" datetime="2025-07-20T15:56:38+08:00">2025-07-20</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>23k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>42 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>注意一个引用的作用域从声明的地方开始一直持续到最后一次使用为止。</p>
<p>生命周期 作用域</p>
<h2 id="核心区别总结"><a href="#核心区别总结" class="headerlink" title="核心区别总结"></a>核心区别总结</h2><table>
<thead>
<tr>
<th>特性</th>
<th>作用域 (Scope)</th>
<th>生命周期 (Lifetime)</th>
</tr>
</thead>
<tbody><tr>
<td><strong>定义对象</strong></td>
<td><strong>变量</strong>的可见性区域及其存活期</td>
<td><strong>引用</strong>的有效性时间段，即引用指向的数据存活的时间</td>
</tr>
<tr>
<td><strong>控制对象</strong></td>
<td>变量何时<strong>创建</strong>和<strong>销毁</strong></td>
<td>引用何时<strong>有效</strong>（不指向无效内存）</td>
</tr>
<tr>
<td><strong>关注点</strong></td>
<td>内存的<strong>分配与释放</strong></td>
<td><strong>内存安全</strong>，尤其是防止悬垂引用</td>
</tr>
<tr>
<td><strong>目的</strong></td>
<td>组织代码和管理资源</td>
<td>确保引用的有效性，由借用检查器（Borrow Checker）强制执行</td>
</tr>
<tr>
<td><strong>形式</strong></td>
<td>通常由 <code>&#123;&#125;</code> 代码块隐式定义</td>
<td>通常通过 <code>&#39;a</code>, <code>&#39;b</code> 等显式注解（当编译器无法推断时）</td>
</tr>
</tbody></table>
<blockquote>
<p>剩下的，官方的文档写的非常好，我也是直接复制过来用了(Bushi)</p>
</blockquote>
<h2 id="什么是所有权？"><a href="#什么是所有权？" class="headerlink" title="什么是所有权？"></a><a target="_blank" rel="noopener" href="https://kaisery.github.io/trpl-zh-cn/ch04-01-what-is-ownership.html#%E4%BB%80%E4%B9%88%E6%98%AF%E6%89%80%E6%9C%89%E6%9D%83">什么是所有权？</a></h2><p><strong>所有权</strong>（<em>ownership</em>）是 Rust 用于如何管理内存的一组规则。所有程序都必须管理其运行时使用计算机内存的方式。一些语言中具有垃圾回收机制，在程序运行时有规律地寻找不再使用的内存；在另一些语言中，程序员必须亲自分配和释放内存。Rust 则选择了第三种方式：通过所有权系统管理内存，编译器在编译时会根据一系列的规则进行检查。如果违反了任何这些规则，程序都不能编译。在运行时，所有权系统的任何功能都不会减慢程序的运行。</p>
<p>因为所有权对很多程序员来说都是一个新概念，需要一些时间来适应。好消息是随着你对 Rust 和所有权系统的规则越来越有经验，你就越能自然地编写出安全和高效的代码。持之以恒！</p>
<p>当你理解了所有权，你将有一个坚实的基础来理解那些使 Rust 独特的功能。在本章中，你将通过完成一些示例来学习所有权，这些示例基于一个常用的数据结构：字符串。</p>
<blockquote>
<h3 id="栈（Stack）与堆（Heap）"><a href="#栈（Stack）与堆（Heap）" class="headerlink" title="栈（Stack）与堆（Heap）"></a><a target="_blank" rel="noopener" href="https://kaisery.github.io/trpl-zh-cn/ch04-01-what-is-ownership.html#%E6%A0%88stack%E4%B8%8E%E5%A0%86heap">栈（Stack）与堆（Heap）</a></h3><p>在很多语言中，你并不需要经常考虑到栈与堆。不过在像 Rust 这样的系统编程语言中，值是位于栈上还是堆上在更大程度上影响了语言的行为以及为何必须做出这样的抉择。我们会在本章的稍后部分描述所有权与栈和堆相关的内容，所以这里只是一个用来预热的简要解释。</p>
<p>栈和堆都是代码在运行时可供使用的内存，但是它们的结构不同。栈以放入值的顺序存储值并以相反顺序取出值。这也被称作 <strong>后进先出</strong>（<em>last in, first out</em>）。想象一下一叠盘子：当增加更多盘子时，把它们放在盘子堆的顶部，当需要盘子时，也从顶部拿走。不能从中间也不能从底部增加或拿走盘子！增加数据叫做 <strong>入栈</strong>（<em>pushing onto the stack</em>），而移出数据叫做 <strong>出栈</strong>（<em>popping off the stack</em>）。栈中的所有数据都必须占用已知且固定的大小。在编译时大小未知或大小可能变化的数据，要改为存储在堆上。</p>
<p>堆是缺乏组织的：当向堆放入数据时，你要请求一定大小的空间。内存分配器（memory allocator）在堆的某处找到一块足够大的空位，把它标记为已使用，并返回一个表示该位置地址的 <strong>指针</strong>（<em>pointer</em>）。这个过程称作 <strong>在堆上分配内存</strong>（<em>allocating on the heap</em>），有时简称为 “分配”（allocating）。（将数据推入栈中并不被认为是分配）。因为指向放入堆中数据的指针是已知的并且大小是固定的，你可以将该指针存储在栈上，不过当需要实际数据时，必须访问指针。想象一下去餐馆就座吃饭。当进入时，你说明有几个人，餐馆员工会找到一个够大的空桌子并领你们过去。如果有人来迟了，他们也可以通过询问来找到你们坐在哪。</p>
<p>入栈比在堆上分配内存要快，因为（入栈时）分配器无需为存储新数据去搜索内存空间；其位置总是在栈顶。相比之下，在堆上分配内存则需要更多的工作，这是因为分配器必须首先找到一块足够存放数据的内存空间，并接着做一些记录为下一次分配做准备。</p>
<p>访问堆上的数据比访问栈上的数据慢，因为必须通过指针来访问。现代处理器在内存中跳转越少就越快。继续类比，假设有一个服务员在餐厅里处理多个桌子的点菜。在一个桌子报完所有菜后再移动到下一个桌子是最有效率的。从桌子 A 听一个菜，接着桌子 B 听一个菜，然后再桌子 A，然后再桌子 B 这样的流程会更加缓慢。出于同样原因，处理器在处理的数据彼此较近的时候（比如在栈上）比较远的时候（比如可能在堆上）更高效。</p>
<p>当你的代码调用一个函数时，传递给函数的值（包括可能指向堆上数据的指针）和函数的局部变量被压入栈中。当函数结束时，这些值被移出栈。</p>
<p>跟踪哪部分代码正在使用堆上的哪些数据，最大限度的减少堆上的重复数据的数量，以及清理堆上不再使用的数据确保不会耗尽空间，这些问题正是所有权系统要处理的。一旦理解了所有权，你就不需要经常考虑栈和堆了，不过明白了所有权的主要目的就是管理堆数据，能够帮助解释为什么所有权要以这种方式工作。</p>
</blockquote>
<h3 id="所有权规则"><a href="#所有权规则" class="headerlink" title="所有权规则"></a><a target="_blank" rel="noopener" href="https://kaisery.github.io/trpl-zh-cn/ch04-01-what-is-ownership.html#%E6%89%80%E6%9C%89%E6%9D%83%E8%A7%84%E5%88%99">所有权规则</a></h3><p>首先，让我们看一下所有权的规则。当我们通过举例说明时，请谨记这些规则：</p>
<blockquote>
<ol>
<li>Rust 中的每一个值都有一个 <strong>所有者</strong>（<em>owner</em>）。</li>
<li>值在任一时刻有且只有一个所有者。</li>
<li>当所有者离开作用域，这个值将被丢弃。</li>
</ol>
</blockquote>
<h3 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a><a target="_blank" rel="noopener" href="https://kaisery.github.io/trpl-zh-cn/ch04-01-what-is-ownership.html#%E5%8F%98%E9%87%8F%E4%BD%9C%E7%94%A8%E5%9F%9F">变量作用域</a></h3><p>既然我们已经掌握了基本语法，将不会在之后的例子中包含 <code>fn main() &#123;</code> 代码，所以如果你是一路跟过来的，必须手动将之后例子的代码放入一个 <code>main</code> 函数中。这样，例子将显得更加简明，使我们可以关注实际细节而不是样板代码。</p>
<p>在所有权的第一个例子中，我们看看一些变量的 <strong>作用域</strong>（<em>scope</em>）。作用域是一个项（item）在程序中有效的范围。假设有这样一个变量：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="string">&quot;hello&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>变量 <code>s</code> 绑定到了一个字符串字面值，这个字符串值是硬编码进程序代码中的。这个变量从声明的点开始直到当前<strong>作用域</strong>结束时都是有效的。示例 4-1 中的注释标明了变量 <code>s</code> 在何处是有效的。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;                      <span class="comment">// s 在这里无效，它尚未声明</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="string">&quot;hello&quot;</span>;   <span class="comment">// 从此处起，s 是有效的</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 s</span></span><br><span class="line">&#125;                      <span class="comment">// 此作用域已结束，s 不再有效</span></span><br></pre></td></tr></table></figure>

<p>示例 4-1：一个变量和其有效的作用域</p>
<p>换句话说，这里有两个重要的时间点：</p>
<ul>
<li>当 <code>s</code> <strong>进入作用域</strong>时，它就是有效的。</li>
<li>这一直持续到它<strong>离开作用域</strong>为止。</li>
</ul>
<p>目前为止，变量是否有效与作用域的关系跟其他编程语言是类似的。现在我们在此基础上介绍 <code>String</code> 类型。</p>
<h3 id="String-类型"><a href="#String-类型" class="headerlink" title="String 类型"></a><a target="_blank" rel="noopener" href="https://kaisery.github.io/trpl-zh-cn/ch04-01-what-is-ownership.html#string-%E7%B1%BB%E5%9E%8B"><code>String</code> 类型</a></h3><p>为了演示所有权的规则，我们需要一个比第三章 <a target="_blank" rel="noopener" href="https://kaisery.github.io/trpl-zh-cn/ch03-02-data-types.html#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">“数据类型”</a> 中讲到的都要复杂的数据类型。前面介绍的类型都是已知大小的，可以存储在栈中，并且当离开作用域时被移出栈，如果代码的另一部分需要在不同的作用域中使用相同的值，可以快速简单地复制它们来创建一个新的独立实例。不过我们需要寻找一个存储在堆上的数据来探索 Rust 是如何知道该在何时清理数据的，而 <code>String</code> 类型就是一个很好的例子。</p>
<p>我们会专注于 <code>String</code> 与所有权相关的部分。这些方面也同样适用于标准库提供的或你自己创建的其他复杂数据类型。在<a target="_blank" rel="noopener" href="https://kaisery.github.io/trpl-zh-cn/ch08-02-strings.html">第八章</a>会更深入地讲解 <code>String</code>。</p>
<p>我们已经见过字符串字面值，即被硬编码进程序里的字符串值。字符串字面值是很方便的，不过它们并不适合使用文本的每一种场景。原因之一就是它们是不可变的。另一个原因是并非所有字符串的值都能在编写代码时就知道：例如，要是想获取用户输入并存储该怎么办呢？为此，Rust 有另一种字符串类型，<code>String</code>。这个类型管理被分配到堆上的数据，所以能够存储在编译时未知大小的文本。可以使用 <code>from</code> 函数基于字符串字面值来创建 <code>String</code>，如下：</p>
<p>这两个冒号 <code>::</code> 是运算符，允许将特定的 <code>from</code> 函数置于 <code>String</code> 类型的命名空间（namespace）下，而不需要使用类似 <code>string_from</code> 这样的名字。在第五章的 <a target="_blank" rel="noopener" href="https://kaisery.github.io/trpl-zh-cn/ch05-03-method-syntax.html#%E6%96%B9%E6%B3%95%E8%AF%AD%E6%B3%95">“方法语法”（“Method Syntax”）</a> 部分会着重讲解这个语法，而且在第七章的 <a target="_blank" rel="noopener" href="https://kaisery.github.io/trpl-zh-cn/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html">“路径用于引用模块树中的项”</a> 中会讲到模块的命名空间。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">s.<span class="title function_ invoke__">push_str</span>(<span class="string">&quot;, world!&quot;</span>); <span class="comment">// push_str() 在字符串后追加字面值</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;s&#125;&quot;</span>); <span class="comment">// 将打印 `hello, world!`</span></span><br></pre></td></tr></table></figure>

<p>那么这里有什么区别呢？为什么 <code>String</code> 可变而字面值却不行呢？区别在于两个类型对内存的处理上。</p>
<h3 id="内存与分配"><a href="#内存与分配" class="headerlink" title="内存与分配"></a><a target="_blank" rel="noopener" href="https://kaisery.github.io/trpl-zh-cn/ch04-01-what-is-ownership.html#%E5%86%85%E5%AD%98%E4%B8%8E%E5%88%86%E9%85%8D">内存与分配</a></h3><p>就字符串字面值来说，我们在编译时就知道其内容，所以文本被直接硬编码进最终的可执行文件中。这使得字符串字面值快速且高效。不过这些特性都只得益于字符串字面值的不可变性。不幸的是，我们不能为了每一个在编译时大小未知的文本而将一块内存放入二进制文件中，并且它的大小还可能随着程序运行而改变。</p>
<p>对于 <code>String</code> 类型，为了支持一个可变，可增长的文本片段，需要在堆上分配一块在编译时未知大小的内存来存放内容。这意味着：</p>
<ul>
<li>必须在运行时向内存分配器（memory allocator）请求内存。</li>
<li>需要一个当我们处理完 <code>String</code> 时将内存返回给分配器的方法。</li>
</ul>
<p>第一部分由我们完成：当调用 <code>String::from</code> 时，它的实现 (<em>implementation</em>) 请求其所需的内存。这在编程语言中是非常通用的。</p>
<p>然而，第二部分实现起来就各有区别了。在有 <strong>垃圾回收</strong>（<em>garbage collector</em>，<em>GC</em>）的语言中，GC 记录并清除不再使用的内存，而我们并不需要关心它。在大部分没有 GC 的语言中，识别出不再使用的内存并调用代码显式释放就是我们的责任了，跟请求内存的时候一样。从历史的角度上说正确处理内存回收曾经是一个困难的编程问题。如果忘记回收了会浪费内存。如果过早回收了，将会出现无效变量。如果重复回收，这也是个 bug。我们需要精确的为一个 <code>allocate</code> 配对一个 <code>free</code>。</p>
<p>Rust 采取了一个不同的策略：内存在拥有它的变量离开作用域后就被自动释放。下面是示例 4-1 中作用域例子的一个使用 <code>String</code> 而不是字符串字面值的版本：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>); <span class="comment">// 从此处起，s 是有效的</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 s</span></span><br><span class="line">&#125;                                  <span class="comment">// 此作用域已结束，</span></span><br><span class="line">                                   <span class="comment">// s 不再有效</span></span><br></pre></td></tr></table></figure>

<p>这是一个将 <code>String</code> 需要的内存返回给分配器的很自然的位置：当 <code>s</code> 离开作用域的时候。当变量离开作用域，Rust 为我们调用一个特殊的函数。这个函数叫做 <a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/ops/trait.Drop.html#tymethod.drop"><code>drop</code></a>，在这里 <code>String</code> 的作者可以放置释放内存的代码。Rust 在结尾的 <code>&#125;</code> 处自动调用 <code>drop</code>。</p>
<blockquote>
<p>注意：在 C++ 中，这种 item 在生命周期结束时释放资源的模式有时被称作 <strong>资源获取即初始化</strong>（<em>Resource Acquisition Is Initialization (RAII)</em>）。如果你使用过 RAII 模式的话应该对 Rust 的 <code>drop</code> 函数并不陌生。</p>
</blockquote>
<p>这个模式对编写 Rust 代码的方式有着深远的影响。现在它看起来很简单，不过在更复杂的场景下代码的行为可能是不可预测的，比如当有多个变量使用在堆上分配的内存时。现在让我们探索一些这样的场景。</p>
<h4 id="使用移动的变量与数据交互"><a href="#使用移动的变量与数据交互" class="headerlink" title="使用移动的变量与数据交互"></a><a target="_blank" rel="noopener" href="https://kaisery.github.io/trpl-zh-cn/ch04-01-what-is-ownership.html#%E4%BD%BF%E7%94%A8%E7%A7%BB%E5%8A%A8%E7%9A%84%E5%8F%98%E9%87%8F%E4%B8%8E%E6%95%B0%E6%8D%AE%E4%BA%A4%E4%BA%92">使用移动的变量与数据交互</a></h4><p>在 Rust 中，多个变量可以采取不同的方式与同一数据进行交互。让我们看看示例 4-2 中一个使用整型的例子。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">y</span> = x;</span><br></pre></td></tr></table></figure>

<p>示例 4-2：将变量 <code>x</code> 的整数值赋给 <code>y</code></p>
<p>我们大致可以猜到这在干什么：“将 <code>5</code> 绑定到 <code>x</code>；接着生成一个值 <code>x</code> 的拷贝并绑定到 <code>y</code>”。现在有了两个变量，<code>x</code> 和 <code>y</code>，都等于 <code>5</code>。这也正是事实上发生了的，因为整数是有已知固定大小的简单值，所以这两个 <code>5</code> 被压入了栈中。</p>
<p>现在看看这个 <code>String</code> 版本：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s2</span> = s1;</span><br></pre></td></tr></table></figure>

<p>这看起来与上面的代码非常类似，所以我们可能会假设它们的运行方式也是类似的：也就是说，第二行可能会生成一个 <code>s1</code> 的拷贝并绑定到 <code>s2</code> 上。但事实并非如此。</p>
<p>看看图 4-1 以了解 <code>String</code> 的底层会发生什么。<code>String</code> 由三部分组成，如图左侧所示：一个指向存放字符串内容内存的指针，一个长度，和一个容量。这一组数据存储在栈上。右侧则是堆上存放内容的内存部分。</p>
<p><img data-src="https://kaisery.github.io/trpl-zh-cn/img/trpl04-01.svg" alt="Two tables: the first table contains the representation of s1 on the stack, consisting of its length (5), capacity (5), and a pointer to the first value in the second table. The second table contains the representation of the string data on the heap, byte by byte."></p>
<p>图 4-1：将值 <code>&quot;hello&quot;</code> 绑定给 <code>s1</code> 的 <code>String</code> 在内存中的表现形式</p>
<p>长度表示 <code>String</code> 的内容当前使用了多少字节的内存。容量是 <code>String</code> 从分配器总共获取了多少字节的内存。长度与容量的区别是很重要的，不过在当前上下文中并不重要，所以现在可以忽略容量。</p>
<p>当我们将 <code>s1</code> 赋值给 <code>s2</code>，<code>String</code> 的数据被复制了，这意味着我们从栈上拷贝了它的指针、长度和容量。我们并没有复制指针指向的堆上数据。换句话说，内存中数据的表现如图 4-2 所示。</p>
<p><img data-src="https://kaisery.github.io/trpl-zh-cn/img/trpl04-02.svg" alt="Three tables: tables s1 and s2 representing those strings on the stack, respectively, and both pointing to the same string data on the heap."></p>
<p>图 4-2：变量 <code>s2</code> 的内存表现，它有一份 <code>s1</code> 指针、长度和容量的拷贝</p>
<p>这个表现形式看起来<strong>并不像</strong>图 4-3 中的那样，如果 Rust 也拷贝了堆上的数据，那么内存看起来就是这样的。如果 Rust 这么做了，那么操作 <code>s2 = s1</code> 在堆上数据比较大的时候会对运行时性能造成非常大的影响。</p>
<p><img data-src="https://kaisery.github.io/trpl-zh-cn/img/trpl04-03.svg" alt="Four tables: two tables representing the stack data for s1 and s2, and each points to its own copy of string data on the heap."></p>
<p>图 4-3：另一个 <code>s2 = s1</code> 时可能的内存表现，如果 Rust 同时也拷贝了堆上的数据的话</p>
<p>之前我们提到过当变量离开作用域后，Rust 自动调用 <code>drop</code> 函数并清理变量的堆内存。不过图 4-2 展示了两个数据指针指向了同一位置。这就有了一个问题：当 <code>s2</code> 和 <code>s1</code> 离开作用域，它们都会尝试释放相同的内存。这是一个叫做 <strong>二次释放</strong>（<em>double free</em>）的错误，也是之前提到过的内存安全性 bug 之一。两次释放（相同）内存会导致内存污染，它可能会导致潜在的安全漏洞。</p>
<p>为了确保内存安全，在 <code>let s2 = s1;</code> 之后，Rust 认为 <code>s1</code> 不再有效，因此 Rust 不需要在 <code>s1</code> 离开作用域后清理任何东西。看看在 <code>s2</code> 被创建之后尝试使用 <code>s1</code> 会发生什么；这段代码不能运行：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s2</span> = s1;</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;s1&#125;, world!&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>你会得到一个类似如下的错误，因为 Rust 禁止你使用无效的引用。</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cargo run</span></span><br><span class="line">   Compiling ownership v0.1.0 (file:///projects/ownership)</span><br><span class="line">error[E0382]: borrow of moved value: `s1`</span><br><span class="line"><span class="meta prompt_"> --&gt; </span><span class="language-bash">src/main.rs:5:15</span></span><br><span class="line">  |</span><br><span class="line">2 |     let s1 = String::from(&quot;hello&quot;);</span><br><span class="line">  |         -- move occurs because `s1` has type `String`, which does not implement the `Copy` trait</span><br><span class="line">3 |     let s2 = s1;</span><br><span class="line">  |              -- value moved here</span><br><span class="line">4 |</span><br><span class="line">5 |     println!(&quot;&#123;s1&#125;, world!&quot;);</span><br><span class="line">  |               ^^^^ value borrowed here after move</span><br><span class="line">  |</span><br><span class="line">  = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)</span><br><span class="line">help: consider cloning the value if the performance cost is acceptable</span><br><span class="line">  |</span><br><span class="line">3 |     let s2 = s1.clone();</span><br><span class="line">  |                ++++++++</span><br><span class="line"></span><br><span class="line">For more information about this error, try `rustc --explain E0382`.</span><br><span class="line">error: could not compile `ownership` (bin &quot;ownership&quot;) due to 1 previous error</span><br></pre></td></tr></table></figure>

<p>如果你在其他语言中听说过术语 <strong>浅拷贝</strong>（<em>shallow copy</em>）和 <strong>深拷贝</strong>（<em>deep copy</em>），那么拷贝指针、长度和容量而不拷贝数据可能听起来像浅拷贝。不过因为 Rust 同时使第一个变量无效了，这个操作被称为 <strong>移动</strong>（<em>move</em>），而不是叫做浅拷贝。上面的例子可以解读为 <code>s1</code> 被 <strong>移动</strong> 到了 <code>s2</code> 中。那么具体发生了什么，如图 4-4 所示。</p>
<p><img data-src="https://kaisery.github.io/trpl-zh-cn/img/trpl04-04.svg" alt="Three tables: tables s1 and s2 representing those strings on the stack, respectively, and both pointing to the same string data on the heap. Table s1 is grayed out be-cause s1 is no longer valid; only s2 can be used to access the heap data."></p>
<p>图 4-4：<code>s1</code> 无效之后的内存表现</p>
<p>这样就解决了我们的问题！因为只有 <code>s2</code> 是有效的，当其离开作用域，它就释放自己的内存，完毕。</p>
<p>另外，这里还隐含了一个设计选择：Rust 永远也不会自动创建数据的 “深拷贝”。因此，任何<strong>自动</strong>的复制都可以被认为是对运行时性能影响较小的。</p>
<h4 id="作用域与赋值"><a href="#作用域与赋值" class="headerlink" title="作用域与赋值"></a><a target="_blank" rel="noopener" href="https://kaisery.github.io/trpl-zh-cn/ch04-01-what-is-ownership.html#%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E8%B5%8B%E5%80%BC">作用域与赋值</a></h4><p>作用域、所有权和通过 <code>drop</code> 函数释放内存之间的关系反过来也同样成立。当你给一个已有的变量赋一个全新的值时，Rust 将会立即调用 <code>drop</code> 并释放原始值的内存。例如，考虑如下代码：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">s = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;ahoy&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;s&#125;, world!&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>起初我们声明了变量 <code>s</code> 并绑定为一个 <code>&quot;hello&quot;</code> 值的 <code>String</code>。接着立即创建了一个值为 <code>&quot;ahoy&quot;</code> 的 <code>String</code> 并赋值给 <code>s</code>。在这里，完全没有任何内容指向了原始堆上的值。</p>
<p><img data-src="https://kaisery.github.io/trpl-zh-cn/img/trpl04-05.svg" alt="One table s representing the string value on the stack, pointing to the second piece of string data (ahoy) on the heap, with the original string data (hello) grayed out because it cannot be accessed anymore."></p>
<p>图 4-5: 当初始值被整体替换后的内存表现</p>
<p>因此原始的字符串立刻就离开了作用域。Rust 会在其上运行 <code>drop</code> 函数同时内存会马上释放。当结尾打印其值时，将会是 <code>&quot;ahoy, world!&quot;</code>。</p>
<h4 id="使用克隆的变量与数据交互"><a href="#使用克隆的变量与数据交互" class="headerlink" title="使用克隆的变量与数据交互"></a><a target="_blank" rel="noopener" href="https://kaisery.github.io/trpl-zh-cn/ch04-01-what-is-ownership.html#%E4%BD%BF%E7%94%A8%E5%85%8B%E9%9A%86%E7%9A%84%E5%8F%98%E9%87%8F%E4%B8%8E%E6%95%B0%E6%8D%AE%E4%BA%A4%E4%BA%92">使用克隆的变量与数据交互</a></h4><p>如果我们 <strong>确实</strong> 需要深度复制 <code>String</code> 中堆上的数据，而不仅仅是栈上的数据，可以使用一个叫做 <code>clone</code> 的常用方法。第五章会讨论方法语法，不过因为方法在很多语言中是一个常见功能，所以之前你可能已经见过了。</p>
<p>这是一个实际使用 <code>clone</code> 方法的例子：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s2</span> = s1.<span class="title function_ invoke__">clone</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;s1 = &#123;s1&#125;, s2 = &#123;s2&#125;&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>这段代码能正常运行，并且明确产生图 4-3 中行为，这里堆上的数据<strong>确实</strong>被复制了。</p>
<p>当出现 <code>clone</code> 调用时，你知道一些特定的代码被执行而且这些代码可能相当消耗资源。你很容易察觉到一些不寻常的事情正在发生。</p>
<h4 id="只在栈上的数据：拷贝"><a href="#只在栈上的数据：拷贝" class="headerlink" title="只在栈上的数据：拷贝"></a><a target="_blank" rel="noopener" href="https://kaisery.github.io/trpl-zh-cn/ch04-01-what-is-ownership.html#%E5%8F%AA%E5%9C%A8%E6%A0%88%E4%B8%8A%E7%9A%84%E6%95%B0%E6%8D%AE%E6%8B%B7%E8%B4%9D">只在栈上的数据：拷贝</a></h4><p>这里还有一个没有提到的细节。这些代码使用了整型并且是有效的，它们是示例 4-2 中的一部分：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">y</span> = x;</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;x = &#123;x&#125;, y = &#123;y&#125;&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>但这段代码似乎与我们刚刚学到的内容相矛盾：没有调用 <code>clone</code>，不过 <code>x</code> 依然有效且没有被移动到 <code>y</code> 中。</p>
<p>原因是像整型这样的在编译时已知大小的类型被整个存储在栈上，所以拷贝其实际的值是快速的。这意味着没有理由在创建变量 <code>y</code> 后使 <code>x</code> 无效。换句话说，这里没有深浅拷贝的区别，所以这里调用 <code>clone</code> 并不会与通常的浅拷贝有什么不同，我们可以不用管它。</p>
<p>Rust 有一个叫做 <code>Copy</code> trait 的特殊注解，可以用在类似整型这样的存储在栈上的类型上（<a target="_blank" rel="noopener" href="https://kaisery.github.io/trpl-zh-cn/ch10-00-generics.html">第十章</a>将会详细讲解 trait）。如果一个类型实现了 <code>Copy</code> trait，那么一个旧的变量在将其赋值给其他变量后仍然有效。</p>
<p>Rust 不允许自身或其任何部分实现了 <code>Drop</code> trait 的类型使用 <code>Copy</code> trait。如果我们对其值离开作用域时需要特殊处理的类型使用 <code>Copy</code> 注解，将会出现一个编译时错误。要学习如何为你的类型添加 <code>Copy</code> 注解以实现该 trait，请阅读附录 C 中的 <a target="_blank" rel="noopener" href="https://kaisery.github.io/trpl-zh-cn/appendix-03-derivable-traits.html">“可派生的 trait”</a>。</p>
<p>那么哪些类型实现了 <code>Copy</code> trait 呢？你可以查看给定类型的文档来确认，不过作为一个通用的规则，任何一组简单标量值的组合都可以实现 <code>Copy</code>，任何不需要分配内存或某种形式资源的类型都可以实现 <code>Copy</code> 。如下是一些 <code>Copy</code> 的类型：</p>
<ul>
<li>所有整数类型，比如 <code>u32</code>。</li>
<li>布尔类型，<code>bool</code>，它的值是 <code>true</code> 和 <code>false</code>。</li>
<li>所有浮点数类型，比如 <code>f64</code>。</li>
<li>字符类型，<code>char</code>。</li>
<li>元组，当且仅当其包含的类型也都实现 <code>Copy</code> 的时候。比如，<code>(i32, i32)</code> 实现了 <code>Copy</code>，但 <code>(i32, String)</code> 就没有。</li>
</ul>
<h3 id="所有权与函数"><a href="#所有权与函数" class="headerlink" title="所有权与函数"></a><a target="_blank" rel="noopener" href="https://kaisery.github.io/trpl-zh-cn/ch04-01-what-is-ownership.html#%E6%89%80%E6%9C%89%E6%9D%83%E4%B8%8E%E5%87%BD%E6%95%B0">所有权与函数</a></h3><p>将值传递给函数与给变量赋值的原理相似。向函数传递值可能会移动或者复制，就像赋值语句一样。示例 4-3 使用注释展示变量何时进入和离开作用域：</p>
<p>文件名：src&#x2F;main.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);  <span class="comment">// s 进入作用域</span></span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">takes_ownership</span>(s);             <span class="comment">// s 的值移动到函数里 ...</span></span><br><span class="line">                                    <span class="comment">// ... 所以到这里不再有效</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;                      <span class="comment">// x 进入作用域</span></span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">makes_copy</span>(x);                  <span class="comment">// x 应该移动函数里，</span></span><br><span class="line">                                    <span class="comment">// 但 i32 是 Copy 的，</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, x);              <span class="comment">// 所以在后面可继续使用 x</span></span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// 这里，x 先移出了作用域，然后是 s。但因为 s 的值已被移走，</span></span><br><span class="line">  <span class="comment">// 没有特殊之处</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">takes_ownership</span>(some_string: <span class="type">String</span>) &#123; <span class="comment">// some_string 进入作用域</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;some_string&#125;&quot;</span>);</span><br><span class="line">&#125; <span class="comment">// 这里，some_string 移出作用域并调用 `drop` 方法。</span></span><br><span class="line">  <span class="comment">// 占用的内存被释放</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">makes_copy</span>(some_integer: <span class="type">i32</span>) &#123; <span class="comment">// some_integer 进入作用域</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;some_integer&#125;&quot;</span>);</span><br><span class="line">&#125; <span class="comment">// 这里，some_integer 移出作用域。没有特殊之处</span></span><br></pre></td></tr></table></figure>

<p>示例 4-3：带有所有权和作用域注释的函数</p>
<p>当尝试在调用 <code>takes_ownership</code> 后使用 <code>s</code> 时，Rust 会抛出一个编译时错误。这些静态检查使我们免于犯错。试试在 <code>main</code> 函数中添加使用 <code>s</code> 和 <code>x</code> 的代码来看看哪里能使用它们，以及所有权规则会在哪里阻止我们这么做。</p>
<h3 id="返回值与作用域"><a href="#返回值与作用域" class="headerlink" title="返回值与作用域"></a><a target="_blank" rel="noopener" href="https://kaisery.github.io/trpl-zh-cn/ch04-01-what-is-ownership.html#%E8%BF%94%E5%9B%9E%E5%80%BC%E4%B8%8E%E4%BD%9C%E7%94%A8%E5%9F%9F">返回值与作用域</a></h3><p>返回值也可以转移所有权。示例 4-4 展示了一个返回了某些值的示例，与示例 4-3 一样带有类似的注释。</p>
<p>文件名：src&#x2F;main.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s1</span> = <span class="title function_ invoke__">gives_ownership</span>();        <span class="comment">// gives_ownership 将它的返回值传递给 s1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s2</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);    <span class="comment">// s2 进入作用域</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s3</span> = <span class="title function_ invoke__">takes_and_gives_back</span>(s2); <span class="comment">// s2 被传入 takes_and_gives_back, </span></span><br><span class="line">                                       <span class="comment">// 它的返回值又传递给 s3</span></span><br><span class="line">&#125; <span class="comment">// 此处，s3 移出作用域并被丢弃。s2 被 move，所以无事发生</span></span><br><span class="line">  <span class="comment">// s1 移出作用域并被丢弃</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">gives_ownership</span>() <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;       <span class="comment">// gives_ownership 将会把返回值传入</span></span><br><span class="line">                                       <span class="comment">// 调用它的函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">some_string</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;yours&quot;</span>); <span class="comment">// some_string 进入作用域</span></span><br><span class="line"></span><br><span class="line">    some_string                        <span class="comment">// 返回 some_string 并将其移至调用函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 该函数将传入字符串并返回该值</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">takes_and_gives_back</span>(a_string: <span class="type">String</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">    <span class="comment">// a_string 进入作用域</span></span><br><span class="line"></span><br><span class="line">    a_string  <span class="comment">// 返回 a_string 并移出给调用的函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例 4-4: 转移返回值的所有权</p>
<p>变量的所有权总是遵循相同的模式：将值赋给另一个变量时它会移动。当持有堆中数据值的变量离开作用域时，其值将通过 <code>drop</code> 被清理掉，除非数据被移动为另一个变量所有。</p>
<p>虽然这样是可以的，但是在每一个函数中都获取所有权并接着返回所有权有些啰嗦。如果我们想要函数使用一个值但不获取所有权该怎么办呢？如果我们还要接着使用它的话，每次都传进去再返回来就有点烦人了，除此之外，我们也可能想返回函数体中产生的一些数据。</p>
<p>我们可以使用元组来返回多个值，如示例 4-5 所示。</p>
<p>文件名：src&#x2F;main.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> (s2, len) = <span class="title function_ invoke__">calculate_length</span>(s1);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The length of &#x27;&#123;s2&#125;&#x27; is &#123;len&#125;.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">calculate_length</span>(s: <span class="type">String</span>) <span class="punctuation">-&gt;</span> (<span class="type">String</span>, <span class="type">usize</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">length</span> = s.<span class="title function_ invoke__">len</span>(); <span class="comment">// len() 返回字符串的长度</span></span><br><span class="line"></span><br><span class="line">    (s, length)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例 4-5: 返回参数的所有权</p>
<h2 id="引用与借用"><a href="#引用与借用" class="headerlink" title="引用与借用"></a><a target="_blank" rel="noopener" href="https://kaisery.github.io/trpl-zh-cn/ch04-02-references-and-borrowing.html#%E5%BC%95%E7%94%A8%E4%B8%8E%E5%80%9F%E7%94%A8">引用与借用</a></h2><p>示例 4-5 中的元组代码有这样一个问题：我们必须将 <code>String</code> 返回给调用函数，以便在调用 <code>calculate_length</code> 后仍能使用 <code>String</code>，因为 <code>String</code> 被移动到了 <code>calculate_length</code> 内。相反我们可以提供一个 <code>String</code> 值的引用（reference）。<strong>引用</strong>（<em>reference</em>）像一个指针，因为它是一个地址，我们可以由此访问储存于该地址的属于其他变量的数据。与指针不同，引用在其生命周期内保证指向某个特定类型的有效值。</p>
<p>下面是如何定义并使用一个（新的）<code>calculate_length</code> 函数，它以一个对象的引用作为参数而不是获取值的所有权：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">len</span> = <span class="title function_ invoke__">calculate_length</span>(&amp;s1);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The length of &#x27;&#123;s1&#125;&#x27; is &#123;len&#125;.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">calculate_length</span>(s: &amp;<span class="type">String</span>) <span class="punctuation">-&gt;</span> <span class="type">usize</span> &#123;</span><br><span class="line">    s.<span class="title function_ invoke__">len</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先，注意变量声明和函数返回值中的所有元组代码都消失了。其次，注意我们传递 <code>&amp;s1</code> 给 <code>calculate_length</code>，同时在函数定义中，我们获取 <code>&amp;String</code> 而不是 <code>String</code>。这些 &amp; 符号就是 <strong>引用</strong>，它们允许你使用值但不获取其所有权。图 4-6 展示了一张示意图。</p>
<p><img data-src="https://kaisery.github.io/trpl-zh-cn/img/trpl04-06.svg" alt="Three tables: the table for s contains only a pointer to the table for s1. The table for s1 contains the stack data for s1 and points to the string data on the heap."></p>
<p>图 4-6：<code>&amp;String s</code> 指向 <code>String s1</code> 示意图</p>
<blockquote>
<p>注意：与使用 <code>&amp;</code> 引用相反的操作是 <strong>解引用</strong>（<em>dereferencing</em>），它使用解引用运算符 <code>*</code> 实现。我们将会在第八章遇到一些解引用运算符，并在第十五章详细讨论解引用。</p>
</blockquote>
<p>仔细看看这个函数调用：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">len</span> = <span class="title function_ invoke__">calculate_length</span>(&amp;s1);</span><br></pre></td></tr></table></figure>

<p><code>&amp;s1</code> 语法让我们创建一个<strong>指向</strong>值 <code>s1</code> 的引用，但是并不拥有它。因为并不拥有这个值，所以当引用停止使用时，它所指向的值也不会被丢弃。</p>
<p>同理，函数签名使用 <code>&amp;</code> 来表明参数 <code>s</code> 的类型是一个引用。让我们增加一些解释性的注释：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">calculate_length</span>(s: &amp;<span class="type">String</span>) <span class="punctuation">-&gt;</span> <span class="type">usize</span> &#123; <span class="comment">// s 是 String 的引用</span></span><br><span class="line">    s.<span class="title function_ invoke__">len</span>()</span><br><span class="line">&#125; <span class="comment">// 这里，s 离开了作用域。但因为它并不拥有引用值的所有权，</span></span><br><span class="line">  <span class="comment">// 所以什么也不会发生</span></span><br></pre></td></tr></table></figure>

<p>变量 <code>s</code> 有效的作用域与函数参数的作用域一样，不过当 <code>s</code> 停止使用时并不丢弃引用指向的数据，因为 <code>s</code> 并没有所有权。当函数使用引用而不是实际值作为参数，无需返回值来交还所有权，因为就不曾拥有所有权。</p>
<p>我们将创建一个引用的行为称为 <strong>借用</strong>（<em>borrowing</em>）。正如现实生活中，如果一个人拥有某样东西，你可以从他那里借来。当你使用完后，必须还回去。因为我们并不拥有它的所有权。</p>
<p>那如果我们尝试修改借用的变量呢？尝试示例 4-6 中的代码。剧透：这行不通！</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">change</span>(&amp;s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">change</span>(some_string: &amp;<span class="type">String</span>) &#123;</span><br><span class="line">    some_string.<span class="title function_ invoke__">push_str</span>(<span class="string">&quot;, world&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例 4-6：尝试修改借用的值</p>
<p>这里是错误：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cargo run</span></span><br><span class="line">   Compiling ownership v0.1.0 (file:///projects/ownership)</span><br><span class="line">error[E0596]: cannot borrow `*some_string` as mutable, as it is behind a `&amp;` reference</span><br><span class="line"><span class="meta prompt_"> --&gt; </span><span class="language-bash">src/main.rs:8:5</span></span><br><span class="line">  |</span><br><span class="line">8 |     some_string.push_str(&quot;, world&quot;);</span><br><span class="line">  |     ^^^^^^^^^^^ `some_string` is a `&amp;` reference, so the data it refers to cannot be borrowed as mutable</span><br><span class="line">  |</span><br><span class="line">help: consider changing this to be a mutable reference</span><br><span class="line">  |</span><br><span class="line">7 | fn change(some_string: &amp;mut String) &#123;</span><br><span class="line">  |                         +++</span><br><span class="line"></span><br><span class="line">For more information about this error, try `rustc --explain E0596`.</span><br><span class="line">error: could not compile `ownership` (bin &quot;ownership&quot;) due to 1 previous error</span><br></pre></td></tr></table></figure>

<p>正如变量默认是不可变的，引用也一样。（默认）不允许修改引用的值。</p>
<h3 id="可变引用"><a href="#可变引用" class="headerlink" title="可变引用"></a><a target="_blank" rel="noopener" href="https://kaisery.github.io/trpl-zh-cn/ch04-02-references-and-borrowing.html#%E5%8F%AF%E5%8F%98%E5%BC%95%E7%94%A8">可变引用</a></h3><p>我们通过一个小调整就能修复示例 4-6 代码中的错误，允许我们修改一个借用的值，这就是 <strong>可变引用</strong>（<em>mutable reference</em>）：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">change</span>(&amp;<span class="keyword">mut</span> s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">change</span>(some_string: &amp;<span class="keyword">mut</span> <span class="type">String</span>) &#123;</span><br><span class="line">    some_string.<span class="title function_ invoke__">push_str</span>(<span class="string">&quot;, world&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先，我们必须将 <code>s</code> 改为 <code>mut</code>。然后在调用 <code>change</code> 函数的地方创建一个可变引用 <code>&amp;mut s</code>，并更新函数签名以接受一个可变引用 <code>some_string: &amp;mut String</code>。这就非常清楚地表明，<code>change</code> 函数将改变它所借用的值。</p>
<p>可变引用有一个很大的限制：如果你有一个对该变量的可变引用，你就不能再创建对该变量的引用。这些尝试创建两个 <code>s</code> 的可变引用的代码会失败：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">r1</span> = &amp;<span class="keyword">mut</span> s;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">r2</span> = &amp;<span class="keyword">mut</span> s;</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;, &#123;&#125;&quot;</span>, r1, r2);</span><br></pre></td></tr></table></figure>

<p>错误如下：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cargo run</span></span><br><span class="line">   Compiling ownership v0.1.0 (file:///projects/ownership)</span><br><span class="line">error[E0499]: cannot borrow `s` as mutable more than once at a time</span><br><span class="line"><span class="meta prompt_"> --&gt; </span><span class="language-bash">src/main.rs:5:14</span></span><br><span class="line">  |</span><br><span class="line">4 |     let r1 = &amp;mut s;</span><br><span class="line">  |              ------ first mutable borrow occurs here</span><br><span class="line">5 |     let r2 = &amp;mut s;</span><br><span class="line">  |              ^^^^^^ second mutable borrow occurs here</span><br><span class="line">6 |</span><br><span class="line">7 |     println!(&quot;&#123;&#125;, &#123;&#125;&quot;, r1, r2);</span><br><span class="line">  |                        -- first borrow later used here</span><br><span class="line"></span><br><span class="line">For more information about this error, try `rustc --explain E0499`.</span><br><span class="line">error: could not compile `ownership` (bin &quot;ownership&quot;) due to 1 previous error</span><br></pre></td></tr></table></figure>

<p>这个报错说这段代码是无效的，因为我们不能在同一时间多次将 <code>s</code> 作为可变变量借用。第一个可变的借入在 <code>r1</code> 中，并且必须持续到在 <code>println!</code> 中使用它，但是在那个可变引用的创建和它的使用之间，我们又尝试在 <code>r2</code> 中创建另一个可变引用，该引用借用与 <code>r1</code> 相同的数据。</p>
<p>这一限制以一种非常小心谨慎的方式允许可变性，防止同一时间对同一数据存在多个可变引用。新 Rustacean 们经常难以适应这一点，因为大部分语言中变量任何时候都是可变的。这个限制的好处是 Rust 可以在编译时就避免数据竞争。<strong>数据竞争</strong>（<em>data race</em>）类似于竞态条件，它可由这三个行为造成：</p>
<ul>
<li>两个或更多指针同时访问同一数据。</li>
<li>至少有一个指针被用来写入数据。</li>
<li>没有同步数据访问的机制。</li>
</ul>
<p>数据竞争会导致未定义行为，难以在运行时追踪，并且难以诊断和修复；Rust 通过拒绝编译存在数据竞争的代码来避免此问题！</p>
<p>一如既往，可以使用大括号来创建一个新的作用域，以允许拥有多个可变引用，只是不能<strong>同时</strong>拥有：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r1</span> = &amp;<span class="keyword">mut</span> s;</span><br><span class="line">&#125; <span class="comment">// r1 在这里离开了作用域，所以我们完全可以创建一个新的引用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">r2</span> = &amp;<span class="keyword">mut</span> s;</span><br></pre></td></tr></table></figure>

<p>Rust 在同时使用可变与不可变引用时也强制采用类似的规则。这些代码会导致一个错误：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">r1</span> = &amp;s; <span class="comment">// 没问题</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">r2</span> = &amp;s; <span class="comment">// 没问题</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">r3</span> = &amp;<span class="keyword">mut</span> s; <span class="comment">// 大问题</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;, &#123;&#125;, and &#123;&#125;&quot;</span>, r1, r2, r3);</span><br></pre></td></tr></table></figure>

<p>错误如下：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cargo run</span></span><br><span class="line">   Compiling ownership v0.1.0 (file:///projects/ownership)</span><br><span class="line">error[E0502]: cannot borrow `s` as mutable because it is also borrowed as immutable</span><br><span class="line"><span class="meta prompt_"> --&gt; </span><span class="language-bash">src/main.rs:6:14</span></span><br><span class="line">  |</span><br><span class="line">4 |     let r1 = &amp;s; // no problem</span><br><span class="line">  |              -- immutable borrow occurs here</span><br><span class="line">5 |     let r2 = &amp;s; // no problem</span><br><span class="line">6 |     let r3 = &amp;mut s; // BIG PROBLEM</span><br><span class="line">  |              ^^^^^^ mutable borrow occurs here</span><br><span class="line">7 |</span><br><span class="line">8 |     println!(&quot;&#123;&#125;, &#123;&#125;, and &#123;&#125;&quot;, r1, r2, r3);</span><br><span class="line">  |                                -- immutable borrow later used here</span><br><span class="line"></span><br><span class="line">For more information about this error, try `rustc --explain E0502`.</span><br><span class="line">error: could not compile `ownership` (bin &quot;ownership&quot;) due to 1 previous error</span><br></pre></td></tr></table></figure>

<p>呼！我们<strong>也</strong>不能在拥有不可变引用的同时拥有可变引用。</p>
<p>不可变引用的借用者可不希望在借用时值会突然发生改变！然而，多个不可变引用是可以的，因为没有哪个只能读取数据的引用者能够影响其他引用者读取到的数据。</p>
<p>注意一个引用的作用域从声明的地方开始一直持续到最后一次使用为止。例如，因为最后一次使用不可变引用的位置在 <code>println!</code>，它发生在声明可变引用之前，所以如下代码是可以编译的：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">r1</span> = &amp;s; <span class="comment">// 没问题</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">r2</span> = &amp;s; <span class="comment">// 没问题</span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;r1&#125; and &#123;r2&#125;&quot;</span>);</span><br><span class="line"><span class="comment">// 此位置之后 r1 和 r2 不再使用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">r3</span> = &amp;<span class="keyword">mut</span> s; <span class="comment">// 没问题</span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;r3&#125;&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>不可变引用 <code>r1</code> 和 <code>r2</code> 的作用域在 <code>println!</code> 最后一次使用之后结束，这发生在可变引用 <code>r3</code> 被创建之前。因为它们的作用域没有重叠，所以代码是可以编译的。编译器可以在作用域结束之前判断不再使用的引用。</p>
<p>尽管借用错误有时令人沮丧，但请牢记这是 Rust 编译器在提前指出一个潜在的 bug（在编译时而不是在运行时）并精准显示问题所在。这样你就不必去跟踪为何数据并不是你想象中的那样。</p>
<h3 id="悬垂引用（Dangling-References）"><a href="#悬垂引用（Dangling-References）" class="headerlink" title="悬垂引用（Dangling References）"></a><a target="_blank" rel="noopener" href="https://kaisery.github.io/trpl-zh-cn/ch04-02-references-and-borrowing.html#%E6%82%AC%E5%9E%82%E5%BC%95%E7%94%A8dangling-references">悬垂引用（Dangling References）</a></h3><p>在具有指针的语言中，很容易通过释放内存时保留指向它的指针而错误地生成一个<strong>悬垂指针</strong>（<em>dangling pointer</em>）—— 指向可能已被分配给其他用途的内存位置的指针。相比之下，在 Rust 中编译器确保引用永远也不会变成悬垂引用：当你拥有一些数据的引用，编译器确保数据不会在其引用之前离开作用域。</p>
<p>让我们尝试创建一个悬垂引用，看看 Rust 如何通过通过一个编译时错误来防止它：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">reference_to_nothing</span> = <span class="title function_ invoke__">dangle</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">dangle</span>() <span class="punctuation">-&gt;</span> &amp;<span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &amp;s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里是错误：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cargo run</span></span><br><span class="line">   Compiling ownership v0.1.0 (file:///projects/ownership)</span><br><span class="line">error[E0106]: missing lifetime specifier</span><br><span class="line"><span class="meta prompt_"> --&gt; </span><span class="language-bash">src/main.rs:5:16</span></span><br><span class="line">  |</span><br><span class="line">5 | fn dangle() -&gt; &amp;String &#123;</span><br><span class="line">  |                ^ expected named lifetime parameter</span><br><span class="line">  |</span><br><span class="line">  = help: this function&#x27;s return type contains a borrowed value, but there is no value for it to be borrowed from</span><br><span class="line">help: consider using the `&#x27;static` lifetime, but this is uncommon unless you&#x27;re returning a borrowed value from a `const` or a `static`</span><br><span class="line">  |</span><br><span class="line">5 | fn dangle() -&gt; &amp;&#x27;static String &#123;</span><br><span class="line">  |                 +++++++</span><br><span class="line">help: instead, you are more likely to want to return an owned value</span><br><span class="line">  |</span><br><span class="line">5 - fn dangle() -&gt; &amp;String &#123;</span><br><span class="line">5 + fn dangle() -&gt; String &#123;</span><br><span class="line">  |</span><br><span class="line"></span><br><span class="line">error[E0515]: cannot return reference to local variable `s`</span><br><span class="line"><span class="meta prompt_"> --&gt; </span><span class="language-bash">src/main.rs:8:5</span></span><br><span class="line">  |</span><br><span class="line">8 |     &amp;s</span><br><span class="line">  |     ^^ returns a reference to data owned by the current function</span><br><span class="line"></span><br><span class="line">Some errors have detailed explanations: E0106, E0515.</span><br><span class="line">For more information about an error, try `rustc --explain E0106`.</span><br><span class="line">error: could not compile `ownership` (bin &quot;ownership&quot;) due to 2 previous errors</span><br></pre></td></tr></table></figure>

<p>错误信息引用了一个我们还未介绍的功能：生命周期（lifetimes）。第十章会详细介绍生命周期。不过，如果你不理会生命周期部分，错误信息中确实包含了为什么这段代码有问题的关键信息：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">this function&#x27;s return type contains a borrowed value, but there is no value</span><br><span class="line">for it to be borrowed from</span><br></pre></td></tr></table></figure>

<p>让我们仔细看看我们的 <code>dangle</code> 代码的每个阶段到底发生了什么：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">dangle</span>() <span class="punctuation">-&gt;</span> &amp;<span class="type">String</span> &#123; <span class="comment">// dangle 返回一个字符串的引用</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>); <span class="comment">// s 是一个新字符串</span></span><br><span class="line"></span><br><span class="line">    &amp;s <span class="comment">// 返回字符串 s 的引用</span></span><br><span class="line">&#125; <span class="comment">// 这里 s 离开作用域并被丢弃。其内存被释放。</span></span><br><span class="line">  <span class="comment">// 危险！</span></span><br></pre></td></tr></table></figure>

<p>因为 <code>s</code> 是在 <code>dangle</code> 函数内创建的，当 <code>dangle</code> 的代码执行完毕后，<code>s</code> 将被释放。不过我们尝试返回它的引用。这意味着这个引用会指向一个无效的 <code>String</code>，这可不对！Rust 不会允许我们这么做。</p>
<p>这里的解决方法是直接返回 <code>String</code>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">no_dangle</span>() <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">    s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就没有任何错误了。所有权被移动出去，所以没有值被释放。</p>
<h3 id="引用的规则"><a href="#引用的规则" class="headerlink" title="引用的规则"></a><a target="_blank" rel="noopener" href="https://kaisery.github.io/trpl-zh-cn/ch04-02-references-and-borrowing.html#%E5%BC%95%E7%94%A8%E7%9A%84%E8%A7%84%E5%88%99">引用的规则</a></h3><p>让我们概括一下之前对引用的讨论：</p>
<ul>
<li>在任意给定时间，<strong>要么</strong>只能有一个可变引用，<strong>要么</strong>只能有多个不可变引用。</li>
<li>引用必须总是有效的。</li>
</ul>
<p>接下来，我们来看看另一种不同类型的引用：slice。</p>
<h2 id="Slice-类型"><a href="#Slice-类型" class="headerlink" title="Slice 类型"></a><a target="_blank" rel="noopener" href="https://kaisery.github.io/trpl-zh-cn/ch04-03-slices.html#slice-%E7%B1%BB%E5%9E%8B">Slice 类型</a></h2><p><strong>切片</strong>（<em>slice</em>）允许你引用集合中一段连续的元素序列，而不用引用整个集合。slice 是一种引用，所以它不拥有所有权。</p>
<p>这里有一个编程小习题：编写一个函数，该函数接收一个用空格分隔单词的字符串，并返回在该字符串中找到的第一个单词。如果函数在该字符串中并未找到空格，则整个字符串就是一个单词，所以应该返回整个字符串。</p>
<blockquote>
<p>注意：出于介绍字符串 slice 的目的，本小节假设只使用 ASCII 字符集；一个关于 UTF-8 处理的更全面的讨论位于第八章<a target="_blank" rel="noopener" href="https://kaisery.github.io/trpl-zh-cn/ch08-02-strings.html#%E4%BD%BF%E7%94%A8%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%82%A8%E5%AD%98-utf-8-%E7%BC%96%E7%A0%81%E7%9A%84%E6%96%87%E6%9C%AC">“使用字符串储存 UTF-8 编码的文本”</a>小节。</p>
</blockquote>
<p>让我们推敲下如何不用 slice 编写这个函数的签名，来理解 slice 能解决的问题：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">first_word</span>(s: &amp;<span class="type">String</span>) <span class="punctuation">-&gt;</span> ?</span><br></pre></td></tr></table></figure>

<p><code>first_word</code> 函数有一个参数 <code>&amp;String</code>。因为我们不需要所有权，所以这没有问题。不过应该返回什么呢？我们并没有一个真正获取<strong>部分</strong>字符串的办法。不过，我们可以返回单词结尾的索引，结尾由一个空格表示。试试如示例 4-7 中的代码。</p>
<p>文件名：src&#x2F;main.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">first_word</span>(s: &amp;<span class="type">String</span>) <span class="punctuation">-&gt;</span> <span class="type">usize</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">bytes</span> = s.<span class="title function_ invoke__">as_bytes</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i, &amp;item) <span class="keyword">in</span> bytes.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">enumerate</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> item == <span class="string">b&#x27; &#x27;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    s.<span class="title function_ invoke__">len</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例 4-7：<code>first_word</code> 函数返回 <code>String</code> 参数的一个字节索引值</p>
<p>因为需要逐个元素的检查 <code>String</code> 中的值是否为空格，需要用 <code>as_bytes</code> 方法将 <code>String</code> 转化为字节数组。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">bytes</span> = s.<span class="title function_ invoke__">as_bytes</span>();</span><br></pre></td></tr></table></figure>

<p>接下来，使用 <code>iter</code> 方法在字节数组上创建一个迭代器：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i, &amp;item) <span class="keyword">in</span> bytes.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">enumerate</span>() &#123;</span><br></pre></td></tr></table></figure>

<p>我们将在<a target="_blank" rel="noopener" href="https://kaisery.github.io/trpl-zh-cn/ch13-02-iterators.html">第十三章</a>详细讨论迭代器。现在，只需知道 <code>iter</code> 方法返回集合中的每一个元素，而 <code>enumerate</code> 包装了 <code>iter</code> 的结果，将这些元素作为元组的一部分来返回。<code>enumerate</code> 返回的元组中，第一个元素是索引，第二个元素是集合中元素的引用。这比我们自己计算索引要方便一些。</p>
<p>因为 <code>enumerate</code> 方法返回一个元组，我们可以使用模式来解构，我们将在<a target="_blank" rel="noopener" href="https://kaisery.github.io/trpl-zh-cn/ch06-02-match.html#%E7%BB%91%E5%AE%9A%E5%80%BC%E7%9A%84%E6%A8%A1%E5%BC%8F">第六章</a>中进一步讨论有关模式的问题。所以在 <code>for</code> 循环中，我们指定了一个模式，其中元组中的 <code>i</code> 是索引而元组中的 <code>&amp;item</code> 是单个字节。因为我们从 <code>.iter().enumerate()</code> 中获取了集合元素的引用，所以模式中使用了 <code>&amp;</code>。</p>
<p>在 <code>for</code> 循环中，我们通过字节的字面值语法来寻找代表空格的字节。如果找到了一个空格，返回它的位置。否则，使用 <code>s.len()</code> 返回字符串的长度。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> item == <span class="string">b&#x27; &#x27;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">s.<span class="title function_ invoke__">len</span>()</span><br></pre></td></tr></table></figure>

<p>现在有了一个找到字符串中第一个单词结尾索引的方法，不过这有一个问题。我们返回了一个独立的 <code>usize</code>，不过它只在 <code>&amp;String</code> 的上下文中才是一个有意义的数字。换句话说，因为它是一个与 <code>String</code> 相分离的值，无法保证将来它仍然有效。考虑一下示例 4-8 中使用了示例 4-7 中 <code>first_word</code> 函数的程序。</p>
<p>文件名：src&#x2F;main.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">word</span> = <span class="title function_ invoke__">first_word</span>(&amp;s); <span class="comment">// word 的值为 5</span></span><br><span class="line"></span><br><span class="line">    s.<span class="title function_ invoke__">clear</span>(); <span class="comment">// 这清空了字符串，使其等于 &quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// word 在此处的值仍然是 5，</span></span><br><span class="line">    <span class="comment">// 但是没有更多的字符串让我们可以有效地应用数值 5。word 的值现在完全无效！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例 4-8：存储 <code>first_word</code> 函数调用的返回值并接着改变 <code>String</code> 的内容</p>
<p>这个程序编译时没有任何错误，而且在调用 <code>s.clear()</code> 之后使用 <code>word</code> 也不会出错。因为 <code>word</code> 与 <code>s</code> 状态完全没有联系，所以 <code>word </code>仍然包含值 <code>5</code>。可以尝试用值 <code>5</code> 来提取变量 <code>s</code> 的第一个单词，不过这是有 bug 的，因为在我们将 <code>5</code> 保存到 <code>word</code> 之后 <code>s</code> 的内容已经改变。</p>
<p>我们不得不时刻担心 <code>word</code> 的索引与 <code>s</code> 中的数据不再同步，这既繁琐又易出错！如果编写这么一个 <code>second_word</code> 函数的话，管理索引这件事将更加容易出问题。它的签名看起来像这样：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">second_word</span>(s: &amp;<span class="type">String</span>) <span class="punctuation">-&gt;</span> (<span class="type">usize</span>, <span class="type">usize</span>) &#123;</span><br></pre></td></tr></table></figure>

<p>现在我们要跟踪一个开始索引<strong>和</strong>一个结束索引，同时有了更多从数据的某个特定状态计算而来的值，但都完全没有与这个状态相关联。现在有三个飘忽不定的不相关变量需要保持同步。</p>
<p>幸运的是，Rust 为这个问题提供了一个解决方法：字符串 slice。</p>
<h3 id="字符串-slice"><a href="#字符串-slice" class="headerlink" title="字符串 slice"></a><a target="_blank" rel="noopener" href="https://kaisery.github.io/trpl-zh-cn/ch04-03-slices.html#%E5%AD%97%E7%AC%A6%E4%B8%B2-slice">字符串 slice</a></h3><p><strong>字符串 slice</strong>（<em>string slice</em>）是 <code>String</code> 中一部分值的引用，它看起来像这样：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">hello</span> = &amp;s[<span class="number">0</span>..<span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">world</span> = &amp;s[<span class="number">6</span>..<span class="number">11</span>];</span><br></pre></td></tr></table></figure>

<p>不同于整个 <code>String</code> 的引用，<code>hello</code> 是一个部分 <code>String</code> 的引用，由一个额外的 <code>[0..5]</code> 部分指定。可以使用一个由中括号中的 <code>[starting_index..ending_index]</code> 指定的 range 创建一个 slice，其中 <code>starting_index</code> 是 slice 的第一个位置，<code>ending_index</code> 则是 slice 最后一个位置的后一个值。在其内部，slice 的数据结构存储了 slice 的开始位置和长度，长度对应于 <code>ending_index</code> 减去 <code>starting_index</code> 的值。所以对于 <code>let world = &amp;s[6..11];</code> 的情况，<code>world</code> 将是一个包含指向 <code>s</code> 索引 6 的指针和长度值 5 的 slice。</p>
<p>图 4-7 展示了一个图例。</p>
<p><img data-src="https://kaisery.github.io/trpl-zh-cn/img/trpl04-07.svg" alt="Three tables: a table representing the stack data of s, which points to the byte at index 0 in a table of the string data &quot;hello world&quot; on the heap. The third table rep-resents the stack data of the slice world, which has a length value of 5 and points to byte 6 of the heap data table."></p>
<p>图 4-7：引用了部分 <code>String</code> 的字符串 slice</p>
<p>对于 Rust 的 <code>..</code> range 语法，如果想要从索引 0 开始，可以不写两个点号之前的值。换句话说，如下两个语句是相同的：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">slice</span> = &amp;s[<span class="number">0</span>..<span class="number">2</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">slice</span> = &amp;s[..<span class="number">2</span>];</span><br></pre></td></tr></table></figure>

<p>依此类推，如果 slice 包含 <code>String</code> 的最后一个字节，也可以舍弃尾部的数字。这意味着如下也是相同的：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">len</span> = s.<span class="title function_ invoke__">len</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">slice</span> = &amp;s[<span class="number">3</span>..len];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">slice</span> = &amp;s[<span class="number">3</span>..];</span><br></pre></td></tr></table></figure>

<p>也可以同时舍弃这两个值来获取整个字符串的 slice。所以如下亦是相同的：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">len</span> = s.<span class="title function_ invoke__">len</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">slice</span> = &amp;s[<span class="number">0</span>..len];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">slice</span> = &amp;s[..];</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：字符串 slice range 的索引必须位于有效的 UTF-8 字符边界内，如果尝试从一个多字节字符的中间位置创建字符串 slice，则程序将会因错误而退出。</p>
</blockquote>
<p>在记住所有这些知识后，让我们重写 <code>first_word</code> 来返回一个 slice。“字符串 slice” 的类型声明写作 <code>&amp;str</code>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">first_word</span>(s: &amp;<span class="type">String</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">str</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">bytes</span> = s.<span class="title function_ invoke__">as_bytes</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i, &amp;item) <span class="keyword">in</span> bytes.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">enumerate</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> item == <span class="string">b&#x27; &#x27;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> &amp;s[<span class="number">0</span>..i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &amp;s[..]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们使用跟示例 4-7 相同的方式获取单词结尾的索引，通过寻找第一个出现的空格。当找到一个空格，我们返回一个字符串 slice，它使用字符串的开始和空格的索引作为开始和结束的索引。</p>
<p>现在当调用 <code>first_word</code> 时，会返回与底层数据关联的单个值。这个值由一个 slice 开始位置的引用和 slice 中元素的数量组成。</p>
<p><code>second_word</code> 函数也可以改为返回一个 slice：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">second_word</span>(s: &amp;<span class="type">String</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">str</span> &#123;</span><br></pre></td></tr></table></figure>

<p>现在我们有了一个不易混淆且直观的 API 了，因为编译器会确保指向 <code>String</code> 的引用持续有效。还记得示例 4-8 程序中，那个当我们获取第一个单词结尾的索引后，接着就清除了字符串导致索引就无效的 bug 吗？那些代码在逻辑上是不正确的，但却没有显示任何直接的错误。问题会在之后尝试对空字符串使用第一个单词的索引时出现。slice 就不可能出现这种 bug 并让我们更早的知道出问题了。使用 slice 版本的 <code>first_word</code> 会抛出一个编译时错误：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">word</span> = <span class="title function_ invoke__">first_word</span>(&amp;s);</span><br><span class="line"></span><br><span class="line">    s.<span class="title function_ invoke__">clear</span>(); <span class="comment">// 错误！</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;the first word is: &#123;word&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里是编译错误：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cargo run</span></span><br><span class="line">   Compiling ownership v0.1.0 (file:///projects/ownership)</span><br><span class="line">error[E0502]: cannot borrow `s` as mutable because it is also borrowed as immutable</span><br><span class="line"><span class="meta prompt_">  --&gt; </span><span class="language-bash">src/main.rs:18:5</span></span><br><span class="line">   |</span><br><span class="line">16 |     let word = first_word(&amp;s);</span><br><span class="line">   |                           -- immutable borrow occurs here</span><br><span class="line">17 |</span><br><span class="line">18 |     s.clear(); // error!</span><br><span class="line">   |     ^^^^^^^^^ mutable borrow occurs here</span><br><span class="line">19 |</span><br><span class="line">20 |     println!(&quot;the first word is: &#123;word&#125;&quot;);</span><br><span class="line">   |                                  ------ immutable borrow later used here</span><br><span class="line"></span><br><span class="line">For more information about this error, try `rustc --explain E0502`.</span><br><span class="line">error: could not compile `ownership` (bin &quot;ownership&quot;) due to 1 previous error</span><br></pre></td></tr></table></figure>

<p>回忆一下借用规则，当拥有某值的不可变引用时，就不能再获取一个可变引用。因为 <code>clear</code> 需要清空 <code>String</code>，它尝试获取一个可变引用。在调用 <code>clear</code> 之后的 <code>println!</code> 使用了 <code>word</code> 中的引用，所以这个不可变的引用在此时必须仍然有效。Rust 不允许 <code>clear</code> 中的可变引用和 <code>word</code> 中的不可变引用同时存在，因此编译失败。Rust 不仅使得我们的 API 简单易用，也在编译时就消除了一整类的错误！</p>
<h4 id="字符串字面值就是-slice"><a href="#字符串字面值就是-slice" class="headerlink" title="字符串字面值就是 slice"></a><a target="_blank" rel="noopener" href="https://kaisery.github.io/trpl-zh-cn/ch04-03-slices.html#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AD%97%E9%9D%A2%E5%80%BC%E5%B0%B1%E6%98%AF-slice">字符串字面值就是 slice</a></h4><p>还记得我们讲到过字符串字面值被储存在二进制文件中吗？现在知道 slice 了，我们就可以正确地理解字符串字面值了：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="string">&quot;Hello, world!&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>这里 <code>s</code> 的类型是 <code>&amp;str</code>：它是一个指向二进制程序特定位置的 slice。这也就是为什么字符串字面值是不可变的；<code>&amp;str</code> 是一个不可变引用。</p>
<h4 id="字符串-slice-作为参数"><a href="#字符串-slice-作为参数" class="headerlink" title="字符串 slice 作为参数"></a><a target="_blank" rel="noopener" href="https://kaisery.github.io/trpl-zh-cn/ch04-03-slices.html#%E5%AD%97%E7%AC%A6%E4%B8%B2-slice-%E4%BD%9C%E4%B8%BA%E5%8F%82%E6%95%B0">字符串 slice 作为参数</a></h4><p>在知道了能够获取字面值和 <code>String</code> 的 slice 后，我们对 <code>first_word</code> 做了改进，这是它的签名：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">first_word</span>(s: &amp;<span class="type">String</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">str</span> &#123;</span><br></pre></td></tr></table></figure>

<p>而更有经验的 Rustacean 会编写出示例 4-9 中的签名，因为它使得可以对 <code>&amp;String</code> 值和 <code>&amp;str</code> 值使用相同的函数：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">first_word</span>(s: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">str</span> &#123;</span><br></pre></td></tr></table></figure>

<p>示例 4-9: 通过将 <code>s</code> 参数的类型改为字符串 slice 来改进 <code>first_word</code> 函数</p>
<p>如果有一个字符串 slice，可以直接传递它。如果有一个 <code>String</code>，则可以传递整个 <code>String</code> 的 slice 或对 <code>String</code> 的引用。这种灵活性利用了 <em>deref coercions</em> 的优势，这个特性我们将在<a target="_blank" rel="noopener" href="https://kaisery.github.io/trpl-zh-cn/ch15-02-deref.html#%E5%87%BD%E6%95%B0%E5%92%8C%E6%96%B9%E6%B3%95%E7%9A%84%E9%9A%90%E5%BC%8F-deref-%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2">“函数和方法的隐式 Deref 强制转换”</a>章节中介绍。定义一个获取字符串 slice 而不是 <code>String</code> 引用的函数使得我们的 API 更加通用并且不会丢失任何功能：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">my_string</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// `first_word` 适用于 `String`（的 slice），部分或全部</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">word</span> = <span class="title function_ invoke__">first_word</span>(&amp;my_string[<span class="number">0</span>..<span class="number">6</span>]);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">word</span> = <span class="title function_ invoke__">first_word</span>(&amp;my_string[..]);</span><br><span class="line">    <span class="comment">// `first_word` 也适用于 `String` 的引用，</span></span><br><span class="line">    <span class="comment">// 这等价于整个 `String` 的 slice</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">word</span> = <span class="title function_ invoke__">first_word</span>(&amp;my_string);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">my_string_literal</span> = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// `first_word` 适用于字符串字面值，部分或全部</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">word</span> = <span class="title function_ invoke__">first_word</span>(&amp;my_string_literal[<span class="number">0</span>..<span class="number">6</span>]);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">word</span> = <span class="title function_ invoke__">first_word</span>(&amp;my_string_literal[..]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 因为字符串字面值已经 **是** 字符串 slice 了，</span></span><br><span class="line">    <span class="comment">// 这也是适用的，无需 slice 语法！</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">word</span> = <span class="title function_ invoke__">first_word</span>(my_string_literal);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="其他类型的-slice"><a href="#其他类型的-slice" class="headerlink" title="其他类型的 slice"></a><a target="_blank" rel="noopener" href="https://kaisery.github.io/trpl-zh-cn/ch04-03-slices.html#%E5%85%B6%E4%BB%96%E7%B1%BB%E5%9E%8B%E7%9A%84-slice">其他类型的 slice</a></h3><p>字符串 slice，正如你想象的那样，是针对字符串的。不过也有更通用的 slice 类型。考虑一下这个数组：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">a</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br></pre></td></tr></table></figure>

<p>就跟我们想要获取字符串的一部分那样，我们也会想要引用数组的一部分。我们可以这样做：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">a</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">slice</span> = &amp;a[<span class="number">1</span>..<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">assert_eq!</span>(slice, &amp;[<span class="number">2</span>, <span class="number">3</span>]);</span><br></pre></td></tr></table></figure>

<p>这个 slice 的类型是 <code>&amp;[i32]</code>。它跟字符串 slice 的工作方式一样，通过存储第一个集合元素的引用和一个集合总长度。你可以对其他所有集合使用这类 slice。第八章讲到 vector 时会详细讨论这些集合。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/07/17/RUST%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.png">
      <meta itemprop="name" content="Chillward">
      <meta itemprop="description" content="谁躺在漆黑的舞台上，用身体迎接着光芒">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chillward的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/07/17/RUST%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/" class="post-title-link" itemprop="url">RUST学习日记之数据类型</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-07-17 23:17:40" itemprop="dateCreated datePublished" datetime="2025-07-17T23:17:40+08:00">2025-07-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-07-20 15:56:32" itemprop="dateModified" datetime="2025-07-20T15:56:32+08:00">2025-07-20</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>12k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>23 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="变量的声明"><a href="#变量的声明" class="headerlink" title="变量的声明"></a>变量的声明</h3><p>rust的变量分为可变变量与不可变变量，声明变量使用<strong>let</strong>关键字，类型可以不显式声明，可变变量用<strong>mut</strong>关键字。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">x</span>:<span class="type">i32</span> = <span class="number">42</span>; <span class="comment">//显式告知编译器变量类型</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">guess</span> = <span class="number">42</span>; <span class="comment">// 编译器推断 guess 是 i32 类型</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">pi</span> = <span class="number">3.14</span>;   <span class="comment">// 编译器推断 pi 是 f64 类型</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">active</span> = <span class="literal">true</span>; <span class="comment">// 编译器推断 active 是 bool 类型</span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">y</span> = <span class="number">10</span>; <span class="comment">// 声明一个可变变量 y 并赋值为 10</span></span><br></pre></td></tr></table></figure>

<h3 id="变量的遮蔽"><a href="#变量的遮蔽" class="headerlink" title="变量的遮蔽"></a>变量的遮蔽</h3><p>在 Rust 中，<strong>变量遮蔽</strong>指的是你可以声明一个与之前变量同名的新变量。这个新变量会“遮盖”（或“隐藏”）之前声明的同名变量，使得在当前作用域内，对这个名字的引用会指向新的变量，而不是旧的。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>; <span class="comment">// 第一次声明 x</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The initial value of x is: &#123;&#125;&quot;</span>, x); <span class="comment">// 输出 5</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = x + <span class="number">1</span>; <span class="comment">// 第二次声明 x，它遮蔽了之前的 x</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The new value of x is: &#123;&#125;&quot;</span>, x);     <span class="comment">// 输出 6</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = x * <span class="number">2</span>; <span class="comment">// 第三次声明 x，再次遮蔽</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The final value of x is: &#123;&#125;&quot;</span>, x);   <span class="comment">// 输出 12</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>乍一看，变量遮蔽可能与使用 <code>mut</code> 关键字的可变变量（Mutable Variables）有些相似，但它们之间存在根本的区别：</p>
<ol>
<li><p><strong>内存位置</strong>：</p>
<ul>
<li><strong>可变变量 (<code>let mut</code>)</strong>：修改的是<strong>同一个内存位置</strong>的值。当你说 <code>let mut x = 5; x = 6;</code> 时，<code>x</code> 的值从 5 变成了 6，存储 <code>x</code> 的那块内存区域中的内容发生了变化。</li>
<li><strong>变量遮蔽 (<code>let</code>)</strong>：是<strong>创建了一个全新的变量</strong>。每次你使用 <code>let</code> 关键字并带上一个已有的变量名时，Rust 实际上是在内存中分配了一个新的空间来存储新变量的值，而不是修改旧变量的值。旧变量可能仍然存在于内存中，只是你无法通过它的名字访问它了。</li>
</ul>
</li>
<li><p><strong>类型改变</strong>：</p>
<ul>
<li><strong>可变变量 (<code>let mut</code>)</strong>：不能改变变量的类型。如果 <code>x</code> 最初是 <code>i32</code>，那么它永远是 <code>i32</code>。</li>
<li><strong>变量遮蔽 (<code>let</code>)</strong>：可以改变变量的类型。这是遮蔽的一个强大之处，也是它与可变变量最明显的区别之一。</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">spaces</span> = <span class="string">&quot;   &quot;</span>; <span class="comment">// spaces 是一个 &amp;str 类型</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Type of spaces (string): &#123;:?&#125;&quot;</span>, spaces);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">spaces</span> = spaces.<span class="title function_ invoke__">len</span>(); <span class="comment">// 新的 spaces 是一个 usize 类型，旧的 &amp;str 被遮蔽了</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Type of spaces (number): &#123;:?&#125;&quot;</span>, spaces);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>变量遮蔽在 Rust 中被视为一个有用的特性，主要有以下几个原因：</p>
<ol>
<li><strong>类型转换或数据转换</strong>：当你需要对一个变量进行转换操作（例如从字符串解析数字，或者进行某种计算），并希望用同一个有意义的变量名来表示转换后的结果时，遮蔽非常方便。这样可以避免创建 <code>x_str</code>、<code>x_int</code> 这样一系列冗余的变量名。</li>
<li><strong>避免意外修改</strong>：因为遮蔽是创建新变量，而不是修改旧变量，所以它强制你重新使用 <code>let</code> 关键字。这有助于避免无意中修改了某个远处的变量，因为你需要明确地重新声明它。</li>
<li><strong>提高可读性</strong>：在某些情况下，使用相同的变量名可以使代码更具可读性，因为它清楚地表明你正在处理同一个逻辑概念的不同“阶段”或“表示”。</li>
</ol>
<p>变量遮蔽只在当前作用域内有效。当代码块结束时，被遮蔽的变量（如果它仍然在作用域内）可能会重新变得可见，或者新的遮蔽变量会消失。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>); <span class="comment">// s1</span></span><br><span class="line"></span><br><span class="line">    &#123; <span class="comment">// 这是一个新的内部作用域</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;world&quot;</span>); <span class="comment">// s2，遮蔽了外部的 s1</span></span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Inside inner scope: &#123;&#125;&quot;</span>, s); <span class="comment">// 输出 &quot;world&quot;</span></span><br><span class="line">    &#125; <span class="comment">// 内部作用域结束，s2 被丢弃</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Outside inner scope: &#123;&#125;&quot;</span>, s); <span class="comment">// 输出 &quot;hello&quot; (s1 重新可见)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h1><p>rust中基本数据类型包括以下几种</p>
<ol>
<li>整形(u32、i32)</li>
<li>浮点型(f32,f64)</li>
<li>布尔型(bool)</li>
<li>字符型(char)</li>
</ol>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span>:<span class="type">i32</span> = <span class="number">42</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span>:<span class="type">u64</span> = <span class="number">200</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">pi</span>:<span class="type">f64</span> = <span class="number">3.14159</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">is_snowing</span>: <span class="type">bool</span> = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>跟C语言没什么大区别，就不详细说了</p>
<hr>
<h1 id="复合数据类型"><a href="#复合数据类型" class="headerlink" title="复合数据类型"></a>复合数据类型</h1><p><strong>复合类型</strong>（<em>Compound types</em>）可以将多个值组合成一个类型。Rust 有两个原生的复合类型：元组（tuple）和数组（array）。</p>
<h4 id="元组-tuple"><a href="#元组-tuple" class="headerlink" title="元组(tuple):"></a>元组(tuple):</h4><p>元组是一个将多个不同类型的值组合进一个复合类型的主要方式。元组长度固定：一旦声明，其长度不会增大或缩小。</p>
<p>我们使用包含在圆括号中的逗号分隔的值列表来创建一个元组。元组中的每一个位置都有一个类型，而且这些不同值的类型也不必是相同的。这个例子中使用了<strong>可选</strong>的类型注解：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">tup</span>: (<span class="type">i32</span>, <span class="type">f64</span>, <span class="type">u8</span>) = (<span class="number">500</span>, <span class="number">6.4</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>tup</code> 变量绑定到整个元组上，因为元组是一个单独的复合元素。为了从元组中获取单个值，可以使用模式匹配（pattern matching）来解构（destructure）元组值，像这样：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">tup</span> = (<span class="number">500</span>, <span class="number">6.4</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> (x, y, z) = tup;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The value of y is: &#123;y&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序首先创建了一个元组并绑定到 <code>tup</code> 变量上。接着使用了 <code>let</code> 和一个模式将 <code>tup</code> 分成了三个不同的变量，<code>x</code>、<code>y</code> 和 <code>z</code>。这叫做 <strong>解构</strong>（<em>destructuring</em>），因为它将一个元组拆成了三个部分。最后，程序打印出了 <code>y</code> 的值，也就是 <code>6.4</code>。</p>
<p>我们也可以使用点号（<code>.</code>）后跟值的索引来直接访问所需的元组元素。例如：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span>: (<span class="type">i32</span>, <span class="type">f64</span>, <span class="type">u8</span>) = (<span class="number">500</span>, <span class="number">6.4</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">five_hundred</span> = x.<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">six_point_four</span> = x.<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">one</span> = x.<span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个程序创建了一个元组，<code>x</code>，然后使用其各自的索引访问元组中的每个元素。跟大多数编程语言一样，元组的第一个索引值是 0。</p>
<p>不带任何值的元组有个特殊的名称，叫做 <strong>单元（unit）</strong> 元组。这种值以及对应的类型都写作 <code>()</code>，表示空值或空的返回类型。如果表达式不返回任何其他值，则会隐式返回单元值。</p>
<h4 id="数组-array"><a href="#数组-array" class="headerlink" title="数组(array):"></a>数组(array):</h4><p>另一个包含多个值的方式是 <strong>数组</strong>（<em>array</em>）。与元组不同，数组中的每个元素的类型必须相同。Rust 中的数组与一些其他语言中的数组不同，Rust 中的数组长度是固定的。</p>
<p>我们将数组的值写成在方括号内，用逗号分隔的列表：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">numbers</span>:[<span class="type">i32</span>;<span class="number">5</span>] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当你想要在栈（stack）而不是在堆（heap）上为数据分配空间，或者是想要确保总是有固定数量的元素时，数组非常有用。但是数组并不如 vector 类型灵活。vector 类型是标准库提供的一个 <strong>允许</strong> 增长和缩小长度的类似数组的集合类型。当不确定是应该使用数组还是 vector 的时候，那么很可能应该使用 vector。</p>
<p>然而，当你确定元素个数不会改变时，数组会更有用。例如，当你在一个程序中使用月份名字时，你更应趋向于使用数组而不是 vector，因为你确定只会有 12 个元素。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">months</span> = [<span class="string">&quot;January&quot;</span>, <span class="string">&quot;February&quot;</span>, <span class="string">&quot;March&quot;</span>, <span class="string">&quot;April&quot;</span>, <span class="string">&quot;May&quot;</span>, <span class="string">&quot;June&quot;</span>, <span class="string">&quot;July&quot;</span>,</span><br><span class="line">              <span class="string">&quot;August&quot;</span>, <span class="string">&quot;September&quot;</span>, <span class="string">&quot;October&quot;</span>, <span class="string">&quot;November&quot;</span>, <span class="string">&quot;December&quot;</span>];</span><br></pre></td></tr></table></figure>

<p>可以像这样编写数组的类型：在方括号中包含每个元素的类型，后跟分号，再后跟数组元素的数量。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">a</span>: [<span class="type">i32</span>; <span class="number">5</span>] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br></pre></td></tr></table></figure>

<p>这里，<code>i32</code> 是每个元素的类型。分号之后，数字 <code>5</code> 表明该数组包含五个元素。</p>
<p>你还可以通过在方括号中指定初始值加分号再加元素个数的方式来创建一个每个元素都为相同值的数组：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">a</span> = [<span class="number">3</span>; <span class="number">5</span>];</span><br></pre></td></tr></table></figure>

<p>变量名为 <code>a</code> 的数组将包含 <code>5</code> 个元素，这些元素的值最初都将被设置为 <code>3</code>。这种写法与 <code>let a = [3, 3, 3, 3, 3];</code> 效果相同，但更简洁。</p>
<p>数组是可以在栈 (stack) 上分配的已知固定大小的单个内存块。可以使用索引来访问数组的元素，像这样：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">first</span> = a[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">second</span> = a[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，叫做 <code>first</code> 的变量的值是 <code>1</code>，因为它是数组索引 <code>[0]</code> 的值。变量 <code>second</code> 将会是数组索引 <code>[1]</code> 的值 <code>2</code>。</p>
<hr>
<h3 id="引用类型与切片-slices"><a href="#引用类型与切片-slices" class="headerlink" title="引用类型与切片(slices)"></a>引用类型与切片(slices)</h3><p>引用类型分为可变引用以及不可变引用。</p>
<p>可变引用可以理解为一种更加安全的指针。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>); <span class="comment">// 原始变量必须是可变的</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// s 的可变引用被传递给 change 函数</span></span><br><span class="line">    <span class="title function_ invoke__">change</span>(&amp;<span class="keyword">mut</span> s);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, s); <span class="comment">// 输出 &quot;hello, world&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个函数接收一个 String 的可变引用</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">change</span>(some_string: &amp;<span class="keyword">mut</span> <span class="type">String</span>) &#123;</span><br><span class="line">    some_string.<span class="title function_ invoke__">push_str</span>(<span class="string">&quot;, world&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>不可变引用可以理解为类似于C语言中<code>const int *</code> 的类型，可以通过指针访问引用的值，但是不能修改。注意引用的对象是可以发生改变的</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span> = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">r</span> = &amp;a; <span class="comment">// r 引用 a</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;r points to a: &#123;&#125;&quot;</span>, r); <span class="comment">// 输出 10</span></span><br><span class="line"></span><br><span class="line">    r = &amp;b; <span class="comment">// 重新绑定 r，让它引用 b</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;r now points to b: &#123;&#125;&quot;</span>, r); <span class="comment">// 输出 20</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Rust 的<strong>借用检查器（borrow checker）</strong> 是一个在编译时运行的工具，它会严格执行以下引用规则，确保内存安全：</p>
<ol>
<li><strong>没有空引用：</strong> Rust 的引用保证总是指向有效的数据。你无法创建空引用，这避免了其他语言中常见的空指针解引用错误。</li>
<li><strong>没有悬垂引用：</strong> 引用指向的数据在其生命周期内必须始终有效。借用检查器会确保你不会引用一块已经被释放的内存。</li>
<li><strong>读写互斥规则：</strong> 这是最关键的规则，它防止了数据竞争（data races）：<ul>
<li>在任何给定时间，你只能拥有<strong>一个可变引用</strong> (<code>&amp;mut T</code>)。这意味着当数据被修改时，不能有其他任何引用（无论是可变还是不可变）指向它。</li>
<li>你可以拥有<strong>任意数量的不可变引用</strong> (<code>&amp;T</code>)。这意味着数据可以被多次同时读取。</li>
<li>但是，当存在不可变引用时，就不能有任何可变引用。</li>
</ul>
</li>
</ol>
<p><strong>切片</strong>是 Rust 中一种特殊的引用类型，它允许你引用集合（如数组、<code>Vec</code> 或 <code>String</code>）中<strong>连续、特定范围的元素序列</strong>。切片本身也是一种引用，不拥有数据。可以类比为指向数组的更安全的指针。</p>
<ul>
<li><p><strong>泛型切片</strong> (<code>&amp;[T]</code>)：用于引用数组或 <code>Vec</code> 的部分或全部。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">numbers</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">middle</span> = &amp;numbers[<span class="number">1</span>..<span class="number">4</span>]; <span class="comment">// middle 是 &amp;[i32]，引用 [2, 3, 4]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>字符串切片</strong> (<code>&amp;str</code>)：用于引用 <code>String</code> 的部分或全部，或直接表示字符串字面量。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">word</span> = &amp;s[<span class="number">0</span>..<span class="number">5</span>]; <span class="comment">// word 是 &amp;str，引用 &quot;hello&quot;</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">literal</span> = <span class="string">&quot;Rust is great&quot;</span>; <span class="comment">// 字符串字面量本身就是 &amp;str</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h1 id="String与String-slices"><a href="#String与String-slices" class="headerlink" title="String与String slices"></a>String与String slices</h1><p>在rust中 String是一个结构体，是封装好的可进行修改的字符串。</p>
<p>String slices是字符串切片，无法修改，即不可变引用。</p>
<p><code>&amp;mut String</code> 和字符串切片 (<code>&amp;str</code>) 之间存在一种非常重要的关系，但它们是两个截然不同且用途互补的概念。</p>
<h2 id="1-mut-String：可变且拥有数据的引用"><a href="#1-mut-String：可变且拥有数据的引用" class="headerlink" title="1. &amp;mut String：可变且拥有数据的引用"></a>1. <code>&amp;mut String</code>：可变且拥有数据的引用</h2><p><code>&amp;mut String</code> 是对一个 <strong><code>String</code> 类型变量的可变引用</strong>。</p>
<ul>
<li><strong>所有权和可变性：</strong><ul>
<li><code>String</code> 类型本身是<strong>拥有数据</strong>的，并且其内容是<strong>可变</strong>的（存储在堆上，可以增长、收缩和修改）。</li>
<li><code>&amp;mut String</code> 允许你通过这个引用来<strong>修改原始的 <code>String</code> 数据</strong>。</li>
</ul>
</li>
<li><strong>用途：</strong> 当你需要在函数内部改变一个 <code>String</code> 变量的内容，但又不希望函数获取这个 <code>String</code> 的所有权时，你会传递 <code>&amp;mut String</code>。</li>
<li><strong>独占性：</strong> 遵循 Rust 的借用规则，当一个 <code>&amp;mut String</code> 存在时，不能有其他任何引用（无论是 <code>&amp;mut String</code> 还是 <code>&amp;String</code>）指向同一个 <code>String</code> 实例。这保证了数据在修改时的唯一访问，从而防止了数据竞争。</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">modify_my_string</span>(s: &amp;<span class="keyword">mut</span> <span class="type">String</span>) &#123;</span><br><span class="line">    s.<span class="title function_ invoke__">push_str</span>(<span class="string">&quot; world!&quot;</span>); <span class="comment">// 通过可变引用修改原始 String</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">my_string</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"><span class="title function_ invoke__">modify_my_string</span>(&amp;<span class="keyword">mut</span> my_string); <span class="comment">// 传递可变引用</span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, my_string); <span class="comment">// Output: Hello world!</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="2-字符串切片-str-：不可变且不拥有数据的引用"><a href="#2-字符串切片-str-：不可变且不拥有数据的引用" class="headerlink" title="2. 字符串切片 (&amp;str)：不可变且不拥有数据的引用"></a>2. 字符串切片 (<code>&amp;str</code>)：不可变且不拥有数据的引用</h2><p><code>&amp;str</code>（字符串切片）是对一个 <strong>UTF-8 编码的字符串数据段的不可变引用</strong>。</p>
<ul>
<li><strong>所有权和不可变性：</strong><ul>
<li><code>&amp;str</code> <strong>不拥有数据</strong>；它只是“借用”了另一段内存中的字符串数据。</li>
<li><code>&amp;str</code> 自身是<strong>不可变</strong>的。你不能通过 <code>&amp;str</code> 来修改它所引用的字符串内容。</li>
</ul>
</li>
<li><strong>来源：</strong> <code>&amp;str</code> 可以来自多种地方：<ul>
<li>字符串字面量（<code>&quot;hello&quot;</code>）本身就是 <code>&amp;&#39;static str</code> 类型。</li>
<li><code>String</code> 类型可以通过 <code>&amp;my_string[..]</code> 或 <code>&amp;my_string</code> 自动强制转换（deref coercion）为 <code>&amp;str</code>。</li>
</ul>
</li>
<li><strong>用途：</strong> 当你只需要读取字符串内容，或函数需要接受任何形式的字符串（无论是 <code>String</code> 还是字符串字面量）作为参数时，通常会使用 <code>&amp;str</code>。</li>
<li><strong>共享性：</strong> 由于是不可变的，你可以创建多个 <code>&amp;str</code> 引用指向同一段数据。</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">print_my_string</span>(s: &amp;<span class="type">str</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, s); <span class="comment">// 只能读取，不能修改</span></span><br><span class="line">    <span class="comment">// s.push_str(&quot;!&quot;); // 错误！&amp;str 是不可变的</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">my_string</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Rust&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">literal_string</span>: &amp;<span class="type">str</span> = <span class="string">&quot;Programming&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">print_my_string</span>(&amp;my_string);       <span class="comment">// 将 String 借用为 &amp;str</span></span><br><span class="line"><span class="title function_ invoke__">print_my_string</span>(literal_string);   <span class="comment">// 直接使用字符串字面量</span></span><br><span class="line"><span class="title function_ invoke__">print_my_string</span>(&amp;my_string[<span class="number">0</span>..<span class="number">2</span>]); <span class="comment">// 借用 String 的一部分作为 &amp;str</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="它们之间的关系和区别总结"><a href="#它们之间的关系和区别总结" class="headerlink" title="它们之间的关系和区别总结"></a>它们之间的关系和区别总结</h2><table>
<thead>
<tr>
<th>特性</th>
<th><code>&amp;mut String</code></th>
<th><code>&amp;str</code></th>
</tr>
</thead>
<tbody><tr>
<td><strong>所有权</strong></td>
<td>不拥有数据，是对 <strong><code>String</code></strong> 的<strong>借用</strong></td>
<td>不拥有数据，是对 <strong>UTF-8 字符串数据</strong> 的<strong>借用</strong></td>
</tr>
<tr>
<td><strong>可变性</strong></td>
<td><strong>可变</strong>：允许通过引用修改原始 <code>String</code> 的内容</td>
<td><strong>不可变</strong>：不允许通过引用修改所引用的字符串内容</td>
</tr>
<tr>
<td><strong>指向目标</strong></td>
<td>总是指向一个完整的 <code>String</code> 实例</td>
<td>可以指向 <code>String</code> 的一部分，也可以是整个 <code>String</code>，或者是字符串字面量</td>
</tr>
<tr>
<td><strong>独占性</strong></td>
<td><strong>独占</strong>：同一时间只能有一个 <code>&amp;mut String</code> 存在</td>
<td><strong>共享</strong>：可以同时存在多个 <code>&amp;str</code> 引用</td>
</tr>
<tr>
<td><strong>用途</strong></td>
<td>需要在函数中修改 <code>String</code> 的场景</td>
<td>需要读取字符串数据，或作为通用字符串参数的场景</td>
</tr>
</tbody></table>
<hr>
<p>简而言之：</p>
<ul>
<li><code>&amp;mut String</code> 是你想要<strong>修改</strong>一个<strong>堆上可变字符串</strong>时用的。它就像给函数一个“写权限”去操作原始的 <code>String</code>。</li>
<li><code>&amp;str</code> 是你想要<strong>读取</strong>一个**字符串（无论来自哪里）**时用的。它就像给函数一个“只读视图”。</li>
</ul>
<p><code>&amp;str</code> 是更通用的字符串视图类型，因为它既可以引用 <code>String</code> 的内容，也可以引用字符串字面量。而 <code>&amp;mut String</code> 明确表示你正在操作一个底层的 <code>String</code> 对象，并且你有权修改它。</p>
<hr>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">book_slices</span>:&amp;[&amp;<span class="type">String</span>] = &amp;[&amp;<span class="string">&quot;JVAV&quot;</span>.<span class="title function_ invoke__">to_string</span>(),&amp;<span class="string">&quot;IT&quot;</span>.<span class="title function_ invoke__">to_string</span>(),&amp;<span class="string">&quot;ZEN&quot;</span>.<span class="title function_ invoke__">to_string</span>()];</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;Book_Slices:&#123;:?&#125;&quot;</span>,book_slices);</span><br><span class="line"></span><br><span class="line"><span class="comment">//String Vs String Slices(&amp;str)</span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">stone_cold</span>:<span class="type">String</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hell,&quot;</span>);</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;Stone Cold Says:&#123;&#125;&quot;</span>,stone_cold);</span><br><span class="line">stone_cold.<span class="title function_ invoke__">push_str</span>(<span class="string">&quot;Yeah!&quot;</span>);</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;Stone Cold Says:&#123;&#125;&quot;</span>,stone_cold);</span><br><span class="line"></span><br><span class="line"><span class="comment">//B- &amp;str(String Slice)</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">string</span>: <span class="type">String</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello,World&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">slice</span>: &amp;<span class="type">str</span> = &amp;string[<span class="number">0</span>..<span class="number">5</span>];</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;Slice Value:&#123;&#125;&quot;</span>,slice);</span><br></pre></td></tr></table></figure>

<p><code>let book_slices:&amp;[&amp;String] = &amp;[&amp;&quot;JVAV&quot;.to_string(),&amp;&quot;IT&quot;.to_string(),&amp;&quot;ZEN&quot;.to_string()];</code></p>
<p>是一个是一个指向 <code>&amp;String</code> 类型数组的切片</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">book_slices</span>: &amp;[&amp;<span class="type">String</span>] = &amp;[&amp;<span class="string">&quot;JVAV&quot;</span>.<span class="title function_ invoke__">to_string</span>(),&amp;<span class="string">&quot;IT&quot;</span>.<span class="title function_ invoke__">to_string</span>(),&amp;<span class="string">&quot;ZEN&quot;</span>.<span class="title function_ invoke__">to_string</span>()];</span><br></pre></td></tr></table></figure>

<ol>
<li><strong><code>&quot;JVAV&quot;.to_string()</code></strong><ul>
<li>这一步创建了一个<strong>拥有所有权</strong>的 <strong><code>String</code></strong> 类型实例，存储在堆上。</li>
</ul>
</li>
<li><strong><code>&amp;&quot;JVAV&quot;.to_string()</code></strong><ul>
<li>这一步从上面创建的 <code>String</code> 实例中，获取了一个<strong>不可变引用</strong>。这个引用的类型是 <strong><code>&amp;String</code></strong>。</li>
</ul>
</li>
<li><strong><code>[&amp; ... , &amp; ... , &amp; ...]</code></strong><ul>
<li>这是一个<strong>数组字面量</strong>，它在编译时被创建。这个数组的元素类型，就是它里面包含的那些引用的类型，即 <strong><code>&amp;String</code></strong>。所以，这是一个 <code>[&amp;String; 3]</code> 类型的数组。</li>
</ul>
</li>
<li><strong><code>&amp;[&amp;String; 3]</code></strong><ul>
<li>最外层的 <code>&amp;</code> 运算符，是获取这个<strong>数组的引用</strong>。</li>
<li>这个引用（<code>&amp;</code> 后面的部分）的类型就是 <code>[&amp;String; 3]</code>。</li>
</ul>
</li>
<li><strong><code>let book_slices: &amp;[&amp;String]</code></strong><ul>
<li>最后，<code>book_slices</code> 被明确地类型标注为 <strong><code>&amp;[&amp;String]</code></strong>。这是一个<strong>切片</strong>，它指向的底层数组的元素类型是 <code>&amp;String</code>。</li>
</ul>
</li>
</ol>
<hr>
<h2 id="关键点：没有发生-Deref-Coercion"><a href="#关键点：没有发生-Deref-Coercion" class="headerlink" title="关键点：没有发生 Deref Coercion"></a>关键点：没有发生 Deref Coercion</h2><p>虽然 Rust 有 <strong>Deref Coercion（解引用强制转换）</strong> 的机制，允许 <code>&amp;String</code> 在需要 <code>&amp;str</code> 的地方自动转换。但是，这种转换发生在<strong>单个引用层面</strong>，而不会改变<strong>数组或切片中元素的实际类型</strong>。</p>
<p>在这个特定的例子中：</p>
<ul>
<li>你明确地构建了一个包含 <code>&amp;String</code> 引用的数组：<code>[&amp;some_string_ref_1, &amp;some_string_ref_2]</code>。</li>
<li>这个数组的类型就是 <code>[&amp;String; N]</code>。</li>
<li>你从这个数组创建的切片，其类型也必须与其元素的实际类型匹配，即 <code>&amp;[&amp;String]</code>。</li>
</ul>
<p>如果 Rust 允许 <code>&amp;[&amp;String]</code> 自动强制转换为 <code>&amp;[&amp;str]</code>，那将意味着它需要修改切片中<strong>每个元素的类型</strong>，这是 Deref Coercion 不会做的事情。Deref Coercion 是一个<strong>单个引用到单个引用</strong>的转换，而不是一个集合到另一个集合的转换。</p>
<hr>
<h2 id="例子：当你确实想要-str-时"><a href="#例子：当你确实想要-str-时" class="headerlink" title="例子：当你确实想要 &amp;[&amp;str] 时"></a>例子：当你确实想要 <code>&amp;[&amp;str]</code> 时</h2><p>如果你真的想拥有一个 <code>&amp;str</code> 切片（即 <code>&amp;[&amp;str]</code>），你需要这样构建它：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// 方式一：直接使用字符串字面量（它们本身就是 &amp;str）</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">book_str_slices_1</span>: &amp;[&amp;<span class="type">str</span>] = &amp;[<span class="string">&quot;JVAV&quot;</span>, <span class="string">&quot;IT&quot;</span>, <span class="string">&quot;ZEN&quot;</span>];</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Book Str Slices 1: &#123;:?&#125;&quot;</span>, book_str_slices_1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方式二：从 String 创建 &amp;str，然后将 &amp;str 放入数组</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s1</span> = <span class="string">&quot;JVAV&quot;</span>.<span class="title function_ invoke__">to_string</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s2</span> = <span class="string">&quot;IT&quot;</span>.<span class="title function_ invoke__">to_string</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s3</span> = <span class="string">&quot;ZEN&quot;</span>.<span class="title function_ invoke__">to_string</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意这里我们是将 &amp;String 显式地转换（通过 Deref Coercion）为 &amp;str 放入数组</span></span><br><span class="line">    <span class="comment">// 但更常见的是直接从 String 创建 &amp;str</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">book_str_slices_2</span>: &amp;[&amp;<span class="type">str</span>] = &amp;[&amp;s1, &amp;s2, &amp;s3]; <span class="comment">// &amp;s1 (type &amp;String) automatically derefs to &amp;str here</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Book Str Slices 2: &#123;:?&#125;&quot;</span>, book_str_slices_2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <code>book_str_slices_2</code> 的例子中，当你把 <code>&amp;s1</code>（类型是 <code>&amp;String</code>）放入一个期望 <code>&amp;str</code> 元素的数组时，Deref Coercion 就会发生，将每个 <code>&amp;String</code> 自动转换为 <code>&amp;str</code>。</p>
<hr>
<h3 id="String与-str"><a href="#String与-str" class="headerlink" title="&amp;String与&amp;str"></a>&amp;String与&amp;str</h3><p><strong><code>&amp;[&amp;String]</code> 和 <code>&amp;[&amp;str]</code> 都不能直接修改它们所指向的字符串内容</strong>，但它们之间存在重要的区别，尤其是在<strong>所有权</strong>、<strong>生命周期</strong>和<strong>底层内存布局</strong>方面。</p>
<h2 id="核心区别概览"><a href="#核心区别概览" class="headerlink" title="核心区别概览"></a>核心区别概览</h2><table>
<thead>
<tr>
<th>特性 &#x2F; 类型</th>
<th><code>&amp;[&amp;String]</code> (指向 <code>&amp;String</code> 数组的切片)</th>
<th><code>&amp;[&amp;str]</code> (指向 <code>&amp;str</code> 数组的切片)</th>
</tr>
</thead>
<tbody><tr>
<td><strong>切片元素类型</strong></td>
<td><code>&amp;String</code> (指向 <code>String</code> 的不可变引用)</td>
<td><code>&amp;str</code> (字符串切片，指向 <code>str</code> 的不可变引用)</td>
</tr>
<tr>
<td><strong>被引用数据的</strong></td>
<td><strong><code>String</code></strong> 类型（拥有数据，在堆上）</td>
<td><strong><code>str</code></strong> 类型（通常在数据段或来自 <code>String</code> 的部分）</td>
</tr>
<tr>
<td><strong>内存位置</strong></td>
<td>引用指向堆上的 <code>String</code> 对象</td>
<td>引用可以直接指向字符串字面量（静态区）或 <code>String</code> 的堆数据</td>
</tr>
<tr>
<td><strong>底层数据所有权</strong></td>
<td>切片本身不拥有数据，但它引用的 <code>String</code> <strong>拥有</strong>数据</td>
<td>切片本身不拥有数据，它引用的 <code>str</code> 也<strong>不拥有</strong>数据</td>
</tr>
<tr>
<td><strong>生命周期管理</strong></td>
<td><strong><code>String</code> 实例的生命周期</strong>必须比 <code>&amp;String</code> 引用长</td>
<td><strong><code>str</code> 数据源的生命周期</strong>必须比 <code>&amp;str</code> 引用长</td>
</tr>
<tr>
<td><strong>创建成本</strong></td>
<td>通常涉及 <code>String::from()</code>，堆分配成本</td>
<td>直接使用字面量，无运行时成本；从 <code>String</code> 借用也无额外成本</td>
</tr>
<tr>
<td><strong>灵活性</strong></td>
<td>间接引用堆数据，多了一层封装</td>
<td>直接引用字符串数据，更灵活，可接受多种来源</td>
</tr>
</tbody></table>
<h3 id="1-String-：指向-String-引用的切片"><a href="#1-String-：指向-String-引用的切片" class="headerlink" title="1. &amp;[&amp;String]：指向 String 引用的切片"></a>1. <code>&amp;[&amp;String]</code>：指向 <code>String</code> 引用的切片</h3><p>当你有 <code>let book_slices: &amp;[&amp;String]</code> 时：</p>
<ul>
<li><strong>内部元素是 <code>&amp;String</code></strong>：这意味着切片中的每个元素都是一个<strong>指向 <code>String</code> 类型数据的引用</strong>。</li>
<li><strong><code>String</code> 拥有数据</strong>：这些 <code>String</code> 对象本身是独立的，它们各自在**堆（heap）**上分配了内存来存储字符串数据。</li>
<li><strong>多层引用</strong>：你可以将其想象为“一个数组的切片，这个数组里的每个元素都是一个指针，而这些指针又指向堆上的字符串对象”。</li>
<li><strong>生命周期</strong>：这个 <code>&amp;[&amp;String]</code> 切片的有效性，取决于它所引用的那个数组（它是一个临时数组字面量），以及数组里面所有 <code>&amp;String</code> 引用所指向的<strong>原始 <code>String</code> 实例的生命周期</strong>。这些 <code>String</code> 实例必须在 <code>&amp;[&amp;String]</code> 切片被使用期间保持有效。<ul>
<li>在你的例子中 <code>&amp;&quot;JVAV&quot;.to_string()</code>，这些 <code>String</code> 实例是<strong>匿名</strong>的。它们在切片被创建的那一行被创建，它们的生命周期被 Rust 自动管理。由于它们在表达式中创建并立即被引用，Rust 编译器会确保它们存活足够长的时间，以供 <code>book_slices</code> 使用。</li>
</ul>
</li>
<li><strong>修改</strong>：你不能通过 <code>&amp;[&amp;String]</code> 切片修改原始的 <code>String</code> 内容，也不能修改切片本身（例如增加或删除元素）。</li>
</ul>
<h3 id="2-str-：指向字符串切片的切片"><a href="#2-str-：指向字符串切片的切片" class="headerlink" title="2. &amp;[&amp;str]：指向字符串切片的切片"></a>2. <code>&amp;[&amp;str]</code>：指向字符串切片的切片</h3><p>当你有 <code>let book_str_slices: &amp;[&amp;str]</code> 时：</p>
<ul>
<li><strong>内部元素是 <code>&amp;str</code></strong>：这意味着切片中的每个元素都是一个<strong>字符串切片</strong>，直接指向 UTF-8 编码的字符串数据。</li>
<li><strong><code>&amp;str</code> 不拥有数据</strong>：这些 <code>&amp;str</code> 只是视图，它们不负责内存管理。它们可以指向：<ul>
<li><strong>静态字符串字面量</strong>（存储在程序的二进制文件中，生命周期是 <code>&#39;static&#39;</code>，贯穿整个程序）。</li>
<li><strong>堆上 <code>String</code> 的一部分或全部</strong>（如果 <code>&amp;str</code> 是从 <code>String</code> 借用而来）。</li>
</ul>
</li>
<li><strong>单层引用</strong>：这可以看作是“一个数组的切片，这个数组里的每个元素都是一个字符串指针（胖指针），直接指向字符串数据”。</li>
<li><strong>生命周期</strong>：这个 <code>&amp;[&amp;str]</code> 切片的有效性，取决于它所引用的数组，以及数组里面所有 <code>&amp;str</code> 引用所指向的<strong>原始字符串数据源的生命周期</strong>。这些数据源必须在 <code>&amp;[&amp;str]</code> 切片被使用期间保持有效。</li>
<li><strong>修改</strong>：你不能通过 <code>&amp;[&amp;str]</code> 切片修改原始的字符串内容，也不能修改切片本身。</li>
</ul>
<h2 id="为什么这种区别很重要？"><a href="#为什么这种区别很重要？" class="headerlink" title="为什么这种区别很重要？"></a>为什么这种区别很重要？</h2><ol>
<li><strong>性能与内存开销</strong>：<ul>
<li><code>&amp;[&amp;String]</code>：创建时需要先创建 <code>String</code> 对象（堆分配），再获取引用。这会带来额外的内存分配和解分配开销。</li>
<li><code>&amp;[&amp;str]</code>：如果元素是字符串字面量，就没有堆分配开销。如果元素是从 <code>String</code> 借用的 <code>&amp;str</code>，那么也没有额外的堆分配。通常更轻量级。</li>
</ul>
</li>
<li><strong>生命周期复杂性</strong>：<ul>
<li><code>&amp;[&amp;String]</code>：你引用的 <code>String</code> 实例必须在切片的整个生命周期内都存在。如果这些 <code>String</code> 是匿名临时创建的，Rust 编译器会尽力延长它们的生命周期，但这并非总是能成功。</li>
<li><code>&amp;[&amp;str]</code>：其生命周期取决于它所引用的实际 <code>str</code> 数据。<code>&amp;&#39;static str</code> 最简单，可以无限制地使用。从 <code>String</code> 借用的 <code>&amp;str</code> 则受限于 <code>String</code> 的生命周期。</li>
</ul>
</li>
<li><strong>函数通用性</strong>：<ul>
<li>通常情况下，函数参数更倾向于使用 <code>&amp;str</code> 而不是 <code>&amp;String</code>，因为 <code>&amp;str</code> 更通用，可以接受各种来源的字符串数据。</li>
<li><code>&amp;[&amp;str]</code> 这样的类型在处理一组通用字符串视图时更为常见。</li>
</ul>
</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>虽然 <code>&amp;[&amp;String]</code> 和 <code>&amp;[&amp;str]</code> 都表示不可修改的字符串序列，但它们在<strong>底层数据类型、所有权链、内存分配和生命周期管理</strong>上存在根本区别。</p>
<ul>
<li><code>&amp;[&amp;String]</code> 是一个切片，它的元素是<strong>指向堆上 <code>String</code> 对象的引用</strong>。</li>
<li><code>&amp;[&amp;str]</code> 是一个切片，它的元素是<strong>直接指向 <code>str</code> 数据的引用</strong>（可以是静态区或堆上 <code>String</code> 的一部分）。</li>
</ul>
<p>理解这些细微差别对于编写高效、安全且符合 Rust 习惯的代码至关重要。</p>
<p>但是&amp;[&amp;mut String]是可以对包含的字符串内容进行修改的，可以类比C语言中的字符数组数组。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/07/17/%E5%9F%BA%E4%BA%8EC%E8%AF%AD%E8%A8%80%E7%AE%80%E6%98%93OOP%E5%AE%9E%E7%8E%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.png">
      <meta itemprop="name" content="Chillward">
      <meta itemprop="description" content="谁躺在漆黑的舞台上，用身体迎接着光芒">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chillward的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/07/17/%E5%9F%BA%E4%BA%8EC%E8%AF%AD%E8%A8%80%E7%AE%80%E6%98%93OOP%E5%AE%9E%E7%8E%B0/" class="post-title-link" itemprop="url">基于C语言简易OOP实现</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-07-17 10:09:13 / 修改时间：11:44:02" itemprop="dateCreated datePublished" datetime="2025-07-17T10:09:13+08:00">2025-07-17</time>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>4k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>7 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>最近在倒腾C语言实现类似于OOP的东西，在油管上看到了这样一种实现方法，昨天尝试了一下，现在记录一下</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=e99VxS8ljjY">Object-Oriented Programming in regular C</a></p>
</blockquote>
<p>最终的主函数长这样，实现了一个非常简陋的String类以及字符串拼接功能，当然，也几乎没有健壮性。这位博主只是简单提供了一种思路。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span>&#123;</span><br><span class="line">	String *s1;</span><br><span class="line">	String *s2;</span><br><span class="line">	s1 = mkstring(<span class="string">&quot;Hello &quot;</span>);</span><br><span class="line">	s2 = mkstring(<span class="string">&quot;World&quot;</span>);</span><br><span class="line">	$(s1)-&gt;concat(s2);</span><br><span class="line">	printfstr(s1);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">free</span>(s1);</span><br><span class="line">	<span class="built_in">free</span>(s2);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个设计的核心在于全局this指针以及宏定义(虽然全局的this指针不是很安全)。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">s_string</span> <span class="title">String</span>;</span> </span><br><span class="line"><span class="keyword">typedef</span> String* (*method)(String*);</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">s_string</span>&#123;</span></span><br><span class="line">	method concat;</span><br><span class="line">	<span class="type">int8_t</span> length;</span><br><span class="line">	<span class="type">char</span> data[];</span><br><span class="line">&#125;String;</span><br></pre></td></tr></table></figure>

<p>首先我们需要用结构体模拟一个String类出来，其中包含了concat方法、长度length以及一个char数组(之前在别处见到的另一种实现多态的方法好像用到了接口结构体跟聚合表，我暂时还没太弄明白，等我弄明白了或许会再写个博客出来)。</p>
<blockquote>
<p>实际上这个 data[]也可以写成<code>char *data;</code>,本质上没什么区别</p>
</blockquote>
<p>method实际上是一个函数指针，指向一个返回值为<strong>String*</strong>,参数为**String***的函数，我们需要自己实现这个函数。</p>
<p>接下来我们为这个类实现构造函数以及打印函数，下面是这两个函数的声明。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String *<span class="title function_">mkstring</span><span class="params">(<span class="type">char</span>*)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">printfstr</span><span class="params">(<span class="type">const</span> String*)</span>;</span><br></pre></td></tr></table></figure>

<p>printfstr函数没什么好讲的，这里讲一下mkstring函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">String *<span class="title function_">mkstring</span><span class="params">(<span class="type">char</span>*str)</span>&#123;</span><br><span class="line">	<span class="type">int16_t</span> len;</span><br><span class="line">	<span class="type">int16_t</span> size;</span><br><span class="line">	String *p;</span><br><span class="line">	</span><br><span class="line">	assert(str);</span><br><span class="line">	len = <span class="built_in">strlen</span>(str);</span><br><span class="line">	assert(len);</span><br><span class="line">	</span><br><span class="line">	size = len +<span class="keyword">sizeof</span>(String) +<span class="number">1</span>;</span><br><span class="line">	p = (String*)<span class="built_in">malloc</span>(size);</span><br><span class="line">	assert(p);</span><br><span class="line">	<span class="built_in">memset</span>(p,<span class="number">0</span>,size);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">memcpy</span>(p-&gt;data,str,len);</span><br><span class="line">	p-&gt;length = len;</span><br><span class="line">	p-&gt;concat = concat_;</span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以先忽略掉这些<strong>assert</strong>(断言)，这个函数进行了以下操作:</p>
<ol>
<li><p>根据输入参数计算了String对象中length参数的长度并赋值。</p>
</li>
<li><p>根据输入字符数组的长度申请了足够的内存空间，并且使用memcpy函数将字符数组的内容复制进String对象中。</p>
</li>
<li><p>将自己实现的concat_函数与类中的函数指针进行了绑定。</p>
</li>
<li><p>最后返回了一个指向初始化好的String对象的指针。</p>
</li>
</ol>
<blockquote>
<p>此处需要注意，C语言字符数组以’\0’作为结尾，在这个函数中，通过memset将整个结构体置0时就相当于将类中char数组最后一位置0了，所以不再需要显式的置0。</p>
</blockquote>
<p>现在来看一下这个设计最核心的部分，全局this指针</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">void</span> thisptr;</span><br><span class="line">thisptr* _this;</span><br></pre></td></tr></table></figure>

<p>可以看到我们创建了一个全局this指针，它将始终指向我们正在操作的String对象。</p>
<p>接下来我们来实现这个concat_方法函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">String* <span class="title function_">concat_</span><span class="params">(String* input)</span> &#123;</span><br><span class="line">	String* current_this = _this; </span><br><span class="line">	</span><br><span class="line">	<span class="type">char</span>* temp_input_data = (<span class="type">char</span>*)<span class="built_in">malloc</span>(input-&gt;length + <span class="number">1</span>);</span><br><span class="line">	<span class="built_in">strcpy</span>(temp_input_data, input-&gt;data);</span><br><span class="line">	</span><br><span class="line">	<span class="type">int16_t</span> original_current_this_length = current_this-&gt;length; </span><br><span class="line">	<span class="type">int16_t</span> new_length = original_current_this_length + input-&gt;length;</span><br><span class="line">	<span class="type">size_t</span> new_size = <span class="keyword">sizeof</span>(String) + new_length + <span class="number">1</span>;</span><br><span class="line">	</span><br><span class="line">	String* reallocated_string = (String*)<span class="built_in">realloc</span>(current_this, new_size);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (reallocated_string == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		perror(<span class="string">&quot;realloc 失败，无法原地扩展字符串&quot;</span>);</span><br><span class="line">		<span class="built_in">free</span>(temp_input_data);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	current_this = reallocated_string; </span><br><span class="line">	_this = current_this; </span><br><span class="line">	</span><br><span class="line">	current_this-&gt;length = new_length;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">memcpy</span>(current_this-&gt;data + original_current_this_length, temp_input_data, input-&gt;length);</span><br><span class="line">	</span><br><span class="line">	current_this-&gt;data[new_length] = <span class="string">&#x27;\0&#x27;</span>; </span><br><span class="line"></span><br><span class="line">	<span class="built_in">free</span>(temp_input_data);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> current_this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们先忽略掉错误处理部分，这个函数实现了以下的功能</p>
<ol>
<li><p><strong>保存输入字符串数据</strong> 函数首先将 <code>input</code> 字符串的数据复制到一个临时缓冲区 <code>temp_input_data</code> 中。这是为了防止在 <code>realloc</code> 失败时，<code>input-&gt;data</code> 中的数据丢失，或者如果在 <code>realloc</code> 后 <code>input-&gt;data</code> 指向的内存被释放或移动而导致后续操作出错。</p>
</li>
<li><p><strong>计算新字符串长度和所需内存大小</strong> 它计算了连接后的新字符串的总长度 <code>new_length</code>（原字符串长度 + 输入字符串长度），并根据这个新长度计算了 <code>String</code> 结构体加上字符串数据所需的总内存大小 <code>new_size</code>。</p>
</li>
<li><p><strong>重新分配内存</strong> 函数尝试使用 <code>realloc</code> 来扩展当前字符串 <code>_this</code> 所占用的内存。<code>realloc</code> 会尝试在原地扩展内存，如果原地扩展失败，它会分配一块新的内存区域并将原有数据复制过去，然后释放旧的内存区域。</p>
</li>
<li><p><strong>处理内存重新分配失败</strong> 如果 <code>realloc</code> 返回 <code>NULL</code>，表示内存重新分配失败。此时，函数会打印错误信息，释放之前分配的临时缓冲区，并返回 <code>NULL</code>。</p>
</li>
<li><p><strong>更新当前字符串指针和长度</strong> 如果内存重新分配成功，<code>current_this</code>（以及全局或成员变量 <code>_this</code>）会更新为 <code>reallocated_string</code> 返回的新地址。然后，<code>current_this</code> 的 <code>length</code> 字段会被更新为 <code>new_length</code>。</p>
</li>
<li><p><strong>拷贝输入字符串数据</strong> 使用 <code>memcpy</code> 将 <code>temp_input_data</code>（即 <code>input</code> 字符串的数据）拷贝到 <code>current_this-&gt;data</code> 的末尾，从 <code>original_current_this_length</code> 的位置开始。</p>
</li>
<li><p><strong>添加字符串结束符</strong> 在新字符串的末尾（<code>new_length</code> 的位置）添加空字符 <code>\0</code>，以确保它是一个合法的 C 字符串。</p>
</li>
<li><p><strong>释放临时缓冲区并返回</strong> 最后，释放之前为 <code>temp_input_data</code> 分配的内存，并返回更新后的 <code>current_this</code> 指针。</p>
</li>
</ol>
<p>这个函数是我修改过的，博主原代码如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">String *<span class="title function_">concat_</span><span class="params">(String *input)</span>&#123;</span><br><span class="line">    <span class="type">int16_t</span> len;</span><br><span class="line">    <span class="type">int16_t</span> size;</span><br><span class="line">    <span class="type">char</span> *p;</span><br><span class="line">    String *this;</span><br><span class="line">    this = (String*)_this;</span><br><span class="line">    len = this-&gt;length + input-&gt;length;</span><br><span class="line">    size = len+<span class="keyword">sizeof</span>(<span class="keyword">struct</span> s_string)+<span class="number">1</span>;</span><br><span class="line">    p = this-&gt;data +this-&gt;length;</span><br><span class="line">    this = (String*)<span class="built_in">realloc</span>(this,size);</span><br><span class="line">    assert(this);</span><br><span class="line">    <span class="built_in">memcpy</span>(p,input-&gt;data,input-&gt;length);</span><br><span class="line">    p = this-&gt;data +len;</span><br><span class="line">    *p = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> this;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可能是因为编译环境不同，这种写法在我的编译环境下会导致严重的内存问题。</p>
<p>现在如果我们想要在主函数中实现字符串拼接，需要以下步骤:</p>
<ol>
<li>初始化s1,s2。</li>
<li>this指针指向s1。</li>
<li>调用s1的concat方法，将s2传入。</li>
</ol>
<p>体现在代码上如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">_this = s1;</span><br><span class="line">s1 = s1-&gt;concat(s2);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里会出现<code>s1 = s1-&gt;concat(*)</code>的写法,是因为在concat函数中进行realloc操作时，会改变s1指针指向的内存，不管是原地扩容还是在新内存空间扩容，在扩容完成后将地址返回给s1就可以保证不出现悬空指针了。</p>
</blockquote>
<p>接下来我们可以实现一个操作宏来简化我们的操作</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> $(x) _this = (x);(x) = (x)</span></span><br></pre></td></tr></table></figure>

<p>这个宏让我们可以以<code>$(s1)-&gt;concat(s2);</code>的形式直接调用对象中的方法，展开后本质上跟上面的写法是一样的。</p>
<blockquote>
<p>注意：这种写法实际上是不安全的，我只是将博主的实现方法照抄下来并且进行记录，暂时还没想到怎么才能优化这种写法</p>
<p>但是有一点显而易见的就是这个全局的this指针是不安全的。</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Chillward"
      src="/uploads/avatar.png">
  <p class="site-author-name" itemprop="name">Chillward</p>
  <div class="site-description" itemprop="description">谁躺在漆黑的舞台上，用身体迎接着光芒</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">6</span>
          <span class="site-state-item-name">博客</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/zh-CN" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Chillward</span>
</div>
  <div class="powered-by">
    <!--由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动 -->
  </div>

<!-- 网站运行时间的设置 -->
<span id="timeDate">载入天数...</span>
<span id="times">载入时分秒...</span>
<script>
    var now = new Date();
    function createtime() {
        var grt= new Date("07/16/2025 10:00:00"); //此处修改你的建站时间或者网站上线时间
        now.setTime(now.getTime()+250);
        days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days);
        hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours);
        if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);
        mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;}
        seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
        snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;}
        document.getElementById("timeDate").innerHTML = "本站已安全运行 "+dnum+" 天 ";
        document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒.";
    }
setInterval("createtime()",250);
</script>
        








	 </div>
    </footer>
  </div>

  
  <script size="300" alpha="0.6" zIndex="-1" src="/lib/canvas-ribbon/canvas-ribbon.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/pjax/pjax.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/lozad@1/dist/lozad.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/pangu@4/dist/browser/pangu.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  




  
<script src="/js/local-search.js"></script>











<script data-pjax>
if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.initialize({
      theme    : 'dark',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    });
  }, window.mermaid);
}
</script>


    <div id="pjax">
  

  

    </div>
</body>
</html>
