<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":true,"pangu":true,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="谁躺在漆黑的舞台上，用身体迎接着光芒">
<meta property="og:type" content="website">
<meta property="og:title" content="Chillward的博客">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Chillward的博客">
<meta property="og:description" content="谁躺在漆黑的舞台上，用身体迎接着光芒">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Chillward">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Chillward的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Chillward的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/07/25/RUST%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0%E4%B9%8B%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.png">
      <meta itemprop="name" content="Chillward">
      <meta itemprop="description" content="谁躺在漆黑的舞台上，用身体迎接着光芒">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chillward的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/07/25/RUST%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0%E4%B9%8B%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/" class="post-title-link" itemprop="url">RUST学习日记之错误处理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-07-25 18:15:52" itemprop="dateCreated datePublished" datetime="2025-07-25T18:15:52+08:00">2025-07-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-07-27 15:43:51" itemprop="dateModified" datetime="2025-07-27T15:43:51+08:00">2025-07-27</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>12k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>23 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>以前一直是写C的，对于现代语言的错误处理一直是搞不太懂，不过目前看来Rust的错误处理看起来还是比Java顺眼一点的</p>
</blockquote>
<h2 id="panic与不可恢复的错误"><a href="#panic与不可恢复的错误" class="headerlink" title="panic与不可恢复的错误"></a>panic与不可恢复的错误</h2><p>panic就类似于程序崩溃，程序会直接崩溃掉，这种错误是无法被程序处理的</p>
<p>有的时候代码出问题了，而你对此束手无策。对于这种情况，Rust 有 <code>panic!</code>宏。当执行这个宏时，程序会打印出一个错误信息，展开并清理栈数据，然后接着退出。出现这种情况的场景通常是检测到一些类型的 bug，而且开发者并不清楚该如何处理它。</p>
<blockquote>
<p>当出现 panic 时，程序默认会开始 <strong>展开</strong>（<em>unwinding</em>），这意味着 Rust 会回溯栈并清理它遇到的每一个函数的数据，不过这个回溯并清理的过程有很多工作。另一种选择是直接 <strong>终止</strong>（<em>abort</em>），这会不清理数据就退出程序。那么程序所使用的内存需要由操作系统来清理。如果你需要项目的最终二进制文件越小越好，panic 时通过在 <em>Cargo.toml</em> 的 <code>[profile]</code> 部分增加 <code>panic = &#39;abort&#39;</code>，可以由展开切换为终止。例如，如果你想要在release模式中 panic 时直接终止：</p>
<figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[profile.release]</span></span><br><span class="line"><span class="attr">panic</span> = <span class="string">&#x27;abort&#x27;</span></span><br></pre></td></tr></table></figure></blockquote>
<p>让我们在一个简单的程序中调用 <code>panic!</code>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">panic!</span>(<span class="string">&quot;crash and burn&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行程序将会出现类似这样的输出：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ cargo run</span><br><span class="line">   Compiling panic v0.1.0 (file:///projects/panic)</span><br><span class="line">    Finished dev [unoptimized + debuginfo] target(s) in 0.25s</span><br><span class="line">     Running `target/debug/panic`</span><br><span class="line">thread &#x27;main&#x27; panicked at &#x27;crash and burn&#x27;, src/main.rs:2:5</span><br><span class="line">note: Run with `RUST_BACKTRACE=1` for a backtrace.</span><br></pre></td></tr></table></figure>

<p>最后两行包含 <code>panic!</code> 调用造成的错误信息。第一行显示了 panic 提供的信息并指明了源码中 panic 出现的位置：<em>src&#x2F;main.rs:2:5</em> 表明这是 <em>src&#x2F;main.rs</em> 文件的第二行第五个字符。</p>
<p>在这个例子中，被指明的那一行是我们代码的一部分，而且查看这一行的话就会发现 <code>panic!</code> 宏的调用。在其他情况下，<code>panic!</code> 可能会出现在我们的代码所调用的代码中。错误信息报告的文件名和行号可能指向别人代码中的 <code>panic!</code> 宏调用，而不是我们代码中最终导致 <code>panic!</code> 的那一行。我们可以使用 <code>panic!</code> 被调用的函数的 backtrace 来寻找代码中出问题的地方。下面我们会详细介绍 backtrace 是什么。</p>
<blockquote>
<p>backtrace宏的作用就是让我们可以找到“我们编写的代码中导致程序崩溃的地方”</p>
</blockquote>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    v[<span class="number">99</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是一个越界调用，在C语言中，这段代码会运行，然后给你一个错误的值，这是相当危险的</p>
<p>为了使程序远离这类漏洞，如果尝试读取一个索引不存在的元素，Rust 会停止执行并拒绝继续。尝试运行上面的程序会出现如下：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ cargo run</span><br><span class="line">   Compiling panic v0.1.0 (file:///projects/panic)</span><br><span class="line">    Finished dev [unoptimized + debuginfo] target(s) in 0.27s</span><br><span class="line">     Running `target/debug/panic`</span><br><span class="line">thread &#x27;main&#x27; panicked at &#x27;index out of bounds: the len is 3 but the index is 99&#x27;, libcore/slice/mod.rs:2448:10</span><br><span class="line">note: Run with `RUST_BACKTRACE=1` for a backtrace.</span><br></pre></td></tr></table></figure>

<p>这指向了一个不是我们编写的文件，<em>libcore&#x2F;slice&#x2F;mod.rs</em>。其为 Rust 源码中 <code>slice</code> 的实现。这是当对 vector <code>v</code> 使用 <code>[]</code> 时 <em>libcore&#x2F;slice&#x2F;mod.rs</em> 中会执行的代码，也是真正出现 <code>panic!</code> 的地方。</p>
<p>接下来的几行提醒我们可以设置 <code>RUST_BACKTRACE</code> 环境变量来得到一个 backtrace。<em>backtrace</em> 是一个执行到目前位置所有被调用的函数的列表。Rust 的 backtrace 跟其他语言中的一样：阅读 backtrace 的关键是从头开始读直到发现你编写的文件。这就是问题的发源地。这一行往上是你的代码所调用的代码；往下则是调用你的代码的代码。这些行可能包含核心 Rust 代码，标准库代码或用到的 crate 代码。让我们将 <code>RUST_BACKTRACE</code> 环境变量设置为任何不是 0 的值来获取 backtrace 看看。示例 9-2 展示了与你看到类似的输出：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">$ RUST_BACKTRACE=1 cargo run</span><br><span class="line">    Finished dev [unoptimized + debuginfo] target(s) in 0.00s</span><br><span class="line">     Running `target/debug/panic`</span><br><span class="line">thread &#x27;main&#x27; panicked at &#x27;index out of bounds: the len is 3 but the index is 99&#x27;, libcore/slice/mod.rs:2448:10</span><br><span class="line">stack backtrace:</span><br><span class="line">   0: std::sys::unix::backtrace::tracing::imp::unwind_backtrace</span><br><span class="line">             at libstd/sys/unix/backtrace/tracing/gcc_s.rs:49</span><br><span class="line">   1: std::sys_common::backtrace::print</span><br><span class="line">             at libstd/sys_common/backtrace.rs:71</span><br><span class="line">             at libstd/sys_common/backtrace.rs:59</span><br><span class="line">   2: std::panicking::default_hook::&#123;&#123;closure&#125;&#125;</span><br><span class="line">             at libstd/panicking.rs:211</span><br><span class="line">   3: std::panicking::default_hook</span><br><span class="line">             at libstd/panicking.rs:227</span><br><span class="line">   4: &lt;std::panicking::begin_panic::PanicPayload&lt;A&gt; as core::panic::BoxMeUp&gt;::get</span><br><span class="line">             at libstd/panicking.rs:476</span><br><span class="line">   5: std::panicking::continue_panic_fmt</span><br><span class="line">             at libstd/panicking.rs:390</span><br><span class="line">   6: std::panicking::try::do_call</span><br><span class="line">             at libstd/panicking.rs:325</span><br><span class="line">   7: core::ptr::drop_in_place</span><br><span class="line">             at libcore/panicking.rs:77</span><br><span class="line">   8: core::ptr::drop_in_place</span><br><span class="line">             at libcore/panicking.rs:59</span><br><span class="line">   9: &lt;usize as core::slice::SliceIndex&lt;[T]&gt;&gt;::index</span><br><span class="line">             at libcore/slice/mod.rs:2448</span><br><span class="line">  10: core::slice::&lt;impl core::ops::index::Index&lt;I&gt; for [T]&gt;::index</span><br><span class="line">             at libcore/slice/mod.rs:2316</span><br><span class="line">  11: &lt;alloc::vec::Vec&lt;T&gt; as core::ops::index::Index&lt;I&gt;&gt;::index</span><br><span class="line">             at liballoc/vec.rs:1653</span><br><span class="line">  12: panic::main</span><br><span class="line">             at src/main.rs:4</span><br><span class="line">  13: std::rt::lang_start::&#123;&#123;closure&#125;&#125;</span><br><span class="line">             at libstd/rt.rs:74</span><br><span class="line">  14: std::panicking::try::do_call</span><br><span class="line">             at libstd/rt.rs:59</span><br><span class="line">             at libstd/panicking.rs:310</span><br><span class="line">  15: macho_symbol_search</span><br><span class="line">             at libpanic_unwind/lib.rs:102</span><br><span class="line">  16: std::alloc::default_alloc_error_hook</span><br><span class="line">             at libstd/panicking.rs:289</span><br><span class="line">             at libstd/panic.rs:392</span><br><span class="line">             at libstd/rt.rs:58</span><br><span class="line">  17: std::rt::lang_start</span><br><span class="line">             at libstd/rt.rs:74</span><br><span class="line">  18: panic::main</span><br></pre></td></tr></table></figure>

<p>这种信息一般是从下往上读，直到找到我们自己编写的代码位置</p>
<blockquote>
<p>RUST_BACKTRACE&#x3D;1 cargo run</p>
</blockquote>
<p>我们可以通过终端传递这个环境变量的值来进入BACKTRACE。</p>
<hr>
<p>现在让我们回到C语言</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  <span class="comment">// 用于 printf</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits.h&gt;</span> <span class="comment">// 用于 INT_MIN</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 执行两个整数的除法。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param numerator 被除数。</span></span><br><span class="line"><span class="comment"> * @param denominator 除数。</span></span><br><span class="line"><span class="comment"> * @return int 如果除数不为零，返回计算出的商。</span></span><br><span class="line"><span class="comment"> * 如果除数为零，返回 INT_MIN 表示错误。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">safe_divide</span><span class="params">(<span class="type">int</span> numerator, <span class="type">int</span> denominator)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (denominator == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Error: Division by zero is not allowed.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> INT_MIN; <span class="comment">// 传播错误：返回一个特殊值表示失败</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> numerator / denominator; <span class="comment">// 成功：返回计算结果</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> result;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;--- 正常除法示例 ---\n&quot;</span>);</span><br><span class="line">    result = safe_divide(<span class="number">10</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span> (result != INT_MIN) &#123; <span class="comment">// 检查返回值是否是错误码</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;10 / 2 = %d\n&quot;</span>, result); <span class="comment">// 成功处理</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Error occurred during division.\n&quot;</span>); <span class="comment">// 错误处理</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n--- 除数为零示例 ---\n&quot;</span>);</span><br><span class="line">    result = safe_divide(<span class="number">10</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (result != INT_MIN) &#123; <span class="comment">// 检查返回值是否是错误码</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;10 / 0 = %d\n&quot;</span>, result); <span class="comment">// 理论上不会执行到这里</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Error occurred during division. Cannot divide by zero.\n&quot;</span>); <span class="comment">// 错误处理</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n--- 另一个正常除法示例 ---\n&quot;</span>);</span><br><span class="line">    result = safe_divide(<span class="number">-15</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">if</span> (result != INT_MIN) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;-15 / 3 = %d\n&quot;</span>, result);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Error occurred during division.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当我们写一个除法程序，当我们传”0”为除数，程序很明显不应该崩溃，而是该返回一个标记值来提醒调用者出错了，然后调用者再进行处理，这就是<strong>可恢复的错误</strong>以及<strong>错误的传播</strong>。</p>
<p>C语言中错误的传播相对原始，一般都是通过返回值层层传递，一旦有一层忘记处理这种情况，整个程序的稳定性就会受到极大的影响。 </p>
<p>在讨论Rust中错误的传播前，我们先来讨论Rust对于这种可恢复错误的处理方式。</p>
<hr>
<p>在 Rust 中，<code>Option&lt;T&gt;</code> 和 <code>Result&lt;T, E&gt;</code> 是两个非常核心的枚举（enum），它们是 Rust 强大的<strong>错误处理</strong>和<strong>存在性（presence）管理</strong>机制的基石。它们的设计理念是强制你在编译时处理可能缺失的值或可能发生的错误，从而避免了其他语言中常见的空指针异常和未处理的运行时错误。</p>
<h3 id="Option：处理值可能缺失的情况"><a href="#Option：处理值可能缺失的情况" class="headerlink" title="Option&lt;T&gt;：处理值可能缺失的情况"></a><code>Option&lt;T&gt;</code>：处理值可能缺失的情况</h3><p><code>Option&lt;T&gt;</code> 枚举用来表示一个值<strong>可能存在，也可能不存在</strong>的情况。它的定义如下：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Option</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="literal">None</span>, <span class="comment">// 值不存在</span></span><br><span class="line">    <span class="title function_ invoke__">Some</span>(T), <span class="comment">// 值存在，并包含类型 T 的数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>它解决什么问题？</strong></p>
<p>在许多其他语言（如 C++、Java、Python 等）中，你可能会使用 <code>NULL</code>、<code>null</code> 或 <code>None</code> 来表示一个变量没有值。然而，直接使用这些“空”值往往会导致运行时错误，比如著名的<strong>空指针异常（Null Pointer Exception）</strong>。因为你可能会忘记检查一个值是否为 <code>null</code>，然后尝试对其进行操作。</p>
<p><code>Option&lt;T&gt;</code> 强制你在编译时就处理值存在或不存在的两种情况。如果你尝试直接使用一个 <code>Option&lt;T&gt;</code> 中的值而不先确定它是否是 <code>Some(T)</code>，编译器会报错。</p>
<h3 id="Result：处理可能发生的错误"><a href="#Result：处理可能发生的错误" class="headerlink" title="Result&lt;T, E&gt;：处理可能发生的错误"></a><code>Result&lt;T, E&gt;</code>：处理可能发生的错误</h3><p><code>Result&lt;T, E&gt;</code> 枚举用来表示一个操作<strong>可能成功并返回一个值，也可能失败并返回一个错误</strong>。它的定义如下：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Result</span>&lt;T, E&gt; &#123;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(T),  <span class="comment">// 操作成功，并包含类型 T 的结果数据</span></span><br><span class="line">    <span class="title function_ invoke__">Err</span>(E), <span class="comment">// 操作失败，并包含类型 E 的错误数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>它解决什么问题？</strong></p>
<p>在 C 语言中，你通常通过返回值和错误码来表示函数成功或失败。在 Java&#x2F;Python 等语言中，则通常使用异常（exceptions）。然而，这些方式都有其弊端：</p>
<ul>
<li><strong>C 语言的错误码</strong>：容易被忽略，需要手动检查，且错误信息有限。</li>
<li><strong>异常</strong>：虽然方便，但可能会导致控制流难以预测（“goto 式的错误处理”），且编译器通常不会强制你捕获或声明异常，可能导致未处理的运行时崩溃。</li>
</ul>
<p><code>Result&lt;T, E&gt;</code> 强制你在编译时就考虑并处理成功和失败的两种情况，使得错误处理成为你代码类型系统的一部分。</p>
<p><strong>如何使用？</strong></p>
<p>与 <code>Option</code> 类似，你通常会使用 <code>match</code> 表达式、<code>if let</code> 或 <code>Result</code> 提供的各种方法（如 <code>is_ok()</code>, <code>is_err()</code>, <code>unwrap()</code>, <code>expect()</code>, <code>map_err()</code>, <code>and_then()</code>, <strong><code>?</code> 运算符</strong>等）来处理 <code>Result</code> 值。</p>
<p><strong>示例：</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File; <span class="comment">// 引入文件系统模块</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// 尝试打开一个不存在的文件</span></span><br><span class="line">    <span class="comment">// File::open 返回一个 Result&lt;File, std::io::Error&gt;</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">greeting_file</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">greeting_file</span> = <span class="keyword">match</span> greeting_file &#123;</span><br><span class="line">      <span class="title function_ invoke__">Ok</span>(file) =&gt; file,</span><br><span class="line">      <span class="title function_ invoke__">Err</span>(error) =&gt; &#123;</span><br><span class="line">         <span class="built_in">panic!</span>(<span class="string">&quot;Probled opening the file &#123;:?&#125;&quot;</span>,error) </span><br><span class="line">        &#125;, </span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果上面一行没有 panic，说明文件成功打开了</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;文件 &#x27;hello.txt&#x27; 已成功打开！&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意：如果 hello.txt 不存在，上面的 println! 永远不会执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是Rust中最简单的错误处理，通过match匹配Result&lt;&gt;成员来实现对于错误的处理，但是在上面那段程序中，当打开文件失败时，程序直接崩溃掉了，这很明显不是我们想要的结果，接下来我们引入下一个知识点 <strong>错误的匹配</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"><span class="keyword">use</span> std::io::ErrorKind;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span> = <span class="keyword">match</span> f &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(file) =&gt; file,</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(error) =&gt; <span class="keyword">match</span> error.<span class="title function_ invoke__">kind</span>() &#123;</span><br><span class="line">            ErrorKind::NotFound =&gt; <span class="keyword">match</span> File::<span class="title function_ invoke__">create</span>(<span class="string">&quot;hello.txt&quot;</span>) &#123;</span><br><span class="line">                <span class="title function_ invoke__">Ok</span>(fc) =&gt; fc,</span><br><span class="line">                <span class="title function_ invoke__">Err</span>(e) =&gt; <span class="built_in">panic!</span>(<span class="string">&quot;Problem creating the file: &#123;:?&#125;&quot;</span>, e),</span><br><span class="line">            &#125;,</span><br><span class="line">            other_error =&gt; <span class="built_in">panic!</span>(<span class="string">&quot;Problem opening the file: &#123;:?&#125;&quot;</span>, other_error),</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>File::open</code> 返回的 <code>Err</code> 成员中的值类型 <code>io::Error</code>，它是一个标准库中提供的结构体。这个结构体有一个返回 <code>io::ErrorKind</code> 值的 <code>kind</code> 方法可供调用。<code>io::ErrorKind</code> 是一个标准库提供的枚举，它的成员对应 <code>io</code> 操作可能导致的不同错误类型。我们感兴趣的成员是 <code>ErrorKind::NotFound</code>，它代表尝试打开的文件并不存在。这样，<code>match</code> 就匹配完 <code>f</code> 了，不过对于 <code>error.kind()</code> 还有一个内层 <code>match</code>。</p>
<p>我们希望在内层 <code>match</code> 中检查的条件是 <code>error.kind()</code> 的返回值是否为 <code>ErrorKind</code>的 <code>NotFound</code> 成员。如果是，则尝试通过 <code>File::create</code> 创建文件。然而因为 <code>File::create</code> 也可能会失败，还需要增加一个内层 <code>match</code> 语句。当文件不能被打开，会打印出一个不同的错误信息。外层 <code>match</code> 的最后一个分支保持不变，这样对任何除了文件不存在的错误会使程序 panic。</p>
<p>match确实是强大的，但是有时候我们确实是希望当出现错误时直接panic!掉，此时再写match会有点麻烦，Rust为我们提供了两个简写方法。</p>
<h3 id="unwrap和expect"><a href="#unwrap和expect" class="headerlink" title="unwrap和expect"></a>unwrap<code>和</code>expect</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;hello.txt&quot;</span>).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果调用这段代码时不存在 <em>hello.txt</em> 文件，我们将会看到一个 <code>unwrap</code> 调用 <code>panic!</code> 时提供的错误信息：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">thread &#x27;main&#x27; panicked at &#x27;called `Result::unwrap()` on an `Err` value: Error &#123;</span><br><span class="line">repr: Os &#123; code: 2, message: &quot;No such file or directory&quot; &#125; &#125;&#x27;,</span><br><span class="line">src/libcore/result.rs:906:4</span><br></pre></td></tr></table></figure>

<p>还有另一个类似于 <code>unwrap</code> 的方法它还允许我们选择 <code>panic!</code> 的错误信息：<code>expect</code>。使用 <code>expect</code> 而不是 <code>unwrap</code> 并提供一个好的错误信息可以表明你的意图并更易于追踪 panic 的根源。<code>expect</code> 的语法看起来像这样：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;hello.txt&quot;</span>).<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Failed to open hello.txt&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>expect</code> 与 <code>unwrap</code> 的使用方式一样：返回文件句柄或调用 <code>panic!</code> 宏。<code>expect</code> 在调用 <code>panic!</code> 时使用的错误信息将是我们传递给 <code>expect</code> 的参数，而不像 <code>unwrap</code> 那样使用默认的 <code>panic!</code> 信息。它看起来像这样：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">thread &#x27;main&#x27; panicked at &#x27;Failed to open hello.txt: Error &#123; repr: Os &#123; code:</span><br><span class="line">2, message: &quot;No such file or directory&quot; &#125; &#125;&#x27;, src/libcore/result.rs:906:4</span><br></pre></td></tr></table></figure>

<p>因为这个错误信息以我们指定的文本开始，<code>Failed to open hello.txt</code>，将会更容易找到代码中的错误信息来自何处。如果在多处使用 <code>unwrap</code>，则需要花更多的时间来分析到底是哪一个 <code>unwrap</code> 造成了 panic，因为所有的 <code>unwrap</code> 调用都打印相同的信息。</p>
<p>接下来我们就可以进入到下一个知识点 <strong>错误的传播</strong>，C语言一般都是通过返回值的层层传递来实现错误的传播。传播错误的好处就是这样能更好地控制代码调用，因为比起你代码所拥有的上下文，调用者可能拥有更多信息或逻辑来决定应该如何处理错误。</p>
<p>简单点说错误的传播就是把可能发生的错误返回给调用者，让调用者来处理而不是由被调用的函数来处理</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#![allow(unused)]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"><span class="keyword">use</span> std::io::Read;</span><br><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">read_username_from_file</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">String</span>, io::Error&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">f</span> = <span class="keyword">match</span> f &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(file) =&gt; file,</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(e) =&gt; <span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(e),</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> f.<span class="title function_ invoke__">read_to_string</span>(&amp;<span class="keyword">mut</span> s) &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(_) =&gt; <span class="title function_ invoke__">Ok</span>(s),</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(e) =&gt; <span class="title function_ invoke__">Err</span>(e),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先让我们看看函数的返回值：<code>Result&lt;String, io::Error&gt;</code>。这意味着函数返回一个 <code>Result&lt;T, E&gt;</code> 类型的值，其中泛型参数 <code>T</code> 的具体类型是 <code>String</code>，而 <code>E</code> 的具体类型是 <code>io::Error</code>。如果这个函数没有出任何错误成功返回，函数的调用者会收到一个包含 <code>String</code> 的 <code>Ok</code> 值 —— 函数从文件中读取到的用户名。如果函数遇到任何错误，函数的调用者会收到一个 <code>Err</code> 值，它储存了一个包含更多这个问题相关信息的 <code>io::Error</code> 实例。这里选择 <code>io::Error</code> 作为函数的返回值是因为它正好是函数体中那两个可能会失败的操作的错误返回值：<code>File::open</code> 函数和 <code>read_to_string</code> 方法。</p>
<p>函数体以 <code>File::open</code> 函数开头。接着使用 <code>match</code> 处理返回值 <code>Result</code>，类似于示例 9-4 中的 <code>match</code>，唯一的区别是当 <code>Err</code> 时不再调用 <code>panic!</code>，而是提早返回并将 <code>File::open</code> 返回的错误值作为函数的错误返回值传递给调用者。如果 <code>File::open</code> 成功了，我们将文件句柄储存在变量 <code>f</code> 中并继续。</p>
<p>接着我们在变量 <code>s</code> 中创建了一个新 <code>String</code> 并调用文件句柄 <code>f</code> 的 <code>read_to_string</code> 方法来将文件的内容读取到 <code>s</code> 中。<code>read_to_string</code> 方法也返回一个 <code>Result</code> 因为它也可能会失败：哪怕是 <code>File::open</code> 已经成功了。所以我们需要另一个 <code>match</code> 来处理这个 <code>Result</code>：如果 <code>read_to_string</code> 成功了，那么这个函数就成功了，并返回文件中的用户名，它现在位于被封装进 <code>Ok</code> 的 <code>s</code> 中。如果 <code>read_to_string</code> 失败了，则像之前处理 <code>File::open</code> 的返回值的 <code>match</code> 那样返回错误值。不过并不需要显式的调用 <code>return</code>，因为这是函数的最后一个表达式。</p>
<p>调用这个函数的代码最终会得到一个包含用户名的 <code>Ok</code> 值，或者一个包含 <code>io::Error</code> 的 <code>Err</code> 值。我们无从得知调用者会如何处理这些值。例如，如果他们得到了一个 <code>Err</code> 值，他们可能会选择 <code>panic!</code> 并使程序崩溃、使用一个默认的用户名或者从文件之外的地方寻找用户名。我们没有足够的信息知晓调用者具体会如何尝试，所以将所有的成功或失败信息向上传播，让他们选择合适的处理方法。</p>
<blockquote>
<p>这种写法是相当常见的，Rust也为我们提供了这种情况下可供使用的简写</p>
</blockquote>
<h3 id="传播错误的简写：-运算符"><a href="#传播错误的简写：-运算符" class="headerlink" title="传播错误的简写：? 运算符"></a>传播错误的简写：<code>?</code> 运算符</h3><p>示例 9-7 展示了一个 <code>read_username_from_file</code> 的实现，它实现了与示例 9-6 中的代码相同的功能，不过这个实现使用了 <code>?</code> 运算符：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"><span class="keyword">use</span> std::io::Read;</span><br><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">read_username_from_file</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">String</span>, io::Error&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">f</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;hello.txt&quot;</span>)?;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    f.<span class="title function_ invoke__">read_to_string</span>(&amp;<span class="keyword">mut</span> s)?;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例 9-7：一个使用 <code>?</code> 运算符向调用者返回错误的函数</p>
<p><code>Result</code> 值之后的 <code>?</code> 被定义为与示例 9-6 中定义的处理 <code>Result</code> 值的 <code>match</code> 表达式有着完全相同的工作方式。如果 <code>Result</code> 的值是 <code>Ok</code>，这个表达式将会返回 <code>Ok</code> 中的值而程序将继续执行。如果值是 <code>Err</code>，<code>Err</code> 将作为整个函数的返回值，就好像使用了 <code>return</code> 关键字一样，这样错误值就被传播给了调用者。</p>
<p>示例 9-6 中的 <code>match</code> 表达式与问号运算符所做的有一点不同：<code>?</code> 运算符所使用的错误值被传递给了 <code>from</code> 函数，它定义于标准库的 <code>From</code> trait 中，其用来将错误从一种类型转换为另一种类型。当 <code>?</code> 运算符调用 <code>from</code> 函数时，收到的错误类型被转换为由当前函数返回类型所指定的错误类型。这在当函数返回单个错误类型来代表所有可能失败的方式时很有用，即使其可能会因很多种原因失败。只要每一个错误类型都实现了 <code>from</code> 函数来定义如何将自身转换为返回的错误类型，<code>?</code> 运算符会自动处理这些转换。</p>
<p>在示例 9-7 的上下文中，<code>File::open</code> 调用结尾的 <code>?</code> 将会把 <code>Ok</code> 中的值返回给变量 <code>f</code>。如果出现了错误，<code>?</code> 运算符会提早返回整个函数并将一些 <code>Err</code> 值传播给调用者。同理也适用于 <code>read_to_string</code> 调用结尾的 <code>?</code>。</p>
<p>当你在一个不返回 <code>Result</code> 的函数中需要调用返回 <code>Result</code> 的函数时，文本提供了两种主要的修复方法：</p>
<ol>
<li><p><strong>修改当前函数的返回值类型为 <code>Result&lt;T, E&gt;</code></strong>： 这是最常见和推荐的方法，特别是当你的函数确实需要传播错误时。你将函数的签名从默认的 <code>()</code> 修改为 <code>Result&lt;T, E&gt;</code>，使得它能够兼容 <code>?</code> 运算符传播的错误。</p>
<p><strong>示例：</strong></p>
<p>Rust</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">use std::error::Error; // 引入 Error trait</span><br><span class="line">use std::fs::File;</span><br><span class="line"></span><br><span class="line">// 将 main 函数的返回值类型修改为 Result&lt;(), Box&lt;dyn Error&gt;&gt;</span><br><span class="line">fn main() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; &#123;</span><br><span class="line">    let f = File::open(&quot;hello.txt&quot;)?; // 现在 ? 运算符可以正常工作了</span><br><span class="line"></span><br><span class="line">    // ... 其他操作 ...</span><br><span class="line"></span><br><span class="line">    Ok(()) // 如果所有操作成功，返回 Ok(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong><code>-&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt;</code></strong>：这里 <code>main</code> 函数被声明为返回一个 <code>Result</code>。<ul>
<li><code>Ok(())</code> 表示成功，没有具体返回值。</li>
<li><code>Err(Box&lt;dyn Error&gt;)</code> 表示失败，并包含一个<strong>错误对象</strong>。</li>
</ul>
</li>
<li><strong><code>Box&lt;dyn Error&gt;</code></strong>：这被称为 <strong>“trait 对象”</strong>。它的作用是允许你返回<strong>任何实现了 <code>std::error::Error</code> 这个 trait 的错误类型</strong>。这是 Rust 处理“多种可能错误类型”的一种通用方法。在这里，你可以简单地理解为 <code>main</code> 函数现在可以返回任何类型的错误，只要这个错误实现了 <code>Error</code> trait。</li>
</ul>
</li>
<li><p><strong>在当前函数内使用 <code>match</code> 或 <code>Result</code> 的其他方法处理错误</strong>： 如果你不希望函数传播错误，或者函数不能修改返回值类型（例如，一些回调函数），那么你就必须在当前函数内部显式地处理 <code>Result</code>，而不是使用 <code>?</code> 运算符。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123; <span class="comment">// main 函数的返回值仍然是 ()</span></span><br><span class="line">    <span class="comment">// 使用 match 显式处理 File::open 返回的 Result</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span> = <span class="keyword">match</span> File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;hello.txt&quot;</span>) &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(file) =&gt; file,</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(e) =&gt; &#123;</span><br><span class="line">            <span class="built_in">eprintln!</span>(<span class="string">&quot;Error opening file: &#123;&#125;&quot;</span>, e); <span class="comment">// 打印错误到标准错误输出</span></span><br><span class="line">            <span class="keyword">return</span>; <span class="comment">// 如果发生错误，直接从 main 函数返回，程序终止</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;File opened successfully!&quot;</span>);</span><br><span class="line">    <span class="comment">// ... 继续使用 f ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，我们使用 <code>match</code> 语句来检查 <code>File::open</code> 的结果。如果它返回 <code>Err</code>，我们就打印错误信息并使用 <code>return;</code> 提前退出 <code>main</code> 函数。这样就没有错误需要被“传播”出 <code>main</code> 函数了。</p>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/07/25/RUST%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0%E4%B9%8B%E5%B8%B8%E8%A7%81%E9%9B%86%E5%90%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.png">
      <meta itemprop="name" content="Chillward">
      <meta itemprop="description" content="谁躺在漆黑的舞台上，用身体迎接着光芒">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chillward的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/07/25/RUST%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0%E4%B9%8B%E5%B8%B8%E8%A7%81%E9%9B%86%E5%90%88/" class="post-title-link" itemprop="url">RUST学习日记之常见集合</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-07-25 07:56:03 / 修改时间：09:33:23" itemprop="dateCreated datePublished" datetime="2025-07-25T07:56:03+08:00">2025-07-25</time>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>15k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>27 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>RUST标准库中给我们提供了很多集合,这里介绍三种最常见的:</p>
</blockquote>
<ol>
<li>vector</li>
<li>String</li>
<li>hash map</li>
</ol>
<p>可能是类似于CPP中的STL,标准库提供了一些别的数据类型,方便我们使用.</p>
<h2 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h2><p>第一个类型是 <code>Vec&lt;T&gt;</code>，也被称为 <em>vector</em>。vector 允许我们在一个单独的数据结构中储存多个值，所有值在内存中彼此相邻排列。vector 只能储存相同类型的值。它们在拥有一系列项的场景下非常实用，例如文件中的文本行或购物车中商品的价格。</p>
<h3 id="Vector的初始化"><a href="#Vector的初始化" class="headerlink" title="Vector的初始化"></a>Vector的初始化</h3><ol>
<li><code>  ler v:Vec[i32] = Vec::new();</code> 新建一个空的Vec来存储i32类型的值.</li>
<li><code>let v = vec![1,2,3];</code> 利用vec!宏来使用初始值来创建一个Vec.此时Rust可以自动推断出v的类型.</li>
</ol>
<h3 id="Vector的更新"><a href="#Vector的更新" class="headerlink" title="Vector的更新"></a>Vector的更新</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#![allow(unused)]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v</span> = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">v.<span class="title function_ invoke__">push</span>(<span class="number">5</span>);</span><br><span class="line">v.<span class="title function_ invoke__">push</span>(<span class="number">6</span>);</span><br><span class="line">v.<span class="title function_ invoke__">push</span>(<span class="number">7</span>);</span><br><span class="line">v.<span class="title function_ invoke__">push</span>(<span class="number">8</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>很明显,v.push是将值推入Vec中的方法</p>
<p>我们需要注意的一点是:与其他结构类似,当vector离开他的作用域时会被销毁,并且当存在一个有效的不可变引用时,是没办法通过push向vec中新增值的.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">first</span> = &amp;v[<span class="number">0</span>];</span><br><span class="line">v.<span class="title function_ invoke__">push</span>(<span class="number">6</span>);</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;The first element is: &#123;&#125;&quot;</span>, first);</span><br></pre></td></tr></table></figure>



<h3 id="Vector元素的读取"><a href="#Vector元素的读取" class="headerlink" title="Vector元素的读取"></a>Vector元素的读取</h3><ol>
<li>通过索引来读取值</li>
<li>通过.get来读取值</li>
</ol>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#![allow(unused)]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">third</span>: &amp;<span class="type">i32</span> = &amp;v[<span class="number">2</span>];</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;The third element is &#123;&#125;&quot;</span>, third);</span><br><span class="line"></span><br><span class="line"><span class="keyword">match</span> v.<span class="title function_ invoke__">get</span>(<span class="number">2</span>) &#123;</span><br><span class="line">    <span class="title function_ invoke__">Some</span>(third) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;The third element is &#123;&#125;&quot;</span>, third),</span><br><span class="line">    <span class="literal">None</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;There is no third element.&quot;</span>),</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里有两个需要注意的地方。首先，我们使用索引值 <code>2</code> 来获取第三个元素，索引是从 0 开始的。其次，这两个不同的获取第三个元素的方式分别为：使用 <code>&amp;</code> 和 <code>[]</code> 返回一个引用；或者使用 <code>get</code> 方法以索引作为参数来返回一个 <code>Option&lt;&amp;T&gt;</code>。</p>
<blockquote>
<p>使用.get方法可能是更优的,因为当索引越界时,.get方法会返回None,然后你就可以处理而不至于使程序崩溃</p>
</blockquote>
<h3 id="遍历Vector中的元素"><a href="#遍历Vector中的元素" class="headerlink" title="遍历Vector中的元素"></a>遍历Vector中的元素</h3><p>如果想要依次访问 vector 中的每一个元素，我们可以遍历其所有的元素而无需通过索引一次一个的访问。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">100</span>, <span class="number">32</span>, <span class="number">57</span>];</span><br><span class="line"><span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> &amp;v &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们也可以遍历可变 vector 的每一个元素的可变引用以便能改变他们。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">100</span>, <span class="number">32</span>, <span class="number">57</span>];</span><br><span class="line"><span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> &amp;<span class="keyword">mut</span> v &#123;</span><br><span class="line">    *i += <span class="number">50</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了修改可变引用所指向的值，在使用 <code>+=</code> 运算符之前必须使用解引用运算符（<code>*</code>）获取 <code>i</code> 中的值。</p>
<h3 id="使用枚举来储存多种类型"><a href="#使用枚举来储存多种类型" class="headerlink" title="使用枚举来储存多种类型"></a>使用枚举来储存多种类型</h3><p>在本章的开始，我们提到 vector 只能储存相同类型的值。这是很不方便的；绝对会有需要储存一系列不同类型的值的用例。幸运的是，枚举的成员都被定义为相同的枚举类型，所以当需要在 vector 中储存不同类型值时，我们可以定义并使用一个枚举！</p>
<p>例如，假如我们想要从电子表格的一行中获取值，而这一行的有些列包含数字，有些包含浮点值，还有些是字符串。我们可以定义一个枚举，其成员会存放这些不同类型的值，同时所有这些枚举成员都会被当作相同类型，那个枚举的类型。接着可以创建一个储存枚举值的 vector，这样最终就能够储存不同类型的值了。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">SpreadsheetCell</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Int</span>(<span class="type">i32</span>),</span><br><span class="line">    <span class="title function_ invoke__">Float</span>(<span class="type">f64</span>),</span><br><span class="line">    <span class="title function_ invoke__">Text</span>(<span class="type">String</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">row</span> = <span class="built_in">vec!</span>[</span><br><span class="line">    SpreadsheetCell::<span class="title function_ invoke__">Int</span>(<span class="number">3</span>),</span><br><span class="line">    SpreadsheetCell::<span class="title function_ invoke__">Text</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;blue&quot;</span>)),</span><br><span class="line">    SpreadsheetCell::<span class="title function_ invoke__">Float</span>(<span class="number">10.12</span>),</span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<p>Rust 在编译时就必须准确的知道 vector 中类型的原因在于它需要知道储存每个元素到底需要多少内存。第二个好处是可以准确的知道这个  vector 中允许什么类型。如果 Rust 允许 vector 存放任意类型，那么当对 vector  元素执行操作时一个或多个类型的值就有可能会造成错误。使用枚举外加 <code>match</code> 意味着 Rust 能在编译时就保证总是会处理所有可能的情况，正如第 6 章讲到的那样。</p>
<p>如果在编写程序时不能确切无遗地知道运行时会储存进 vector 的所有类型，枚举技术就行不通了。相反，你可以使用 trait 对象，第 17 章会讲到它。</p>
<p>现在我们了解了一些使用 vector 的最常见的方式，请一定去看看标准库中 <code>Vec</code> 定义的很多其他实用方法的 API 文档。例如，除了 <code>push</code> 之外还有一个 <code>pop</code> 方法，它会移除并返回 vector 的最后一个元素。</p>
<h2 id="String类型"><a href="#String类型" class="headerlink" title="String类型"></a>String类型</h2><p>在 Rust 中，字符串并非单一类型，而是通常指两种主要的 UTF-8 编码类型：<strong><code>str</code>（字符串 slice）</strong> 和 <strong><code>String</code></strong>。</p>
<p>具体来说，它涵盖了以下几个要点：</p>
<ul>
<li><strong><code>str</code> (字符串 slice)</strong>：<ul>
<li>这是 Rust <strong>核心语言</strong>中唯一的字符串类型。</li>
<li>它通常以 <strong>被借用的形式 <code>&amp;str</code></strong> 出现。</li>
<li><code>&amp;str</code> 是对储存在<strong>别处</strong>（例如程序二进制输出中的字符串字面量）的 UTF-8 编码字符串数据的<strong>引用</strong>。它们是不可变且固定大小的。</li>
</ul>
</li>
<li><strong><code>String</code></strong>：<ul>
<li>这是由 Rust <strong>标准库提供</strong>的类型，不属于核心语言。</li>
<li>它是一种<strong>可增长的、可变的、有所有权</strong>的 UTF-8 编码字符串类型。</li>
<li><code>String</code> 类型的数据存储在堆上，可以根据需要进行扩展和修改。</li>
</ul>
</li>
<li><strong>“字符串”的通用指代</strong>：<ul>
<li>当 Rust 开发者（Rustacean）提到“字符串”时，通常指的是 <strong><code>String</code> 和 <code>&amp;str</code> 这两种类型</strong>，而不是特指其中一个。</li>
<li>这两种类型在 Rust 标准库中都非常常用，且都使用 <strong>UTF-8 编码</strong>。</li>
</ul>
</li>
<li><strong>其他字符串类型</strong>：<ul>
<li>除了 <code>String</code> 和 <code>&amp;str</code>，Rust 标准库还提供了其他字符串类型，如 <code>OsString</code>、<code>OsStr</code>、<code>CString</code> 和 <code>CStr</code>。</li>
<li>这些类型通常以 <code>String</code> 或 <code>Str</code> 结尾，分别对应其所有权（<code>String</code> 变体）和可借用（<code>Str</code> 变体）的特性。</li>
<li>它们可能用于存储不同编码或内存表示形式的文本内容（例如与操作系统或 C 语言交互时）。</li>
</ul>
</li>
</ul>
<blockquote>
<p>官方文档下头这段写得还是很像人话的,我们之间复制过来,需要注意的是,rust中的字符串默认是UTF-8而不是ASCII,所以会出现一些在C语言中不会出现的问题,C语言中与之对应的知识是wchar,即宽字符.</p>
</blockquote>
<h3 id="新建字符串"><a href="#新建字符串" class="headerlink" title="新建字符串"></a><a target="_blank" rel="noopener" href="https://rustwiki.org/zh-CN/book/ch08-02-strings.html#%E6%96%B0%E5%BB%BA%E5%AD%97%E7%AC%A6%E4%B8%B2">新建字符串</a></h3><p>很多 <code>Vec</code> 可用的操作在 <code>String</code> 中同样可用，从 <code>new</code> 函数创建字符串开始，如示例 8-11 所示。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br></pre></td></tr></table></figure>

<p>示例 8-11：新建一个空的 <code>String</code></p>
<p>这新建了一个叫做 <code>s</code> 的空的字符串，接着我们可以向其中装载数据。通常字符串会有初始数据，因为我们希望一开始就有这个字符串。为此，可以使用 <code>to_string</code> 方法，它能用于任何实现了 <code>Display</code> trait 的类型，字符串字面量也实现了它。示例 8-12 展示了两个例子。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">data</span> = <span class="string">&quot;initial contents&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = data.<span class="title function_ invoke__">to_string</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 该方法也可直接用于字符串字面量：</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="string">&quot;initial contents&quot;</span>.<span class="title function_ invoke__">to_string</span>();</span><br></pre></td></tr></table></figure>

<p>示例 8-12：使用 <code>to_string</code> 方法从字符串字面量创建 <code>String</code></p>
<p>这些代码会创建包含 <code>initial contents</code> 的字符串。</p>
<p>也可以使用 <code>String::from</code> 函数来从字符串字面量创建 <code>String</code>。示例 8-13 中的代码等同于使用 <code>to_string</code>。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;initial contents&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>示例 8-13：使用 <code>String::from</code> 函数从字符串字面量创建 <code>String</code></p>
<p>因为字符串应用广泛，这里有很多不同的用于字符串的通用 API 可供选择。其中一些可能看起来多余，不过都有其用武之地！在这个例子中，<code>String::from</code> 和 <code>to_string</code> 最终做到了完全相同的事情，所以如何选择，就是风格问题了。</p>
<p>请记住，字符串是 UTF-8 编码的，所以可以包含任何正确编码的数据，如示例 8-14 所示。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">hello</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;السلام عليكم&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">hello</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Dobrý den&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">hello</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">hello</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;שָׁלוֹם&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">hello</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;नमस्ते&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">hello</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;こんにちは&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">hello</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;안녕하세요&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">hello</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;你好&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">hello</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Olá&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">hello</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Здравствуйте&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">hello</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hola&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>示例 8-14：在字符串中储存不同语言的问候语</p>
<p>所有这些都是有效的 <code>String</code> 值。</p>
<h3 id="更新字符串"><a href="#更新字符串" class="headerlink" title="更新字符串"></a><a target="_blank" rel="noopener" href="https://rustwiki.org/zh-CN/book/ch08-02-strings.html#%E6%9B%B4%E6%96%B0%E5%AD%97%E7%AC%A6%E4%B8%B2">更新字符串</a></h3><p><code>String</code> 的大小可以增加，其内容也可以改变，就像可以放入更多数据来改变 <code>Vec</code> 的内容一样。另外，可以方便的使用 <code>+</code> 运算符或 <code>format!</code> 宏来拼接 <code>String</code> 值。</p>
<h4 id="使用-push-str-和-push-附加字符串"><a href="#使用-push-str-和-push-附加字符串" class="headerlink" title="使用 push_str 和 push 附加字符串"></a><a target="_blank" rel="noopener" href="https://rustwiki.org/zh-CN/book/ch08-02-strings.html#%E4%BD%BF%E7%94%A8-push_str-%E5%92%8C-push-%E9%99%84%E5%8A%A0%E5%AD%97%E7%AC%A6%E4%B8%B2">使用 <code>push_str</code> 和 <code>push</code> 附加字符串</a></h4><p>可以通过 <code>push_str</code> 方法来附加字符串 slice，从而使 <code>String</code> 变长，如示例 8-15 所示。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line">s.<span class="title function_ invoke__">push_str</span>(<span class="string">&quot;bar&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>示例 8-15：使用 <code>push_str</code> 方法向 <code>String</code> 附加字符串 slice</p>
<p>执行这两行代码之后，<code>s</code> 将会包含 <code>foobar</code>。<code>push_str</code> 方法采用字符串 slice，因为我们并不需要获取参数的所有权。例如，示例 8-16 展示了如果将 <code>s2</code> 的内容附加到 <code>s1</code> 之后，自身不能被使用就糟糕了。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s2</span> = <span class="string">&quot;bar&quot;</span>;</span><br><span class="line">s1.<span class="title function_ invoke__">push_str</span>(s2);</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;s2 is &#123;&#125;&quot;</span>, s2);</span><br></pre></td></tr></table></figure>

<p>示例 8-16：将字符串 slice 的内容附加到 <code>String</code> 后使用它</p>
<p>如果 <code>push_str</code> 方法获取了 <code>s2</code> 的所有权，就不能在最后一行打印出其值了。好在代码如我们期望那样工作！</p>
<p><code>push</code> 方法被定义为获取一个单独的字符作为参数，并附加到 <code>String</code> 中。示例 8-17 展示了使用 <code>push</code> 方法将字母 <em>l</em> 加入 <code>String</code> 的代码。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;lo&quot;</span>);</span><br><span class="line">s.<span class="title function_ invoke__">push</span>(<span class="string">&#x27;l&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>示例 8-17：使用 <code>push</code> 将一个字符加入 <code>String</code> 值中</p>
<p>执行这些代码之后，<code>s</code> 将会包含 <code>lol</code>。</p>
<h4 id="使用-运算符或-format-宏拼接字符串"><a href="#使用-运算符或-format-宏拼接字符串" class="headerlink" title="使用 + 运算符或 format! 宏拼接字符串"></a><a target="_blank" rel="noopener" href="https://rustwiki.org/zh-CN/book/ch08-02-strings.html#%E4%BD%BF%E7%94%A8--%E8%BF%90%E7%AE%97%E7%AC%A6%E6%88%96-format-%E5%AE%8F%E6%8B%BC%E6%8E%A5%E5%AD%97%E7%AC%A6%E4%B8%B2">使用 <code>+</code> 运算符或 <code>format!</code> 宏拼接字符串</a></h4><p>通常你会希望将两个已知的字符串合并在一起。一种办法是像这样使用 <code>+</code> 运算符，如示例 8-18 所示。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello, &quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s2</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;world!&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s3</span> = s1 + &amp;s2; <span class="comment">// 注意 s1 被移动了，不能继续使用</span></span><br></pre></td></tr></table></figure>

<p>示例 8-18：使用 <code>+</code> 运算符将两个 <code>String</code> 值合并到一个新的 <code>String</code> 值中</p>
<p>执行完这些代码之后，字符串 <code>s3</code> 将会包含 <code>Hello, world!</code>。<code>s1</code> 在相加后不再有效的原因，和使用 <code>s2</code> 的引用的原因，与使用 <code>+</code> 运算符时调用的函数签名有关。<code>+</code> 运算符使用了 <code>add</code> 函数，这个函数签名看起来像这样：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">add</span>(<span class="keyword">self</span>, s: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br></pre></td></tr></table></figure>

<p>这并不是标准库中实际的签名；标准库中的 <code>add</code> 使用泛型定义。这里我们看到的 <code>add</code> 的签名使用具体类型代替了泛型，这也正是当使用 <code>String</code> 值调用这个方法会发生的。第 10 章会讨论泛型。这个签名提供了理解 <code>+</code> 运算那微妙部分的线索。</p>
<p>首先，<code>s2</code> 使用了 <code>&amp;</code>，意味着我们使用第二个字符串的 <strong>引用</strong> 与第一个字符串相加。这是因为 <code>add</code> 函数的 <code>s</code> 参数：只能将 <code>&amp;str</code> 和 <code>String</code> 相加，不能将两个 <code>String</code> 值相加。不过等一下 —— 正如 <code>add</code> 的第二个参数所指定的，<code>&amp;s2</code> 的类型是 <code>&amp;String</code> 而不是 <code>&amp;str</code>。那么为什么示例 8-18 还能编译呢？</p>
<p>之所以能够在 <code>add</code> 调用中使用 <code>&amp;s2</code> 是因为 <code>&amp;String</code> 可以被 <strong>强转</strong>（<em>coerced</em>）成 <code>&amp;str</code>。当 <code>add</code> 函数被调用时，Rust 使用了一个被称为 <strong>解引用强制转换</strong>（<em>deref coercion</em>）的技术，你可以将其理解为它把 <code>&amp;s2</code> 变成了 <code>&amp;s2[..]</code>。第 15 章会更深入的讨论解引用强制转换。因为 <code>add</code> 没有获取参数的所有权，所以 <code>s2</code> 在这个操作后仍然是有效的 <code>String</code>。</p>
<p>其次，可以发现签名中 <code>add</code> 获取了 <code>self</code> 的所有权，因为 <code>self</code> <strong>没有</strong> 使用 <code>&amp;</code>。这意味着示例 8-18 中的 <code>s1</code> 的所有权将被移动到 <code>add</code> 调用中，之后就不再有效。虽然 <code>let s3 = s1 + &amp;s2;</code> 看起来就像它会复制两个字符串并创建一个新的字符串，而实际上这个语句会获取 <code>s1</code> 的所有权，附加上从 <code>s2</code> 中拷贝的内容，并返回结果的所有权。换句话说，它看起来好像生成了很多拷贝，不过实际上并没有：这个实现比拷贝要更高效。</p>
<p>如果想要级联多个字符串，<code>+</code> 的行为就显得笨重了：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;tic&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s2</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;tac&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s3</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;toe&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = s1 + <span class="string">&quot;-&quot;</span> + &amp;s2 + <span class="string">&quot;-&quot;</span> + &amp;s3;</span><br></pre></td></tr></table></figure>

<p>这时 <code>s</code> 的内容会是 <code>tic-tac-toe</code>。在有这么多 <code>+</code> 和 <code>&quot;</code> 字符的情况下，很难理解具体发生了什么。对于更为复杂的字符串连接，可以使用 <code>format!</code> 宏：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;tic&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s2</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;tac&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s3</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;toe&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125;-&#123;&#125;-&#123;&#125;&quot;</span>, s1, s2, s3);</span><br></pre></td></tr></table></figure>

<p>这些代码也会将 <code>s</code> 设置为 “tic-tac-toe”。<code>format!</code> 与 <code>println!</code> 的工作原理相同，不过不同于将输出打印到屏幕上，它返回一个带有结果内容的 <code>String</code>。这个版本就好理解的多，并且不会获取任何参数的所有权。</p>
<h3 id="索引字符串"><a href="#索引字符串" class="headerlink" title="索引字符串"></a><a target="_blank" rel="noopener" href="https://rustwiki.org/zh-CN/book/ch08-02-strings.html#%E7%B4%A2%E5%BC%95%E5%AD%97%E7%AC%A6%E4%B8%B2">索引字符串</a></h3><p>在很多语言中，通过索引来引用字符串中的单独字符是有效且常见的操作。然而在 Rust 中，如果你尝试使用索引语法访问 <code>String</code> 的一部分，会出现一个错误。考虑一下如示例 8-19 中所示的无效代码。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">h</span> = s1[<span class="number">0</span>];</span><br></pre></td></tr></table></figure>

<p>示例 8-19：尝试对字符串使用索引语法</p>
<p>这段代码会导致如下错误：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">error[E0277]: the trait bound `std::string::String: std::ops::Index&lt;&#123;integer&#125;&gt;` is not satisfied</span><br><span class="line"> --&gt;</span><br><span class="line">  |</span><br><span class="line">3 |     let h = s1[0];</span><br><span class="line">  |             ^^^^^ the type `std::string::String` cannot be indexed by `&#123;integer&#125;`</span><br><span class="line">  |</span><br><span class="line">  = help: the trait `std::ops::Index&lt;&#123;integer&#125;&gt;` is not implemented for `std::string::String`</span><br></pre></td></tr></table></figure>

<p>错误和提示说明了全部问题：Rust 的字符串不支持索引。那么接下来的问题是，为什么不支持呢？为了回答这个问题，我们必须先聊一聊 Rust 是如何在内存中储存字符串的。</p>
<h4 id="内部表现"><a href="#内部表现" class="headerlink" title="内部表现"></a><a target="_blank" rel="noopener" href="https://rustwiki.org/zh-CN/book/ch08-02-strings.html#%E5%86%85%E9%83%A8%E8%A1%A8%E7%8E%B0">内部表现</a></h4><p><code>String</code> 是一个 <code>Vec&lt;u8&gt;</code> 的封装。让我们看看示例 8-14 中一些正确编码的字符串的例子。首先是这一个：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">len</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hola&quot;</span>).<span class="title function_ invoke__">len</span>();</span><br></pre></td></tr></table></figure>

<p>在这里，<code>len</code> 的值是 4 ，这意味着储存字符串 “Hola” 的 <code>Vec</code> 的长度是 4 个字节：这里每一个字母的 UTF-8 编码都占用 1 个字节。那下面这个例子又如何呢？（注意这个字符串中的首字母是西里尔字母的 Ze，而不是阿拉伯数字 3 。）</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">len</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Здравствуйте&quot;</span>).<span class="title function_ invoke__">len</span>();</span><br></pre></td></tr></table></figure>

<p>当问及这个字符是多长的时候有人可能会说是 12。然而，Rust 的回答是 24。这是使用 UTF-8 编码 “Здравствуйте”  所需要的字节数，这是因为每个 Unicode 标量值需要 2 个字节存储。因此一个字符串字节值的索引并不总是对应一个有效的 Unicode  标量值。作为演示，考虑如下无效的 Rust 代码：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">hello</span> = <span class="string">&quot;Здравствуйте&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">answer</span> = &amp;hello[<span class="number">0</span>];</span><br></pre></td></tr></table></figure>

<p><code>answer</code> 的值应该是什么呢？它应该是第一个字符 <code>З</code> 吗？当使用 UTF-8 编码时，<code>З</code> 的第一个字节 <code>208</code>，第二个是 <code>151</code>，所以 <code>answer</code> 实际上应该是 <code>208</code>，不过 <code>208</code> 自身并不是一个有效的字母。返回 <code>208</code> 可不是一个请求字符串第一个字母的人所希望看到的，不过它是 Rust 在字节索引 0 位置所能提供的唯一数据。用户通常不会想要一个字节值被返回，即便这个字符串只有拉丁字母： 即便 <code>&amp;&quot;hello&quot;[0]</code> 是返回字节值的有效代码，它也应当返回 <code>104</code> 而不是 <code>h</code>。为了避免返回意外的值并造成不能立刻发现的 bug，Rust 根本不会编译这些代码，并在开发过程中及早杜绝了误会的发生。</p>
<h4 id="字节、标量值和字形簇！天呐！"><a href="#字节、标量值和字形簇！天呐！" class="headerlink" title="字节、标量值和字形簇！天呐！"></a><a target="_blank" rel="noopener" href="https://rustwiki.org/zh-CN/book/ch08-02-strings.html#%E5%AD%97%E8%8A%82%E6%A0%87%E9%87%8F%E5%80%BC%E5%92%8C%E5%AD%97%E5%BD%A2%E7%B0%87%E5%A4%A9%E5%91%90">字节、标量值和字形簇！天呐！</a></h4><p>这引起了关于 UTF-8 的另外一个问题：从 Rust 的角度来讲，事实上有三种相关方式可以理解字符串：字节、标量值和字形簇（最接近人们眼中 <strong>字母</strong> 的概念）。</p>
<p>比如这个用梵文书写的印度语单词 “नमस्ते”，最终它储存在 vector 中的 <code>u8</code> 值看起来像这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[224, 164, 168, 224, 164, 174, 224, 164, 184, 224, 165, 141, 224, 164, 164, 224, 165, 135]</span><br></pre></td></tr></table></figure>

<p>这里有 18 个字节，也就是计算机最终会储存的数据。如果从 Unicode 标量值的角度理解它们，也就像 Rust 的 <code>char</code> 类型那样，这些字节看起来像这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&#x27;न&#x27;, &#x27;म&#x27;, &#x27;स&#x27;, &#x27;्&#x27;, &#x27;त&#x27;, &#x27;े&#x27;]</span><br></pre></td></tr></table></figure>

<p>这里有六个 <code>char</code>，不过第四个和第六个都不是字母，它们是发音符号本身并没有任何意义。最后，如果以字形簇的角度理解，就会得到人们所说的构成这个单词的四个字母：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&quot;न&quot;, &quot;म&quot;, &quot;स्&quot;, &quot;ते&quot;]</span><br></pre></td></tr></table></figure>

<p>Rust 提供了多种不同的方式来解释计算机储存的原始字符串数据，这样程序就可以选择它需要的表现方式，而无所谓是何种人类语言。</p>
<p>最后一个 Rust 不允许使用索引获取 <code>String</code> 字符的原因是，索引操作预期总是需要常数时间 (O(1))。但是对于 <code>String</code> 不可能保证这样的性能，因为 Rust 必须从开头到索引位置遍历来确定有多少有效的字符。</p>
<h3 id="字符串-slice"><a href="#字符串-slice" class="headerlink" title="字符串 slice"></a><a target="_blank" rel="noopener" href="https://rustwiki.org/zh-CN/book/ch08-02-strings.html#%E5%AD%97%E7%AC%A6%E4%B8%B2-slice">字符串 slice</a></h3><p>索引字符串通常是一个坏点子，因为字符串索引应该返回的类型是不明确的：字节值、字符、字形簇或者字符串  slice。因此，如果你真的希望使用索引创建字符串 slice 时，Rust 会要求你更明确一些。为了更明确索引并表明你需要一个字符串  slice，相比使用 <code>[]</code> 和单个值的索引，可以使用 <code>[]</code> 和一个 range 来创建含特定字节的字符串 slice：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">hello</span> = <span class="string">&quot;Здравствуйте&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = &amp;hello[<span class="number">0</span>..<span class="number">4</span>];</span><br></pre></td></tr></table></figure>

<p>这里，<code>s</code> 会是一个 <code>&amp;str</code>，它包含字符串的头 4 个字节。早些时候，我们提到了这些字母都是 2 个字节长的，所以这意味着 <code>s</code> 将会是 “Зд”。</p>
<p>如果获取 <code>&amp;hello[0..1]</code> 会发生什么呢？答案是：Rust 在运行时会 panic，就跟访问 vector 中的无效索引时一样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thread &#x27;main&#x27; panicked at &#x27;byte index 1 is not a char boundary; it is inside &#x27;З&#x27; (bytes 0..2) of `Здравствуйте`&#x27;, src/libcore/str/mod.rs:2188:4</span><br></pre></td></tr></table></figure>

<p>你应该小心谨慎的使用这个操作，因为这么做可能会使你的程序崩溃。</p>
<h3 id="遍历字符串的方法"><a href="#遍历字符串的方法" class="headerlink" title="遍历字符串的方法"></a><a target="_blank" rel="noopener" href="https://rustwiki.org/zh-CN/book/ch08-02-strings.html#%E9%81%8D%E5%8E%86%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%96%B9%E6%B3%95">遍历字符串的方法</a></h3><p>幸运的是，这里还有其他获取字符串元素的方式。</p>
<p>如果你需要操作单独的 Unicode 标量值，最好的选择是使用 <code>chars</code> 方法。对 “नमस्ते” 调用 <code>chars</code> 方法会将其分开并返回六个 <code>char</code> 类型的值，接着就可以遍历其结果来访问每一个元素了：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="variable">c</span> <span class="keyword">in</span> <span class="string">&quot;नमस्ते&quot;</span>.<span class="title function_ invoke__">chars</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这些代码会打印出如下内容：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">न</span><br><span class="line">म</span><br><span class="line">स</span><br><span class="line">्</span><br><span class="line">त</span><br><span class="line">े</span><br></pre></td></tr></table></figure>

<p><code>bytes</code> 方法返回每一个原始字节，这可能会适合你的使用场景：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="variable">b</span> <span class="keyword">in</span> <span class="string">&quot;नमस्ते&quot;</span>.<span class="title function_ invoke__">bytes</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这些代码会打印出组成 <code>String</code> 的 18 个字节：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">224</span></span><br><span class="line"><span class="number">164</span></span><br><span class="line"><span class="comment">// --snip--</span></span><br><span class="line"><span class="number">165</span></span><br><span class="line"><span class="number">135</span></span><br></pre></td></tr></table></figure>

<p>不过请记住有效的 Unicode 标量值可能会由不止一个字节组成。</p>
<p>从字符串中获取字形簇是很复杂的，所以标准库并没有提供这个功能。<a target="_blank" rel="noopener" href="https://crates.io/">crates.io</a> 上有些提供这样功能的 crate。</p>
<h3 id="字符串并不简单"><a href="#字符串并不简单" class="headerlink" title="字符串并不简单"></a><a target="_blank" rel="noopener" href="https://rustwiki.org/zh-CN/book/ch08-02-strings.html#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B9%B6%E4%B8%8D%E7%AE%80%E5%8D%95">字符串并不简单</a></h3><p>总而言之，字符串还是很复杂的。不同的语言选择了不同的向开发者展示其复杂性的方式。Rust 选择了以准确的方式处理 <code>String</code> 数据作为所有 Rust 程序的默认行为，这意味着开发者们必须更多的思考如何预先处理 UTF-8 数据。这种权衡取舍相比其他语言更多的暴露出了字符串的复杂性，不过也使你在开发生命周期后期免于处理涉及非 ASCII 字符的错误。</p>
<blockquote>
<p>哈希map,我在C语言编程时没怎么接触过这个东西,所以不太熟悉,等用到的时候再回来看吧</p>
</blockquote>
<h2 id="哈希-map-储存键值对"><a href="#哈希-map-储存键值对" class="headerlink" title="哈希 map 储存键值对"></a><a target="_blank" rel="noopener" href="https://rustwiki.org/zh-CN/book/ch08-03-hash-maps.html#%E5%93%88%E5%B8%8C-map-%E5%82%A8%E5%AD%98%E9%94%AE%E5%80%BC%E5%AF%B9">哈希 map 储存键值对</a></h2><p>最后介绍的常用集合类型是 <strong>哈希 map</strong>（<em>hash map</em>）。<code>HashMap&lt;K, V&gt;</code> 类型储存了一个键类型 <code>K</code> 对应一个值类型 <code>V</code> 的映射。它通过一个 <strong>哈希函数</strong>（<em>hashing function</em>）来实现映射，决定如何将键和值放入内存中。很多编程语言支持这种数据结构，不过通常有不同的名字：哈希、map、对象、哈希表或者关联数组，仅举几例。</p>
<p>哈希 map 可以用于需要任何类型作为键来寻找数据的情况，而不是像 vector 那样通过索引。例如，在一个游戏中，你可以将每个团队的分数记录到哈希 map 中，其中键是队伍的名字而值是每个队伍的分数。给出一个队名，就能得到他们的得分。</p>
<p>本章我们会介绍哈希 map 的基本 API，不过还有更多吸引人的功能隐藏于标准库在 <code>HashMap&lt;K, V&gt;</code> 上定义的函数中。一如既往请查看标准库文档来了解更多信息。</p>
<h3 id="新建一个哈希-map"><a href="#新建一个哈希-map" class="headerlink" title="新建一个哈希 map"></a><a target="_blank" rel="noopener" href="https://rustwiki.org/zh-CN/book/ch08-03-hash-maps.html#%E6%96%B0%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%93%88%E5%B8%8C-map">新建一个哈希 map</a></h3><p>可以使用 <code>new</code> 创建一个空的 <code>HashMap</code>，并使用 <code>insert</code> 增加元素。在示例 8-20 中我们记录两支队伍的分数，分别是蓝队和黄队。蓝队开始有 10 分而黄队开始有 50 分：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">scores</span> = HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line">scores.<span class="title function_ invoke__">insert</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Blue&quot;</span>), <span class="number">10</span>);</span><br><span class="line">scores.<span class="title function_ invoke__">insert</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Yellow&quot;</span>), <span class="number">50</span>);</span><br></pre></td></tr></table></figure>

<p>示例 8-20：新建一个哈希 map 并插入一些键值对</p>
<p>注意必须首先 <code>use</code> 标准库中集合部分的 <code>HashMap</code>。在这三个常用集合中，<code>HashMap</code> 是最不常用的，所以并没有被 prelude 自动引用。标准库中对 <code>HashMap</code> 的支持也相对较少，例如，并没有内建的构建宏。</p>
<p>像 vector 一样，哈希 map 将它们的数据储存在堆上，这个 <code>HashMap</code> 的键类型是 <code>String</code> 而值类型是 <code>i32</code>。类似于 vector，哈希 map 是同质的：所有的键必须是相同类型，值也必须都是相同类型。</p>
<p>另一个构建哈希 map 的方法是使用一个元组的 vector 的 <code>collect</code> 方法，其中每个元组包含一个键值对。<code>collect</code> 方法可以将数据收集进一系列的集合类型，包括 <code>HashMap</code>。例如，如果队伍的名字和初始分数分别在两个 vector 中，可以使用 <code>zip</code> 方法来创建一个元组的 vector，其中 “Blue” 与 10 是一对，依此类推。接着就可以使用 <code>collect</code> 方法将这个元组 vector 转换成一个 <code>HashMap</code>，如示例 8-21 所示：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">teams</span>  = <span class="built_in">vec!</span>[<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Blue&quot;</span>), <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Yellow&quot;</span>)];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">initial_scores</span> = <span class="built_in">vec!</span>[<span class="number">10</span>, <span class="number">50</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">scores</span>: HashMap&lt;_, _&gt; = teams.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">zip</span>(initial_scores.<span class="title function_ invoke__">iter</span>()).<span class="title function_ invoke__">collect</span>();</span><br></pre></td></tr></table></figure>

<p>示例 8-21：用队伍列表和分数列表创建哈希 map</p>
<p>这里 <code>HashMap&lt;_, _&gt;</code> 类型标注是必要的，因为 <code>collect</code> 有可能当成多种不同的数据结构，而除非显式指定否则 Rust 无从得知你需要的类型。但是对于键和值的类型参数来说，可以使用下划线占位，而 Rust 能够根据 vector 中数据的类型推断出 <code>HashMap</code> 所包含的类型。</p>
<h3 id="哈希-map-和所有权"><a href="#哈希-map-和所有权" class="headerlink" title="哈希 map 和所有权"></a><a target="_blank" rel="noopener" href="https://rustwiki.org/zh-CN/book/ch08-03-hash-maps.html#%E5%93%88%E5%B8%8C-map-%E5%92%8C%E6%89%80%E6%9C%89%E6%9D%83">哈希 map 和所有权</a></h3><p>对于像 <code>i32</code> 这样的实现了 <code>Copy</code> trait 的类型，其值可以拷贝进哈希 map。对于像 <code>String</code> 这样拥有所有权的值，其值将被移动而哈希 map 会成为这些值的所有者，如示例 8-22 所示：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">field_name</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Favorite color&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">field_value</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Blue&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">map</span> = HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line">map.<span class="title function_ invoke__">insert</span>(field_name, field_value);</span><br><span class="line"><span class="comment">// 这里 field_name 和 field_value 不再有效，</span></span><br><span class="line"><span class="comment">// 尝试使用它们看看会出现什么编译错误！</span></span><br></pre></td></tr></table></figure>

<p>示例 8-22：展示一旦键值对被插入后就为哈希 map 所拥有</p>
<p>当 <code>insert</code> 调用将 <code>field_name</code> 和 <code>field_value</code> 移动到哈希 map 中后，将不能使用这两个绑定。</p>
<p>如果将值的引用插入哈希 map，这些值本身将不会被移动进哈希 map。但是这些引用指向的值必须至少在哈希 map 有效时也是有效的。第 10 章 <a target="_blank" rel="noopener" href="https://rustwiki.org/zh-CN/book/ch10-03-lifetime-syntax.html#validating-references-with-lifetimes">“生命周期与引用有效性”</a> 部分将会更多的讨论这个问题。</p>
<h3 id="访问哈希-map-中的值"><a href="#访问哈希-map-中的值" class="headerlink" title="访问哈希 map 中的值"></a><a target="_blank" rel="noopener" href="https://rustwiki.org/zh-CN/book/ch08-03-hash-maps.html#%E8%AE%BF%E9%97%AE%E5%93%88%E5%B8%8C-map-%E4%B8%AD%E7%9A%84%E5%80%BC">访问哈希 map 中的值</a></h3><p>可以通过 <code>get</code> 方法并提供对应的键来从哈希 map 中获取值，如示例 8-23 所示：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">scores</span> = HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line">scores.<span class="title function_ invoke__">insert</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Blue&quot;</span>), <span class="number">10</span>);</span><br><span class="line">scores.<span class="title function_ invoke__">insert</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Yellow&quot;</span>), <span class="number">50</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">team_name</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Blue&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">score</span> = scores.<span class="title function_ invoke__">get</span>(&amp;team_name);</span><br></pre></td></tr></table></figure>

<p>示例 8-23：访问哈希 map 中储存的蓝队分数</p>
<p>这里，<code>score</code> 是与蓝队分数相关的值，应为 <code>Some(10)</code>。因为 <code>get</code> 返回 <code>Option&lt;V&gt;</code>，所以结果被装进 <code>Some</code>；如果某个键在哈希 map 中没有对应的值，<code>get</code> 会返回 <code>None</code>。这时就要用某种第 6 章提到的方法之一来处理 <code>Option</code>。</p>
<p>可以使用与 vector 类似的方式来遍历哈希 map 中的每一个键值对，也就是 <code>for</code> 循环：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">scores</span> = HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line">scores.<span class="title function_ invoke__">insert</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Blue&quot;</span>), <span class="number">10</span>);</span><br><span class="line">scores.<span class="title function_ invoke__">insert</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Yellow&quot;</span>), <span class="number">50</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (key, value) <span class="keyword">in</span> &amp;scores &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;: &#123;&#125;&quot;</span>, key, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这会以任意顺序打印出每一个键值对：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Yellow: <span class="number">50</span></span><br><span class="line">Blue: <span class="number">10</span></span><br></pre></td></tr></table></figure>

<h3 id="更新哈希-map"><a href="#更新哈希-map" class="headerlink" title="更新哈希 map"></a><a target="_blank" rel="noopener" href="https://rustwiki.org/zh-CN/book/ch08-03-hash-maps.html#%E6%9B%B4%E6%96%B0%E5%93%88%E5%B8%8C-map">更新哈希 map</a></h3><p>尽管键值对的数量是可以增长的，不过任何时候，每个键只能关联一个值。当我们想要改变哈希 map 中的数据时，必须决定如何处理一个键已经有值了的情况。可以选择完全无视旧值并用新值代替旧值。可以选择保留旧值而忽略新值，并只在键 <strong>没有</strong> 对应值时增加新值。或者可以结合新旧两值。让我们看看这分别该如何处理！</p>
<h4 id="覆盖一个值"><a href="#覆盖一个值" class="headerlink" title="覆盖一个值"></a><a target="_blank" rel="noopener" href="https://rustwiki.org/zh-CN/book/ch08-03-hash-maps.html#%E8%A6%86%E7%9B%96%E4%B8%80%E4%B8%AA%E5%80%BC">覆盖一个值</a></h4><p>如果我们插入了一个键值对，接着用相同的键插入一个不同的值，与这个键相关联的旧值将被替换。即便示例 8-24 中的代码调用了两次 <code>insert</code>，哈希 map 也只会包含一个键值对，因为两次都是对蓝队的键插入的值：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">scores</span> = HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line">scores.<span class="title function_ invoke__">insert</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Blue&quot;</span>), <span class="number">10</span>);</span><br><span class="line">scores.<span class="title function_ invoke__">insert</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Blue&quot;</span>), <span class="number">25</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, scores);</span><br></pre></td></tr></table></figure>

<p>示例 8-24：替换以特定键储存的值</p>
<p>这会打印出 <code>&#123;&quot;Blue&quot;: 25&#125;</code>。原始的值 <code>10</code> 则被覆盖了。</p>
<h4 id="只在键没有对应值时插入"><a href="#只在键没有对应值时插入" class="headerlink" title="只在键没有对应值时插入"></a><a target="_blank" rel="noopener" href="https://rustwiki.org/zh-CN/book/ch08-03-hash-maps.html#%E5%8F%AA%E5%9C%A8%E9%94%AE%E6%B2%A1%E6%9C%89%E5%AF%B9%E5%BA%94%E5%80%BC%E6%97%B6%E6%8F%92%E5%85%A5">只在键没有对应值时插入</a></h4><p>我们经常会检查某个特定的键是否有值，如果没有就插入一个值。为此哈希 map 有一个特有的 API，叫做 <code>entry</code>，它获取我们想要检查的键作为参数。<code>entry</code> 函数的返回值是一个枚举，<code>Entry</code>，它代表了可能存在也可能不存在的值。比如说我们想要检查黄队的键是否关联了一个值。如果没有，就插入值 50，对于蓝队也是如此。使用 entry API 的代码看起来像示例 8-25 这样：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">scores</span> = HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line">scores.<span class="title function_ invoke__">insert</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Blue&quot;</span>), <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">scores.<span class="title function_ invoke__">entry</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Yellow&quot;</span>)).<span class="title function_ invoke__">or_insert</span>(<span class="number">50</span>);</span><br><span class="line">scores.<span class="title function_ invoke__">entry</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Blue&quot;</span>)).<span class="title function_ invoke__">or_insert</span>(<span class="number">50</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, scores);</span><br></pre></td></tr></table></figure>

<p>示例 8-25：使用 <code>entry</code> 方法只在键没有对应一个值时插入</p>
<p><code>Entry</code> 的 <code>or_insert</code> 方法在键对应的值存在时就返回这个值的可变引用，如果不存在则将参数作为新值插入并返回新值的可变引用。这比编写自己的逻辑要简明的多，另外也与借用检查器结合得更好。</p>
<p>运行示例 8-25 的代码会打印出 <code>&#123;&quot;Yellow&quot;: 50, &quot;Blue&quot;: 10&#125;</code>。第一个 <code>entry</code> 调用会插入黄队的键和值 <code>50</code>，因为黄队并没有一个值。第二个 <code>entry</code> 调用不会改变哈希 map 因为蓝队已经有了值 <code>10</code>。</p>
<h4 id="根据旧值更新一个值"><a href="#根据旧值更新一个值" class="headerlink" title="根据旧值更新一个值"></a><a target="_blank" rel="noopener" href="https://rustwiki.org/zh-CN/book/ch08-03-hash-maps.html#%E6%A0%B9%E6%8D%AE%E6%97%A7%E5%80%BC%E6%9B%B4%E6%96%B0%E4%B8%80%E4%B8%AA%E5%80%BC">根据旧值更新一个值</a></h4><p>另一个常见的哈希 map 的应用场景是找到一个键对应的值并根据旧的值更新它。例如，示例 8-26  中的代码计数一些文本中每一个单词分别出现了多少次。我们使用哈希 map  以单词作为键并递增其值来记录我们遇到过几次这个单词。如果是第一次看到某个单词，就插入值 <code>0</code>。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">text</span> = <span class="string">&quot;hello world wonderful world&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">map</span> = HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="variable">word</span> <span class="keyword">in</span> text.<span class="title function_ invoke__">split_whitespace</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">count</span> = map.<span class="title function_ invoke__">entry</span>(word).<span class="title function_ invoke__">or_insert</span>(<span class="number">0</span>);</span><br><span class="line">    *count += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, map);</span><br></pre></td></tr></table></figure>

<p>示例 8-26：通过哈希 map 储存单词和计数来统计出现次数</p>
<p>这会打印出 <code>&#123;&quot;world&quot;: 2, &quot;hello&quot;: 1, &quot;wonderful&quot;: 1&#125;</code>，<code>or_insert</code> 方法事实上会返回这个键的值的一个可变引用（<code>&amp;mut V</code>）。这里我们将这个可变引用储存在 <code>count</code> 变量中，所以为了赋值必须首先使用星号（<code>*</code>）解引用 <code>count</code>。这个可变引用在 <code>for</code> 循环的结尾离开作用域，这样所有这些改变都是安全的并符合借用规则。</p>
<h3 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a><a target="_blank" rel="noopener" href="https://rustwiki.org/zh-CN/book/ch08-03-hash-maps.html#%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0">哈希函数</a></h3><p><code>HashMap</code> 默认使用一种 “密码学安全的”（“cryptographically strong” ）<a target="_blank" rel="noopener" href="https://rustwiki.org/zh-CN/book/ch08-03-hash-maps.html#siphash">1</a> 哈希函数，它可以抵抗拒绝服务（Denial of Service, DoS）攻击。然而这并不是可用的最快的算法，不过为了更高的安全性值得付出一些性能的代价。如果性能监测显示此哈希函数非常慢，以致于你无法接受，你可以指定一个不同的 <em>hasher</em> 来切换为其它函数。hasher 是一个实现了 <code>BuildHasher</code> trait 的类型。第 10 章会讨论 trait 和如何实现它们。你并不需要从头开始实现你自己的 hasher；<a target="_blank" rel="noopener" href="https://crates.io/">crates.io</a> 有其他人分享的实现了许多常用哈希算法的 hasher 的库。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/07/24/RUST%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0%E4%B9%8B%E6%A8%A1%E5%9D%9703/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.png">
      <meta itemprop="name" content="Chillward">
      <meta itemprop="description" content="谁躺在漆黑的舞台上，用身体迎接着光芒">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chillward的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/07/24/RUST%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0%E4%B9%8B%E6%A8%A1%E5%9D%9703/" class="post-title-link" itemprop="url">RUST学习日记之模块03</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-07-24 18:11:52 / 修改时间：19:07:46" itemprop="dateCreated datePublished" datetime="2025-07-24T18:11:52+08:00">2025-07-24</time>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>9.8k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>18 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>我们依旧先来欣赏一下官方的高速神言,这一节官方主要就是讲了一下 use as还有pub use这三个东西</p>
</blockquote>
<h2 id="使用-use-关键字将名称引入作用域"><a href="#使用-use-关键字将名称引入作用域" class="headerlink" title="使用 use 关键字将名称引入作用域"></a><a target="_blank" rel="noopener" href="https://rustwiki.org/zh-CN/book/ch07-04-bringing-paths-into-scope-with-the-use-keyword.html#%E4%BD%BF%E7%94%A8-use-%E5%85%B3%E9%94%AE%E5%AD%97%E5%B0%86%E5%90%8D%E7%A7%B0%E5%BC%95%E5%85%A5%E4%BD%9C%E7%94%A8%E5%9F%9F">使用 <code>use</code> 关键字将名称引入作用域</a></h2><p>到目前为止，似乎我们编写的用于调用函数的路径都很冗长且重复，并不方便。例如，示例 7-7 中，无论我们选择 <code>add_to_waitlist</code> 函数的绝对路径还是相对路径，每次我们想要调用 <code>add_to_waitlist</code> 时，都必须指定 <code>front_of_house</code> 和 <code>hosting</code>。幸运的是，有一种方法可以简化这个过程。我们可以使用 <code>use</code> 关键字将路径一次性引入作用域，然后调用该路径中的项，就如同它们是本地项一样。</p>
<p>在示例 7-11 中，我们将 <code>crate::front_of_house::hosting</code> 模块引入了 <code>eat_at_restaurant</code> 函数的作用域，而我们只需要指定 <code>hosting::add_to_waitlist</code> 即可在 <code>eat_at_restaurant</code> 中调用 <code>add_to_waitlist</code> 函数。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">mod</span> front_of_house &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">mod</span> hosting &#123;</span><br><span class="line">        <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">add_to_waitlist</span>() &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> crate::front_of_house::hosting;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">eat_at_restaurant</span>() &#123;</span><br><span class="line">    hosting::<span class="title function_ invoke__">add_to_waitlist</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例 7-11: 使用 <code>use</code> 将模块引入作用域</p>
<p>在作用域中增加 <code>use</code> 和路径类似于在文件系统中创建软连接（符号连接，symbolic link）。通过在 crate 根增加 <code>use crate::front_of_house::hosting</code>，现在 <code>hosting</code> 在作用域中就是有效的名称了，如同 <code>hosting</code> 模块被定义于 crate 根一样。通过 <code>use</code> 引入作用域的路径也会检查私有性，同其它路径一样。</p>
<p>你还可以使用 <code>use</code> 和相对路径来将一个项引入作用域。示例 7-12 展示了如何指定相对路径来取得与示例 7-11 中一样的行为。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">mod</span> front_of_house &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">mod</span> hosting &#123;</span><br><span class="line">        <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">add_to_waitlist</span>() &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> front_of_house::hosting;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">eat_at_restaurant</span>() &#123;</span><br><span class="line">    hosting::<span class="title function_ invoke__">add_to_waitlist</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例 7-12: 使用 <code>use</code> 和相对路径将模块引入作用域</p>
<h3 id="创建惯用的-use-路径"><a href="#创建惯用的-use-路径" class="headerlink" title="创建惯用的 use 路径"></a><a target="_blank" rel="noopener" href="https://rustwiki.org/zh-CN/book/ch07-04-bringing-paths-into-scope-with-the-use-keyword.html#%E5%88%9B%E5%BB%BA%E6%83%AF%E7%94%A8%E7%9A%84-use-%E8%B7%AF%E5%BE%84">创建惯用的 <code>use</code> 路径</a></h3><p>在示例 7-11 中，你可能会比较疑惑，为什么我们是指定 <code>use crate::front_of_house::hosting</code>，然后在 <code>eat_at_restaurant</code> 中调用 <code>hosting::add_to_waitlist</code>，而不是通过指定一直到 <code>add_to_waitlist</code> 函数的 <code>use</code> 路径来得到相同的结果，如示例 7-13 所示。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">mod</span> front_of_house &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">mod</span> hosting &#123;</span><br><span class="line">        <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">add_to_waitlist</span>() &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> crate::front_of_house::hosting::add_to_waitlist;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">eat_at_restaurant</span>() &#123;</span><br><span class="line">    <span class="title function_ invoke__">add_to_waitlist</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例 7-13: 使用 <code>use</code> 将 <code>add_to_waitlist</code> 函数引入作用域，这并不符合习惯</p>
<p>虽然示例 7-11 和 7-13 都完成了相同的任务，但示例 7-11 是使用 <code>use</code> 将函数引入作用域的习惯用法。使用 <code>use</code> 将函数的父模块引入作用域意味着我们必须在调用函数时指定父模块，这样可以清晰地表明函数不是在本地定义的，同时使完整路径的重复度最小化。示例 7-13 中的代码则未表明 <code>add_to_waitlist</code> 是在哪里被定义的。</p>
<p>另一方面，使用 <code>use</code> 引入结构体、枚举和其他项时，习惯是指定它们的完整路径。示例 7-14 展示了将 <code>HashMap</code> 结构体引入二进制 crate 作用域的习惯用法。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">map</span> = HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    map.<span class="title function_ invoke__">insert</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例 7-14: 将 <code>HashMap</code> 引入作用域的习惯用法</p>
<p>这种习惯用法背后没有什么硬性要求：它只是一种惯例，人们已经习惯了以这种方式阅读和编写 Rust 代码。</p>
<blockquote>
<p>其实也就说了这么些内容</p>
</blockquote>
<p><strong>使用 <code>use</code> 引入函数时，习惯上是将函数的父模块引入作用域。</strong> 这样，在调用函数时，你需要写 <code>父模块::函数名()</code>，比如 <code>hosting::add_to_waitlist()</code>。这样做的好处是，可以清晰地表明这个函数不是当前模块定义的，同时避免了每次都写完整的冗长路径。</p>
<p><strong>使用 <code>use</code> 引入结构体、枚举或其他项时，习惯上是直接引入到该项本身。</strong> 这样，你可以直接使用该项的名称，比如 <code>HashMap::new()</code>。</p>
<p>这个习惯用法有一个例外，那就是我们想使用 <code>use</code> 语句将两个具有相同名称的项带入作用域，因为 Rust 不允许这样做。示例 7-15 展示了如何将两个具有相同名称但不同父模块的 <code>Result</code> 类型引入作用域，以及如何引用它们。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">use</span> std::fmt;</span><br><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">function1</span>() <span class="punctuation">-&gt;</span> fmt::<span class="type">Result</span> &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">function2</span>() <span class="punctuation">-&gt;</span> io::<span class="type">Result</span>&lt;()&gt; &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例 7-15: 使用父模块将两个具有相同名称的类型引入同一作用域</p>
<p>如你所见，使用父模块可以区分这两个 <code>Result</code> 类型。如果我们是指定 <code>use std::fmt::Result</code> 和 <code>use std::io::Result</code>，我们将在同一作用域拥有了两个 <code>Result</code> 类型，当我们使用 <code>Result</code> 时，Rust 则不知道我们要用的是哪个。</p>
<blockquote>
<p>接下来就是引入 as</p>
</blockquote>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fmt::<span class="type">Result</span>;</span><br><span class="line"><span class="keyword">use</span> std::io::<span class="type">Result</span> <span class="keyword">as</span> IoResult;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">function1</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span> &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">function2</span>() <span class="punctuation">-&gt;</span> IoResult&lt;()&gt; &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　这个其实看两眼也就明白了,不用什么复杂的解释</p>
<p>然后还有pub use,我的理解就是你自己编写的模块中通过use引用了别的模块的内容,想要使这些内容可以被引用你模块的人使用的话,就需要pub use语句</p>
<blockquote>
<p>以下是ai给出的解释</p>
</blockquote>
<p><code>pub use</code> 的核心作用，正是你描述的这个场景：当你编写一个模块（或者库）时，你可能会<strong>在内部 <code>use</code> 其他模块或类型</strong>来方便自己使用。但是，如果你希望<strong>使用你这个模块的外部代码</strong>也能通过你的模块路径来访问这些被你 <code>use</code> 进来的内容，那么你就需要使用 <code>pub use</code>。</p>
<p>简单来说：</p>
<ul>
<li><strong><code>use</code>：</strong> 仅仅是你自己模块内部的“快捷方式”，方便你在本模块中使用。外部模块无法通过你的模块来访问这些被 <code>use</code> 进来的东西。</li>
<li><strong><code>pub use</code>：</strong> 不仅创建了内部的“快捷方式”，还<strong>公开了</strong>这个快捷方式。这样，外部模块就可以通过你的模块路径来访问这个被重导出的内容，就好像这些内容就是你模块自己定义的一样。</li>
</ul>
<p>这就像是你开了一家商店（你的模块），你从批发商那里进了些商品（其他模块的内容）。</p>
<ul>
<li>如果你只是自己用（<code>use</code>），这些商品就在你的库房里，只有你能看到。</li>
<li>但如果你想把这些商品摆在你的店里卖（<code>pub use</code>），那么顾客（外部代码）就可以通过你的商店来购买这些商品了，他们甚至不需要知道你最初是从哪个批发商那里进的货。</li>
</ul>
<p><code>pub use</code> 允许你提供一个更清晰、更简洁的 API 给你的用户，同时隐藏了你内部的组织结构,语法如下:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> front_of_house &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">mod</span> hosting &#123;</span><br><span class="line">        <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">add_to_waitlist</span>() &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">use</span> crate::front_of_house::hosting;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">eat_at_restaurant</span>() &#123;</span><br><span class="line">    hosting::<span class="title function_ invoke__">add_to_waitlist</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>还剩下一些杂七杂八的东西</p>
<p>下面是这段内容讲的三个主要“玩意儿”：</p>
<ul>
<li><p>你问得很好！这段内容主要围绕着如何在 Rust 项目中使用外部包（crate）以及如何优化 <code>use</code> 语句来管理这些引入的依赖。</p>
<p>下面是这段内容讲的三个主要“玩意儿”：</p>
<h3 id="1-如何使用外部包（Crate）"><a href="#1-如何使用外部包（Crate）" class="headerlink" title="1. 如何使用外部包（Crate）"></a>1. 如何使用外部包（Crate）</h3><p>Rust 项目使用 <strong>Cargo</strong> 这个构建系统和包管理器来管理依赖。</p>
<ul>
<li><p><strong>声明依赖：</strong> 当你需要使用一个外部包时（比如 <code>rand</code>），你需要在项目的 <code>Cargo.toml</code> 文件中的 <code>[dependencies]</code> 部分添加这个包的名称和版本号。Cargo 会自动从 <strong>crates.io</strong>（Rust 社区的包注册表）下载这个包及其所有必要的依赖。</p>
<p>Ini, TOML</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[dependencies]</span><br><span class="line">rand = &quot;0.8.3&quot; # 示例：声明对rand包的依赖</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>引入作用域：</strong> 仅仅声明依赖还不够。你还需要使用 <code>use</code> 关键字，以 <strong>绝对路径</strong> 的方式将外部包中你想要使用的特定项（函数、结构体、trait 等）引入到你的代码的作用域中，这样你才能直接使用它们。</p>
<p>Rust</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use rand::Rng; // 将rand包中的Rng trait引入作用域</span><br></pre></td></tr></table></figure>

<p>值得注意的是，<strong>标准库 (<code>std</code>)</strong> 也是一个特殊的外部 crate。虽然你不需要在 <code>Cargo.toml</code> 中声明它，但你仍然需要使用 <code>use</code> 语句来引入 <code>std</code> 中你想要使用的项，例如 <code>use std::collections::HashMap;</code>。</p>
</li>
</ul>
<h3 id="2-优化-use-语句：嵌套路径"><a href="#2-优化-use-语句：嵌套路径" class="headerlink" title="2. 优化 use 语句：嵌套路径"></a>2. 优化 <code>use</code> 语句：嵌套路径</h3><p>当你的代码需要从同一个模块或同一个包中引入多个项时，逐行 <code>use</code> 会让代码变得冗长。Rust 提供了 <strong>嵌套路径</strong> 的语法来简化这个过程。</p>
<ul>
<li><p><strong>基本嵌套：</strong> 如果多个项共享同一个路径前缀，你可以将它们用大括号 <code>&#123;&#125;</code> 包裹起来。</p>
<p>Rust</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 之前：</span><br><span class="line">// use std::cmp::Ordering;</span><br><span class="line">// use std::io;</span><br><span class="line"></span><br><span class="line">// 之后：一行搞定</span><br><span class="line">use std::&#123;cmp::Ordering, io&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>self</code> 关键字：</strong> 当你想引入一个模块本身，同时又想引入这个模块下的某个子项时，可以在嵌套路径中使用 <code>self</code> 关键字。</p>
<p>Rust</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 之前：</span><br><span class="line">// use std::io;</span><br><span class="line">// use std::io::Write;</span><br><span class="line"></span><br><span class="line">// 之后：一行搞定，同时引入了io模块和io::Write</span><br><span class="line">use std::io::&#123;self, Write&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="3-引入所有公有定义：Glob-运算符"><a href="#3-引入所有公有定义：Glob-运算符" class="headerlink" title="3. 引入所有公有定义：Glob 运算符 *"></a>3. 引入所有公有定义：Glob 运算符 <code>*</code></h3><p>如果你想将一个模块下所有 <strong>公有</strong> 的项都引入到当前作用域，可以使用 <strong>glob 运算符 <code>\*</code></strong>。</p>
<ul>
<li><p><strong>用法：</strong> 在路径的末尾加上 <code>*</code>。</p>
<p>Rust</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use std::collections::*; // 引入std::collections模块中所有的公有项</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>注意事项：</strong> 尽管方便，但使用 glob 运算符时需要<strong>谨慎</strong>。它会使代码的可读性降低，因为你很难一眼看出某个名称是来自哪里，可能会导致名称冲突。它通常在测试模块（为了方便测试所有功能）或特定模式（如 <code>prelude</code> 模式）中使用。</p>
</li>
</ul>
<p>这里还有，并提供了两种技巧 (<code>&#123;&#125;</code> 嵌套路径和 <code>*</code> glob 运算符) 来更简洁地管理 <code>use</code> 语句，从而提高代码的可读性和维护性。</p>
<p>这段代码展示了 Rust 中更细粒度的可见性控制，也就是如何使用 <code>pub(in path)</code>、<code>pub(self)</code> 和 <code>pub(super)</code> 来限制一个项（比如函数）的可见范围。</p>
<h3 id="深入理解-Rust-的可见性控制"><a href="#深入理解-Rust-的可见性控制" class="headerlink" title="深入理解 Rust 的可见性控制"></a>深入理解 Rust 的可见性控制</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个名为 `my_mod` 的模块</span></span><br><span class="line"><span class="keyword">mod</span> my_mod &#123;</span><br><span class="line">    <span class="comment">// 模块中的项默认具有私有的可见性</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">private_function</span>() &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;called `my_mod::private_function()`&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 `pub` 修饰语来改变默认可见性。</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">function</span>() &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;called `my_mod::function()`&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在同一模块中，项可以访问其它项，即使它是私有的。</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">indirect_access</span>() &#123;</span><br><span class="line">        <span class="built_in">print!</span>(<span class="string">&quot;called `my_mod::indirect_access()`, that\n&gt; &quot;</span>);</span><br><span class="line">        <span class="title function_ invoke__">private_function</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模块也可以嵌套</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">mod</span> nested &#123;</span><br><span class="line">        <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">function</span>() &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;called `my_mod::nested::function()`&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">#[allow(dead_code)]</span></span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">private_function</span>() &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;called `my_mod::nested::private_function()`&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用 `pub(in path)` 语法定义的函数只在给定的路径中可见。</span></span><br><span class="line">        <span class="comment">// `path` 必须是父模块（parent module）或祖先模块（ancestor module）</span></span><br><span class="line">        <span class="title function_ invoke__">pub</span>(<span class="keyword">in</span> crate::my_mod) <span class="keyword">fn</span> <span class="title function_">public_function_in_my_mod</span>() &#123;</span><br><span class="line">            <span class="built_in">print!</span>(<span class="string">&quot;called `my_mod::nested::public_function_in_my_mod()`, that\n &gt; &quot;</span>);</span><br><span class="line">            <span class="title function_ invoke__">public_function_in_nested</span>()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用 `pub(self)` 语法定义的函数则只在当前模块中可见。</span></span><br><span class="line">        <span class="title function_ invoke__">pub</span>(<span class="keyword">self</span>) <span class="keyword">fn</span> <span class="title function_">public_function_in_nested</span>() &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;called `my_mod::nested::public_function_in_nested&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用 `pub(super)` 语法定义的函数只在父模块中可见。</span></span><br><span class="line">        <span class="title function_ invoke__">pub</span>(<span class="keyword">super</span>) <span class="keyword">fn</span> <span class="title function_">public_function_in_super_mod</span>() &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;called my_mod::nested::public_function_in_super_mod&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">call_public_function_in_my_mod</span>() &#123;</span><br><span class="line">        <span class="built_in">print!</span>(<span class="string">&quot;called `my_mod::call_public_funcion_in_my_mod()`, that\n&gt; &quot;</span>);</span><br><span class="line">        nested::<span class="title function_ invoke__">public_function_in_my_mod</span>();</span><br><span class="line">        <span class="built_in">print!</span>(<span class="string">&quot;&gt; &quot;</span>);</span><br><span class="line">        nested::<span class="title function_ invoke__">public_function_in_super_mod</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// `pub(crate)` 使得函数只在当前 crate 中可见</span></span><br><span class="line">    <span class="title function_ invoke__">pub</span>(<span class="keyword">crate</span>) <span class="keyword">fn</span> <span class="title function_">public_function_in_crate</span>() &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;called `my_mod::public_function_in_crate()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 嵌套模块的可见性遵循相同的规则</span></span><br><span class="line">    <span class="keyword">mod</span> private_nested &#123;</span><br><span class="line">        <span class="meta">#[allow(dead_code)]</span></span><br><span class="line">        <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">function</span>() &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;called `my_mod::private_nested::function()`&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">function</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;called `function()`&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// 模块机制消除了相同名字的项之间的歧义。</span></span><br><span class="line">    <span class="title function_ invoke__">function</span>();</span><br><span class="line">    my_mod::<span class="title function_ invoke__">function</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 公有项，包括嵌套模块内的，都可以在父模块外部访问。</span></span><br><span class="line">    my_mod::<span class="title function_ invoke__">indirect_access</span>();</span><br><span class="line">    my_mod::nested::<span class="title function_ invoke__">function</span>();</span><br><span class="line">    my_mod::<span class="title function_ invoke__">call_public_function_in_my_mod</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// pub(crate) 项可以在同一个 crate 中的任何地方访问</span></span><br><span class="line">    my_mod::<span class="title function_ invoke__">public_function_in_crate</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// pub(in path) 项只能在指定的模块中访问</span></span><br><span class="line">    <span class="comment">// 报错！函数 `public_function_in_my_mod` 是私有的</span></span><br><span class="line">    <span class="comment">//my_mod::nested::public_function_in_my_mod();</span></span><br><span class="line">    <span class="comment">// 试一试 ^ 取消该行的注释</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模块的私有项不能直接访问，即便它是嵌套在公有模块内部的</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 报错！`private_function` 是私有的</span></span><br><span class="line">    <span class="comment">//my_mod::private_function();</span></span><br><span class="line">    <span class="comment">// 试一试 ^ 取消此行注释</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 报错！`private_function` 是私有的</span></span><br><span class="line">    <span class="comment">//my_mod::nested::private_function();</span></span><br><span class="line">    <span class="comment">// 试一试 ^ 取消此行的注释</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Error! `private_nested` is a private module</span></span><br><span class="line">    <span class="comment">//my_mod::private_nested::function();</span></span><br><span class="line">    <span class="comment">// 试一试 ^ 取消此行的注释</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>默认情况下，Rust 中的所有项（函数、结构体、枚举、模块等）都是私有的。要让它们在当前作用域之外可见，你需要使用 <code>pub</code> 关键字。然而，简单的 <code>pub</code> 意味着对<strong>所有</strong>外部代码都可见，这在某些情况下可能过于宽松。</p>
<p><code>pub(in path)</code>、<code>pub(self)</code> 和 <code>pub(super)</code> 提供了一种方式，让你能够更精确地控制项的可见性，而不是简单地“完全公开”或“完全私有”。</p>
<h4 id="1-pub-in-crate-my-mod-：指定路径可见性"><a href="#1-pub-in-crate-my-mod-：指定路径可见性" class="headerlink" title="1. pub(in crate::my_mod)：指定路径可见性"></a>1. <code>pub(in crate::my_mod)</code>：指定路径可见性</h4><p>这个语法允许你将一个项的可见性限制在指定的路径（模块）内部。</p>
<ul>
<li><p><strong><code>pub(in crate::my_mod) fn public_function_in_my_mod()</code></strong></p>
<ul>
<li>这意味着 <code>public_function_in_my_mod</code> 这个函数只在 <strong><code>crate::my_mod</code> 模块及其子模块内部可见和可调用</strong>。</li>
<li>在 <code>my_mod</code> 外部的代码，即使 <code>my_mod</code> 本身是公开的，也无法直接调用 <code>public_mod::nested::public_function_in_my_mod</code>。</li>
<li><code>path</code> 必须是该项的父模块或祖先模块。你不能指定一个与当前项没有继承关系的模块。</li>
</ul>
<p><strong>想象一下：</strong> 你有一个家族企业，<code>my_mod</code> 是总公司。这个函数就像是只有总公司内部的员工（包括子公司员工）才能使用的特定工具。外部客户即使知道总公司存在，也无法直接使用这个工具。</p>
</li>
</ul>
<h4 id="2-pub-self-：当前模块可见性"><a href="#2-pub-self-：当前模块可见性" class="headerlink" title="2. pub(self)：当前模块可见性"></a>2. <code>pub(self)</code>：当前模块可见性</h4><p><code>pub(self)</code> 将可见性限制在定义该项的<strong>当前模块</strong>内部。</p>
<ul>
<li><p><strong><code>pub(self) fn public_function_in_nested()</code></strong></p>
<ul>
<li>这意味着 <code>public_function_in_nested</code> 这个函数只在 <code>my_mod::nested</code> <strong>模块内部可见</strong>。</li>
<li>即使在 <code>my_mod</code> 模块内部（<code>nested</code> 的父模块），也无法直接调用 <code>public_function_in_nested</code>。只有在 <code>nested</code> 模块内部的代码才能调用它。</li>
</ul>
<p><strong>想象一下：</strong> <code>nested</code> 是公司里的一个特定部门。<code>public_function_in_nested</code> 就像是这个部门内部的专用流程，只有这个部门的员工才能使用。总公司或其他部门的员工都不能直接调用这个流程。</p>
</li>
</ul>
<h4 id="3-pub-super-：父模块可见性"><a href="#3-pub-super-：父模块可见性" class="headerlink" title="3. pub(super)：父模块可见性"></a>3. <code>pub(super)</code>：父模块可见性</h4><p><code>pub(super)</code> 将可见性限制在定义该项的<strong>父模块</strong>内部。</p>
<ul>
<li><p><strong><code>pub(super) fn public_function_in_super_mod()</code></strong></p>
<ul>
<li>这意味着 <code>public_function_in_super_mod</code> 这个函数只在 <code>my_mod</code> <strong>模块内部可见</strong>。</li>
<li>尽管它定义在 <code>nested</code> 模块中，但它只对 <code>nested</code> 的父模块（即 <code>my_mod</code>）可见。<code>nested</code> 模块内部也能调用它，因为父模块的可见性范围包含了子模块。</li>
</ul>
<p><strong>想象一下：</strong> 仍然是公司里的一个部门 <code>nested</code>。<code>public_function_in_super_mod</code> 就像是这个部门为总公司（<code>my_mod</code>）提供的内部服务，总公司可以直接调用，但其他部门或外部客户不能直接调用。</p>
</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">function</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;called `function()`&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">mod</span> cool &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">function</span>() &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;called `cool::function()`&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">mod</span> my &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">function</span>() &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;called `my::function()`&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">mod</span> cool &#123;</span><br><span class="line">        <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">function</span>() &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;called `my::cool::function()`&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">indirect_call</span>() &#123;</span><br><span class="line">        <span class="comment">// 让我们从这个作用域中访问所有名为 `function` 的函数！</span></span><br><span class="line">        <span class="built_in">print!</span>(<span class="string">&quot;called `my::indirect_call()`, that\n&gt; &quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// `self` 关键字表示当前的模块作用域——在这个例子是 `my`。</span></span><br><span class="line">        <span class="comment">// 调用 `self::function()` 和直接调用 `function()` 都得到相同的结果，</span></span><br><span class="line">        <span class="comment">// 因为他们表示相同的函数。</span></span><br><span class="line">        self::<span class="title function_ invoke__">function</span>();</span><br><span class="line">        <span class="title function_ invoke__">function</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 我们也可以使用 `self` 来访问 `my` 内部的另一个模块：</span></span><br><span class="line">        self::cool::<span class="title function_ invoke__">function</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// `super` 关键字表示父作用域（在 `my` 模块外面）。</span></span><br><span class="line">        super::<span class="title function_ invoke__">function</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 这将在 *crate* 作用域内绑定 `cool::function` 。</span></span><br><span class="line">        <span class="comment">// 在这个例子中，crate 作用域是最外面的作用域。</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">use</span> crate::cool::function <span class="keyword">as</span> root_function;</span><br><span class="line">            <span class="title function_ invoke__">root_function</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    my::<span class="title function_ invoke__">indirect_call</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这些细粒度的可见性控制非常有用，它们允许你：</p>
<ul>
<li><strong>封装内部实现细节：</strong> 将一些只应该在特定范围内部使用的函数或数据隐藏起来，避免外部滥用或不当修改。</li>
<li><strong>构建清晰的 API：</strong> 明确哪些部分是库的公共接口，哪些是内部辅助功能。</li>
<li><strong>增强代码安全性：</strong> 限制了对某些敏感操作的访问。</li>
</ul>
<p>RUST的这个模块管理系统真的挺复杂的,估计得在实战中用它两回才能真正学得会.</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/07/24/RUST%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0%E4%B9%8B%E6%A8%A1%E5%9D%9702/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.png">
      <meta itemprop="name" content="Chillward">
      <meta itemprop="description" content="谁躺在漆黑的舞台上，用身体迎接着光芒">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chillward的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/07/24/RUST%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0%E4%B9%8B%E6%A8%A1%E5%9D%9702/" class="post-title-link" itemprop="url">RUST学习日记之模块02</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-07-24 10:23:54 / 修改时间：18:10:05" itemprop="dateCreated datePublished" datetime="2025-07-24T10:23:54+08:00">2025-07-24</time>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>11k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>21 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="路径用于引用模块树中的项"><a href="#路径用于引用模块树中的项" class="headerlink" title="路径用于引用模块树中的项"></a>路径用于引用模块树中的项</h2><p>来看一下 Rust 如何在模块树中找到一个项的位置，我们使用路径的方式，就像在文件系统使用路径一样。如果我们想要调用一个函数，我们需要知道它的路径。</p>
<p>路径有两种形式：</p>
<ul>
<li><strong>绝对路径</strong>（<em>absolute path</em>）从 crate 根部开始，以 crate 名或者字面量 <code>crate</code> 开头。</li>
<li><strong>相对路径</strong>（<em>relative path</em>）从当前模块开始，以 <code>self</code>、<code>super</code> 或当前模块的标识符开头。</li>
</ul>
<p>绝对路径和相对路径都后跟一个或多个由双冒号（<code>::</code>）分割的标识符。</p>
<p>让我们回到示例 7-1。我们如何调用 <code>add_to_waitlist</code> 函数？还是同样的问题，<code>add_to_waitlist</code> 函数的路径是什么？在示例 7-3 中，我们通过删除一些模块和函数，稍微简化了一下我们的代码。我们在 crate 根部定义了一个新函数 <code>eat_at_restaurant</code>，并在其中展示调用 <code>add_to_waitlist</code> 函数的两种方法。<code>eat_at_restaurant</code> 函数是我们 crate 库的一个公共 API，所以我们使用 <code>pub</code> 关键字来标记它。在<a target="_blank" rel="noopener" href="https://rustwiki.org/zh-CN/book/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html#%E4%BD%BF%E7%94%A8-pub-%E5%85%B3%E9%94%AE%E5%AD%97%E6%9A%B4%E9%9C%B2%E8%B7%AF%E5%BE%84">“使用 <code>pub</code> 关键字暴露路径”</a>一节，我们将详细介绍 <code>pub</code>。注意，这个例子无法编译通过，我们稍后会解释原因。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">mod</span> front_of_house &#123;</span><br><span class="line">    <span class="keyword">mod</span> hosting &#123;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">add_to_waitlist</span>() &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">eat_at_restaurant</span>() &#123;</span><br><span class="line">    <span class="comment">// 绝对路径</span></span><br><span class="line">    crate::front_of_house::hosting::<span class="title function_ invoke__">add_to_waitlist</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 相对路径</span></span><br><span class="line">    front_of_house::hosting::<span class="title function_ invoke__">add_to_waitlist</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例 7-3: 使用绝对路径和相对路径来调用 <code>add_to_waitlist</code> 函数</p>
<p>第一种方式，我们在 <code>eat_at_restaurant</code> 中调用 <code>add_to_waitlist</code> 函数，使用的是绝对路径。<code>add_to_waitlist</code> 函数与 <code>eat_at_restaurant</code> 被定义在同一 crate 中，这意味着我们可以使用 <code>crate</code> 关键字为起始的绝对路径。</p>
<p>在 <code>crate</code> 后面，我们持续地嵌入模块，直到我们找到 <code>add_to_waitlist</code>。你可以想象出一个相同结构的文件系统，我们通过指定路径 <code>/front_of_house/hosting/add_to_waitlist</code> 来执行 <code>add_to_waitlist</code> 程序。我们使用 <code>crate</code> 从 crate 根部开始就类似于在 shell 中使用 <code>/</code> 从文件系统根开始。</p>
<p>第二种方式，我们在 <code>eat_at_restaurant</code> 中调用 <code>add_to_waitlist</code>，使用的是相对路径。这个路径以 <code>front_of_house</code> 为起始，这个模块在模块树中，与 <code>eat_at_restaurant</code> 定义在同一层级。与之等价的文件系统路径就是 <code>front_of_house/hosting/add_to_waitlist</code>。以名称为起始，意味着该路径是相对路径。</p>
<p>选择使用相对路径还是绝对路径，还是要取决于你的项目。取决于你是更倾向于将项的定义代码与使用该项的代码分开来移动，还是一起移动。举一个例子，如果我们要将 <code>front_of_house</code> 模块和 <code>eat_at_restaurant</code> 函数一起移动到一个名为 <code>customer_experience</code> 的模块中，我们需要更新 <code>add_to_waitlist</code> 的绝对路径，但是相对路径还是可用的。然而，如果我们要将 <code>eat_at_restaurant</code> 函数单独移到一个名为 <code>dining</code> 的模块中，还是可以使用原本的绝对路径来调用 <code>add_to_waitlist</code>，但是相对路径必须要更新。我们更倾向于使用绝对路径，因为把代码定义和项调用各自独立地移动是更常见的。</p>
<blockquote>
<p>官方依旧高速神言不说人话</p>
</blockquote>
<p>我们用 C 语言的例子来类比一下 Rust 中“把代码定义和项调用各自独立地移动是更常见的”这句话。</p>
<p>在 C 语言中，我们没有像 Rust 这样的模块系统，但我们可以用<strong>头文件（.h）</strong> 和 <strong>源文件（.c）</strong> 来类比“定义”和“调用”以及“路径”。</p>
<h3 id="C-语言中的类比"><a href="#C-语言中的类比" class="headerlink" title="C 语言中的类比"></a>C 语言中的类比</h3><p>想象你有两个 C 文件：</p>
<ol>
<li><p><strong><code>math_operations.h</code> 和 <code>math_operations.c</code></strong>：</p>
<ul>
<li><p><code>math_operations.h</code> (头文件)：声明了 <code>add</code> 函数。这就像 Rust 中一个模块的公开接口，告诉别人有这么一个函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// math_operations.h</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>; <span class="comment">// 这是函数的“定义”或“声明”</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>math_operations.c</code> (源文件)：实现了 <code>add</code> 函数。这是函数的具体“定义”所在。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// math_operations.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;math_operations.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong><code>main.c</code></strong>：</p>
<ul>
<li>这个文件会<strong>调用</strong> <code>add</code> 函数。</li>
</ul>
</li>
</ol>
<h4 id="场景一：类似-Rust-中的绝对路径（使用完整路径-包含完整头文件）"><a href="#场景一：类似-Rust-中的绝对路径（使用完整路径-包含完整头文件）" class="headerlink" title="场景一：类似 Rust 中的绝对路径（使用完整路径&#x2F;包含完整头文件）"></a>场景一：类似 Rust 中的<strong>绝对路径</strong>（使用完整路径&#x2F;包含完整头文件）</h4><p>在 <code>main.c</code> 中，如果你想要使用 <code>add</code> 函数，你会这么做：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;math_operations.h&quot;</span> <span class="comment">// 告诉编译器去哪里找 add 函数的声明</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> result = add(<span class="number">5</span>, <span class="number">3</span>); <span class="comment">// 调用 add 函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里，<code>#include &quot;math_operations.h&quot;</code> 就像 Rust 中的<strong>绝对路径</strong>。它明确地指明了 <code>add</code> 函数的声明在哪里可以找到。</p>
<ul>
<li><strong>如果我移动 <code>main.c</code> 文件（调用者）</strong>：假设你把 <code>main.c</code> 从项目的一个子目录移动到另一个子目录，只要 <code>math_operations.h</code> 的相对位置没有改变，或者你通过编译器的 <code>-I</code> 选项（include path）告诉了编译器 <code>math_operations.h</code> 的新位置，那么 <code>main.c</code> 中 <code>add(5, 3)</code> 的调用<strong>不需要修改</strong>。因为 <code>add</code> 函数的定义（和声明）本身没有移动。这和 Rust 中绝对路径的稳定性类似。</li>
</ul>
<h4 id="场景二：类似-Rust-中的相对路径（如果-C-语言有这种直接模块引用）"><a href="#场景二：类似-Rust-中的相对路径（如果-C-语言有这种直接模块引用）" class="headerlink" title="场景二：类似 Rust 中的相对路径（如果 C 语言有这种直接模块引用）"></a>场景二：类似 Rust 中的<strong>相对路径</strong>（如果 C 语言有这种直接模块引用）</h4><p>C 语言没有像 Rust 这样内建的相对模块路径引用机制。但我们可以想象一种情况，如果你需要在 <code>main.c</code> 中<strong>直接引用</strong> <code>add</code> 函数的定义，而不是通过头文件。这在 C 语言中是做不到的，但为了类比，我们可以假设：</p>
<p>如果 <code>main.c</code> 直接依赖于 <code>math_operations.c</code> 文件的<strong>相对位置</strong>来找到 <code>add</code> 函数的定义（这是个假设，C 实际编译不是这样做的）。那么：</p>
<ul>
<li><strong>如果我移动 <code>main.c</code> 文件（调用者）</strong>：<code>main.c</code> 的位置变了，它与 <code>math_operations.c</code> 的相对位置就可能变了。那么，原先的“相对路径”就失效了，你<strong>需要修改</strong> <code>main.c</code> 中引用 <code>add</code> 函数的方式。</li>
</ul>
<h3 id="“各自独立移动”的含义"><a href="#“各自独立移动”的含义" class="headerlink" title="“各自独立移动”的含义"></a>“各自独立移动”的含义</h3><p>回到 Rust 的语境：</p>
<p>“把代码定义和项调用各自独立地移动是更常见的”这句话意味着：</p>
<ol>
<li><strong>你更常会移动和重构使用某个功能（<code>add</code> 函数）的代码文件（<code>main.c</code>），而不是改变那个功能本身（<code>math_operations.c</code> 和 <code>math_operations.h</code>）的存放位置。</strong></li>
<li>当你移动 <code>main.c</code> 时，你希望它里面的 <code>add(5, 3)</code> 调用能够<strong>保持不变</strong>，而不需要每次移动都去修改它。</li>
</ol>
<p>因此，使用 <strong>绝对路径</strong>（类似 C 语言中 <code>#include &lt;library_header.h&gt;</code> 或者通过 <code>-I</code> 选项找到的头文件）会更稳定。因为它从一个固定的起点（Rust 的 crate 根部）开始寻找，<strong>不依赖于你当前调用代码（<code>main.c</code>）的位置</strong>。即使你把 <code>main.c</code> 移动到项目的其他地方，只要 <code>add</code> 函数的定义没有从它原来的“绝对位置”移动，那么对它的引用就依然有效。</p>
<p>而 <strong>相对路径</strong>，由于它的起点是“当前模块”，一旦你移动了当前模块，相对位置就变了，路径就可能失效，需要你手动更新。</p>
<p>所以，Rust 建议我们倾向于使用绝对路径，因为它在代码重构时，特别是当调用方代码移动时，能够减少你需要修改的引用路径的数量，从而提高代码的维护性和稳定性。</p>
<blockquote>
<p>简而言之就是绝对路径更好用,OK,接下来我们继续欣赏官方文档的高速神言</p>
</blockquote>
<p>让我们试着编译一下示例 7-3，并查明为何不能编译！示例 7-4 展示了这个错误。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ cargo build</span><br><span class="line">   Compiling restaurant v0.1.0 (file:///projects/restaurant)</span><br><span class="line">error[E0603]: module `hosting` is private</span><br><span class="line"> --&gt; src/lib.rs:9:28</span><br><span class="line">  |</span><br><span class="line">9 |     crate::front_of_house::hosting::add_to_waitlist();</span><br><span class="line">  |                            ^^^^^^^ private module</span><br><span class="line">  |</span><br><span class="line">note: the module `hosting` is defined here</span><br><span class="line"> --&gt; src/lib.rs:2:5</span><br><span class="line">  |</span><br><span class="line">2 |     mod hosting &#123;</span><br><span class="line">  |     ^^^^^^^^^^^</span><br><span class="line"></span><br><span class="line">error[E0603]: module `hosting` is private</span><br><span class="line">  --&gt; src/lib.rs:12:21</span><br><span class="line">   |</span><br><span class="line">12 |     front_of_house::hosting::add_to_waitlist();</span><br><span class="line">   |                     ^^^^^^^ private module</span><br><span class="line">   |</span><br><span class="line">note: the module `hosting` is defined here</span><br><span class="line">  --&gt; src/lib.rs:2:5</span><br><span class="line">   |</span><br><span class="line">2  |     mod hosting &#123;</span><br><span class="line">   |     ^^^^^^^^^^^</span><br><span class="line"></span><br><span class="line">For more information about this error, try `rustc --explain E0603`.</span><br><span class="line">error: could not compile `restaurant` due to 2 previous errors</span><br></pre></td></tr></table></figure>

<p>示例 7-4: 构建示例 7-3 出现的编译器错误</p>
<p>错误信息说 <code>hosting</code> 模块是私有的。换句话说，我们拥有 <code>hosting</code> 模块和 <code>add_to_waitlist</code> 函数的的正确路径，但是 Rust 不让我们使用，因为它不能访问私有片段。</p>
<p>模块不仅对于你组织代码很有用。他们还定义了 Rust 的 <em>私有性边界</em>（<em>privacy boundary</em>）：这条界线不允许外部代码了解、调用和依赖被封装的实现细节。所以，如果你希望创建一个私有函数或结构体，你可以将其放入模块。</p>
<p>Rust  中默认所有项（函数、方法、结构体、枚举、模块和常量）都是私有的。父模块中的项不能使用子模块中的私有项，但是子模块中的项可以使用他们父模块中的项。这是因为子模块封装并隐藏了他们的实现详情，但是子模块可以看到他们定义的上下文。继续拿餐馆作比喻，把私有性规则想象成餐馆的后台办公室：餐馆内的事务对餐厅顾客来说是不可知的，但办公室经理可以洞悉其经营的餐厅并在其中做任何事情。</p>
<p>Rust 选择以这种方式来实现模块系统功能，因此默认隐藏内部实现细节。这样一来，你就知道可以更改内部代码的哪些部分而不会破坏外部代码。你还可以通过使用 <code>pub</code> 关键字来创建公共项，使子模块的内部部分暴露给上级模块。</p>
<blockquote>
<p>接下来主要就是引出PUB关键字,需要注意PUB关键字对于结构体,枚举,函数的作用是不太一样的,需要分辨一下</p>
</blockquote>
<h3 id="使用-pub-关键字暴露路径"><a href="#使用-pub-关键字暴露路径" class="headerlink" title="使用 pub 关键字暴露路径"></a>使用 <code>pub</code> 关键字暴露路径</h3><p>让我们回头看一下示例 7-4 的错误，它告诉我们 <code>hosting</code> 模块是私有的。我们想让父模块中的 <code>eat_at_restaurant</code> 函数可以访问子模块中的 <code>add_to_waitlist</code> 函数，因此我们使用 <code>pub</code> 关键字来标记 <code>hosting</code> 模块，如示例 7-5 所示。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> front_of_house &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">mod</span> hosting &#123;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">add_to_waitlist</span>() &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">eat_at_restaurant</span>() &#123;</span><br><span class="line">    <span class="comment">// 绝对路径</span></span><br><span class="line">    crate::front_of_house::hosting::<span class="title function_ invoke__">add_to_waitlist</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 相对路径</span></span><br><span class="line">    front_of_house::hosting::<span class="title function_ invoke__">add_to_waitlist</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例 7-5: 使用 <code>pub</code> 关键字声明 <code>hosting</code> 模块使其可在 <code>eat_at_restaurant</code> 使用</p>
<p>不幸的是，示例 7-5 的代码编译仍然有错误，如示例 7-6 所示。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ cargo build</span><br><span class="line">   Compiling restaurant v0.1.0 (file:///projects/restaurant)</span><br><span class="line">error[E0603]: function `add_to_waitlist` is private</span><br><span class="line"> --&gt; src/lib.rs:9:37</span><br><span class="line">  |</span><br><span class="line">9 |     crate::front_of_house::hosting::add_to_waitlist();</span><br><span class="line">  |                                     ^^^^^^^^^^^^^^^ private function</span><br><span class="line">  |</span><br><span class="line">note: the function `add_to_waitlist` is defined here</span><br><span class="line"> --&gt; src/lib.rs:3:9</span><br><span class="line">  |</span><br><span class="line">3 |         fn add_to_waitlist() &#123;&#125;</span><br><span class="line">  |         ^^^^^^^^^^^^^^^^^^^^</span><br><span class="line"></span><br><span class="line">error[E0603]: function `add_to_waitlist` is private</span><br><span class="line">  --&gt; src/lib.rs:12:30</span><br><span class="line">   |</span><br><span class="line">12 |     front_of_house::hosting::add_to_waitlist();</span><br><span class="line">   |                              ^^^^^^^^^^^^^^^ private function</span><br><span class="line">   |</span><br><span class="line">note: the function `add_to_waitlist` is defined here</span><br><span class="line">  --&gt; src/lib.rs:3:9</span><br><span class="line">   |</span><br><span class="line">3  |         fn add_to_waitlist() &#123;&#125;</span><br><span class="line">   |         ^^^^^^^^^^^^^^^^^^^^</span><br><span class="line"></span><br><span class="line">For more information about this error, try `rustc --explain E0603`.</span><br><span class="line">error: could not compile `restaurant` due to 2 previous errors</span><br></pre></td></tr></table></figure>

<p>示例 7-6: 构建示例 7-5 出现的编译器错误</p>
<p>发生了什么？在 <code>mod hosting</code> 前添加了 <code>pub</code> 关键字，使其变成公有的。伴随着这种变化，如果我们可以访问 <code>front_of_house</code>，那我们也可以访问 <code>hosting</code>。但是 <code>hosting</code> 的 <strong>内容</strong>（<em>contents</em>） 仍然是私有的；这表明<strong>使模块公有并不使其内容也是公有的。模块上的 <code>pub</code> 关键字只允许其父模块引用它。</strong></p>
<p>示例 7-6 中的错误说，<code>add_to_waitlist</code> 函数是私有的。私有性规则不但应用于模块，还应用于结构体、枚举、函数和方法。</p>
<p>让我们继续将 <code>pub</code> 关键字放置在 <code>add_to_waitlist</code> 函数的定义之前，使其变成公有。如示例 7-7 所示。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">mod</span> front_of_house &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">mod</span> hosting &#123;</span><br><span class="line">        <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">add_to_waitlist</span>() &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">eat_at_restaurant</span>() &#123;</span><br><span class="line">    <span class="comment">// 绝对路径</span></span><br><span class="line">    crate::front_of_house::hosting::<span class="title function_ invoke__">add_to_waitlist</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 相对路径</span></span><br><span class="line">    front_of_house::hosting::<span class="title function_ invoke__">add_to_waitlist</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例 7-7: 为 <code>mod hosting</code> 和 <code>fn add_to_waitlist</code> 添加 <code>pub</code> 关键字使他们可以在 <code>eat_at_restaurant</code> 函数中被调用</p>
<p>现在代码可以编译通过了！让我们看看绝对路径和相对路径，并根据私有性规则，再检查一下为什么增加 <code>pub</code> 关键字使得我们可以在 <code>add_to_waitlist</code> 中调用这些路径。</p>
<p>在绝对路径，我们从 <code>crate</code>，也就是 crate 根部开始。然后 crate 根部中定义了 <code>front_of_house</code> 模块。<code>front_of_house</code> 模块不是公有的，不过因为 <code>eat_at_restaurant</code> 函数与 <code>front_of_house</code> 定义于同一模块中（即，<code>eat_at_restaurant</code> 和 <code>front_of_house</code> 是兄弟），我们可以从 <code>eat_at_restaurant</code> 中引用 <code>front_of_house</code>。接下来是使用 <code>pub</code> 标记的 <code>hosting</code> 模块。我们可以访问 <code>hosting</code> 的父模块，所以可以访问 <code>hosting</code>。最后，<code>add_to_waitlist</code> 函数被标记为 <code>pub</code> ，我们可以访问其父模块，所以这个函数调用是有效的！</p>
<p>在相对路径，其逻辑与绝对路径相同，除了第一步：不同于从 crate 根部开始，路径从 <code>front_of_house</code> 开始。<code>front_of_house</code> 模块与 <code>eat_at_restaurant</code> 定义于同一模块，所以从 <code>eat_at_restaurant</code> 中开始定义的该模块相对路径是有效的。接下来因为 <code>hosting</code> 和 <code>add_to_waitlist</code> 被标记为 <code>pub</code>，路径其余的部分也是有效的，因此函数调用也是有效的！</p>
<blockquote>
<p>我们来仔细讨论一下上面这段话</p>
</blockquote>
<p><strong><code>front_of_house</code> 在你提供的代码中不是私有的，它是默认公开的，因为它是直接在 <code>crate</code> 根部定义的。</strong></p>
<p>Rust 的访问规则有点绕，我们来具体解释一下：</p>
<h3 id="crate-根部定义的模块默认是公开的"><a href="#crate-根部定义的模块默认是公开的" class="headerlink" title="crate 根部定义的模块默认是公开的"></a><code>crate</code> 根部定义的模块默认是公开的</h3><p>当你直接在 <code>src/lib.rs</code> (或者 <code>src/main.rs</code>) 文件中定义一个模块时，比如 <code>mod front_of_house &#123;&#125;</code>，这个模块就是定义在 <code>crate</code> 的<strong>根部</strong>。</p>
<p><strong>在 <code>crate</code> 根部定义的项（包括模块），默认情况下是可以在整个 <code>crate</code> 内部被直接访问到的。</strong> 它们不需要 <code>pub</code> 关键字就可以被同一 <code>crate</code> 中的其他代码访问。<code>pub</code> 关键字的作用是让该项可以被<strong>外部 <code>crate</code></strong> (比如你的库被其他项目引用时) 访问，或者让该项可以被<strong>子模块之外的模块</strong>通过完整路径访问。</p>
<p>所以，<code>front_of_house</code> 模块虽然没有显式地写 <code>pub mod front_of_house &#123;&#125;</code>，但因为它直接位于 <code>crate</code> 根部，所以：</p>
<ol>
<li><strong><code>eat_at_restaurant</code> 函数</strong>（也在 <code>crate</code> 根部）可以直接看到并访问 <code>front_of_house</code>，因为它们是“兄弟”关系，都在最外层。</li>
<li><strong><code>crate::</code></strong> 作为绝对路径的起点，它自然也能直接“看到”它根部定义的所有内容，包括 <code>front_of_house</code>。</li>
</ol>
<h3 id="为什么会产生误解？"><a href="#为什么会产生误解？" class="headerlink" title="为什么会产生误解？"></a>为什么会产生误解？</h3><p>你可能误解了“私有”的含义。在 Rust 中，一个模块（或任何项）如果没有 <code>pub</code> 关键字，它通常表示该项只在其<strong>直接父模块内部</strong>可见和可访问。但是，这个规则对于 <strong><code>crate</code> 根部</strong>有点特殊。<code>crate</code> 根部本身就是最高层级，它里面定义的所有东西对于整个 <code>crate</code> 内部的代码来说，都是默认可访问的，除非它们被嵌套在某个私有模块内部。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong><code>front_of_house</code> 模块</strong>：因为它直接定义在 <code>crate</code> 根部（<code>src/lib.rs</code> 的顶层），所以默认情况下，这个 <code>crate</code> 内部的所有代码都可以直接看到并引用它。它不是“私有的”，而是对 <code>crate</code> 内部可见的。</li>
<li><strong><code>pub mod hosting</code></strong>：这里 <code>pub</code> 的作用是让 <code>hosting</code> 模块可以被 <code>front_of_house</code> 之外的代码（比如 <code>eat_at_restaurant</code>，它位于 <code>front_of_house</code> 的父级 <code>crate</code> 根部）访问。如果没有 <code>pub</code>，那么 <code>hosting</code> 默认就是私有的，只有 <code>front_of_house</code> 内部的代码才能访问它。</li>
<li><strong><code>pub fn add_to_waitlist()</code></strong>：函数默认是私有的。如果你想从它所在的模块外面调用它，就必须给它加上 <code>pub</code>。</li>
</ul>
<p>所以，<code>crate</code> 可以访问到 <code>front_of_house</code> 是因为 <code>front_of_house</code> 就在 <code>crate</code> 根部，并且对于 <code>crate</code> 内部是默认可见的。</p>
<blockquote>
<p>依旧AI大法</p>
</blockquote>
<hr>
<p>是的，<strong>默认情况下，模块外部无法直接访问 <code>front_of_house</code> 模块的内容。</strong></p>
<p>让我们用刚才的餐厅例子再来说明一下：</p>
<p>你的 Rust 项目是个大餐厅，<code>front_of_house</code> 是餐厅里“前厅”这个区域。</p>
<ul>
<li><strong>默认情况下（没有 <code>pub</code>）</strong>：这个“前厅”是餐厅内部的一个区域，它里面的具体设施（比如某个柜台、某个角落）默认都是“不对外开放”的。只有当你身处“前厅”内部，或者你被“前厅”的主管（父模块）特许，才能使用里面的东西。外部的顾客（其他 <code>crate</code>）或者甚至餐厅内部其他区域的员工（其他模块）都不能直接走进“前厅”去拿里面的东西，除非前厅的某个门是打开的（<code>pub</code>）。</li>
<li><strong>为什么 <code>crate::front_of_house</code> 可以访问到？</strong><ul>
<li>因为 <code>front_of_house</code> 是直接定义在你的 <code>crate</code>（也就是整个餐厅）的“大厅”（根部）里的。</li>
<li>所以，当你从“大厅”出发（<code>crate::</code>）时，你自然能看到“大厅”里所有的区域划分，包括 <code>front_of_house</code>。这就像你站在餐厅大堂中央，能看到哪里是“前厅”，哪里是“厨房”。</li>
<li>但是，能看到这个区域，不代表你就能直接使用这个区域里的所有东西。要使用里面的东西，里面的东西本身也必须是公开的。</li>
</ul>
</li>
</ul>
<p>所以，结论是：</p>
<p>如果你想让 <strong><code>front_of_house</code> 模块内部的</strong> 某个函数或结构体被**<code>front_of_house</code> 模块外部**的代码访问（比如被 <code>eat_at_restaurant</code> 访问，或者被另一个 <code>crate</code> 访问），那么：</p>
<ol>
<li><strong><code>front_of_house</code> 模块</strong>本身需要是可访问的（因为它直接在 <code>crate</code> 根部，所以它对 <code>crate</code> 内部是默认可见的）。</li>
<li><strong><code>front_of_house</code> 内部的子模块或函数&#x2F;结构体</strong>也必须使用 <strong><code>pub</code> 关键字</strong> 来声明，才能让外部通过完整路径访问到它们。</li>
</ol>
<p>这就是为什么在示例中，你不仅要给 <code>hosting</code> 加上 <code>pub</code>，还要给 <code>add_to_waitlist</code> 加上 <code>pub</code>，才能让 <code>eat_at_restaurant</code> 最终调用到它。</p>
<h3 id="使用-super-起始的相对路径"><a href="#使用-super-起始的相对路径" class="headerlink" title="使用 super 起始的相对路径"></a><a target="_blank" rel="noopener" href="https://rustwiki.org/zh-CN/book/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html#%E4%BD%BF%E7%94%A8-super-%E8%B5%B7%E5%A7%8B%E7%9A%84%E7%9B%B8%E5%AF%B9%E8%B7%AF%E5%BE%84">使用 <code>super</code> 起始的相对路径</a></h3><p>我们还可以使用 <code>super</code> 开头来构建从父模块开始的相对路径。这么做类似于文件系统中以 <code>..</code> 开头的语法。我们为什么要这样做呢？</p>
<p>考虑一下示例 7-8 中的代码，它模拟了厨师更正了一个错误订单，并亲自将其提供给客户的情况。<code>fix_incorrect_order</code> 函数通过指定的 <code>super</code> 起始的 <code>serve_order</code> 路径，来调用 <code>serve_order</code> 函数：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">serve_order</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">mod</span> back_of_house &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">fix_incorrect_order</span>() &#123;</span><br><span class="line">        <span class="title function_ invoke__">cook_order</span>();</span><br><span class="line">        super::<span class="title function_ invoke__">serve_order</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">cook_order</span>() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例 7-8: 使用以 <code>super</code> 开头的相对路径从父目录开始调用函数</p>
<p><code>fix_incorrect_order</code> 函数在 <code>back_of_house</code> 模块中，所以我们可以使用 <code>super</code> 进入 <code>back_of_house</code> 父模块，也就是本例中的 <code>crate</code> 根。在这里，我们可以找到 <code>serve_order</code>。成功！我们认为 <code>back_of_house</code> 模块和 <code>serve_order</code> 函数之间可能具有某种关联关系，并且，如果我们要重新组织这个 crate 的模块树，需要一起移动它们。因此，我们使用 <code>super</code>，这样一来，如果这些代码被移动到了其他模块，我们只需要更新很少的代码。</p>
<h3 id="创建公有的结构体和枚举"><a href="#创建公有的结构体和枚举" class="headerlink" title="创建公有的结构体和枚举"></a><a target="_blank" rel="noopener" href="https://rustwiki.org/zh-CN/book/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html#%E5%88%9B%E5%BB%BA%E5%85%AC%E6%9C%89%E7%9A%84%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E6%9E%9A%E4%B8%BE">创建公有的结构体和枚举</a></h3><p>我们还可以使用 <code>pub</code> 来设计公有的结构体和枚举，不过有一些额外的细节需要注意。如果我们在一个结构体定义的前面使用了 <code>pub</code> ，这个结构体会变成公有的，但是这个结构体的字段仍然是私有的。我们可以根据情况决定每个字段是否公有。在示例 7-9 中，我们定义了一个公有结构体 <code>back_of_house::Breakfast</code>，其中有一个公有字段 <code>toast</code> 和私有字段 <code>seasonal_fruit</code>。这个例子模拟的情况是，在一家餐馆中，顾客可以选择随餐附赠的面包类型，但是厨师会根据季节和库存情况来决定随餐搭配的水果。餐馆可用的水果变化是很快的，所以顾客不能选择水果，甚至无法看到他们将会得到什么水果。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">mod</span> back_of_house &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Breakfast</span> &#123;</span><br><span class="line">        <span class="keyword">pub</span> toast: <span class="type">String</span>,</span><br><span class="line">        seasonal_fruit: <span class="type">String</span>,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">impl</span> <span class="title class_">Breakfast</span> &#123;</span><br><span class="line">        <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">summer</span>(toast: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> Breakfast &#123;</span><br><span class="line">            Breakfast &#123;</span><br><span class="line">                toast: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(toast),</span><br><span class="line">                seasonal_fruit: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;peaches&quot;</span>),</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">eat_at_restaurant</span>() &#123;</span><br><span class="line">    <span class="comment">// 在夏天点一份黑麦面包作为早餐</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">meal</span> = back_of_house::Breakfast::<span class="title function_ invoke__">summer</span>(<span class="string">&quot;Rye&quot;</span>);</span><br><span class="line">    <span class="comment">// 更改我们想要的面包</span></span><br><span class="line">    meal.toast = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Wheat&quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;I&#x27;d like &#123;&#125; toast please&quot;</span>, meal.toast);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果取消下一行的注释，将会导致编译失败；我们不被允许</span></span><br><span class="line">    <span class="comment">// 看到或更改随餐搭配的季节水果</span></span><br><span class="line">    <span class="comment">// meal.seasonal_fruit = String::from(&quot;blueberries&quot;);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例 7-9: 带有公有和私有字段的结构体</p>
<p>因为 <code>back_of_house::Breakfast</code> 结构体的 <code>toast</code> 字段是公有的，所以我们可以在 <code>eat_at_restaurant</code> 中使用点号来随意的读写 <code>toast</code> 字段。注意，我们不能在 <code>eat_at_restaurant</code> 中使用 <code>seasonal_fruit</code> 字段，因为 <code>seasonal_fruit</code> 是私有的。尝试去除那一行修改 <code>seasonal_fruit</code> 字段值的代码的注释，看看你会得到什么错误！</p>
<p>还请注意一点，因为 <code>back_of_house::Breakfast</code> 具有私有字段，所以这个结构体需要提供一个公共的关联函数来构造 <code>Breakfast</code> 的实例（这里我们命名为 <code>summer</code>）。如果 <code>Breakfast</code> 没有这样的函数，我们将无法在 <code>eat_at_restaurant</code> 中创建 <code>Breakfast</code> 实例，因为我们不能在 <code>eat_at_restaurant</code> 中设置私有字段 <code>seasonal_fruit</code> 的值。</p>
<p>与之相反，如果我们将枚举设为公有，则它的所有成员都将变为公有。我们只需要在 <code>enum</code> 关键字前面加上 <code>pub</code>，就像示例 7-10 展示的那样。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">mod</span> back_of_house &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">enum</span> <span class="title class_">Appetizer</span> &#123;</span><br><span class="line">        Soup,</span><br><span class="line">        Salad,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">eat_at_restaurant</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">order1</span> = back_of_house::Appetizer::Soup;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">order2</span> = back_of_house::Appetizer::Salad;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例 7-10: 设计公有枚举，使其所有成员公有</p>
<p>因为我们创建了名为 <code>Appetizer</code> 的公有枚举，所以我们可以在 <code>eat_at_restaurant</code> 中使用 <code>Soup</code> 和 <code>Salad</code> 成员。如果枚举成员不是公有的，那么枚举会显得用处不大；给枚举的所有成员挨个添加 <code>pub</code> 是很令人恼火的，因此枚举成员默认就是公有的。结构体通常使用时，不必将它们的字段公有化，因此结构体遵循常规，内容全部是私有的，除非使用 <code>pub</code> 关键字。</p>
<p>还有一种使用 <code>pub</code> 的场景我们还没有涉及到，那就是我们最后要讲的模块功能：<code>use</code> 关键字。我们将先单独介绍 <code>use</code>，然后展示如何结合使用 <code>pub</code> 和 <code>use</code>。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/07/23/RUST%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0%E4%B9%8B%E6%A8%A1%E5%9D%9701/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.png">
      <meta itemprop="name" content="Chillward">
      <meta itemprop="description" content="谁躺在漆黑的舞台上，用身体迎接着光芒">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chillward的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/07/23/RUST%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0%E4%B9%8B%E6%A8%A1%E5%9D%9701/" class="post-title-link" itemprop="url">RUST学习日记之模块01</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-07-23 21:25:01" itemprop="dateCreated datePublished" datetime="2025-07-23T21:25:01+08:00">2025-07-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-07-24 11:14:52" itemprop="dateModified" datetime="2025-07-24T11:14:52+08:00">2025-07-24</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>18k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>33 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p> 在C语言编程时，我们会包含多个头文件，然后就可以使用头文件中定义的函数和数据类型。但是C语言这一套容易出现一些问题:</p>
<ol>
<li>隐式依赖</li>
<li>全局命名空间污染</li>
<li>重复包含问题</li>
</ol>
<p>RUST的模块系统很好的避免了这些问题</p>
<blockquote>
<p>依旧是熟悉的复制粘贴</p>
</blockquote>
<p>  到目前为止，我们编写的程序都在一个文件的一个模块中。伴随着项目的增长，你应该通过将代码分解为多个模块和多个文件来组织代码。一个包（package）可以包含多个二进制 crate 项和一个可选的库 crate。伴随着包的增长，你可以将包中的部分代码提取出来，做成独立的 crate，这些 crate 则作为外部依赖项。本章将会涵盖所有这些概念。对于一个由一系列相互关联的包组成的超大型项目，Cargo 提供了<strong>工作空间</strong>（<em>workspaces</em>）这一功能，我们将在第十四章的 <a target="_blank" rel="noopener" href="https://kaisery.github.io/trpl-zh-cn/ch14-03-cargo-workspaces.html">“Cargo Workspaces”</a> 对此进行讲解。</p>
<p>  我们也会讨论封装来实现细节，这可以让你在更高层面重用代码：你实现了一个操作后，其他的代码可以通过该代码的公共接口来进行调用，而不需要知道它是如何实现的。你在编写代码时可以定义哪些部分是其他代码可以使用的公共部分，以及哪些部分是你有权更改实现细节的私有部分。这是另一种减少你在脑海中记住项目内容数量的方法。</p>
<p>  这里有一个需要说明的概念 “作用域（scope）”：代码所在的嵌套上下文有一组定义为 “in scope” 的名称。当阅读、编写和编译代码时，程序员和编译器需要知道特定位置的特定名称是否引用了变量、函数、结构体、枚举、模块、常量或者其他有意义的项。你可以创建作用域，以及改变哪些名称在作用域内还是作用域外。同一个作用域内不能拥有两个相同名称的项；可以使用一些工具来解决名称冲突。</p>
<p>  Rust 有许多功能可以让你管理代码的组织，包括哪些细节可以被公开，哪些细节作为私有部分，以及程序中各个作用域中有哪些名称。这些特性，有时被统称为 “模块系统（the module system）”，包括：</p>
<ul>
<li><strong>包</strong>（<em>Packages</em>）：Cargo 的一个功能，它允许你构建、测试和分享 crate。</li>
<li><strong>Crates</strong> ：一个模块的树形结构，它形成了库或可执行文件项目。</li>
<li><strong>模块</strong>（<em>Modules</em>）和 <strong>use</strong>：允许你控制作用域和路径的私有性。</li>
<li><strong>路径</strong>（<em>path</em>）：一个为例如结构体、函数或模块等项命名的方式。</li>
</ul>
<h2 id="包和Create"><a href="#包和Create" class="headerlink" title="包和Create"></a>包和Create</h2><p>crate 是 Rust 在编译时最小的代码单位。即使你用 <code>rustc</code> 而不是 <code>cargo</code> 来编译一个单独的源代码文件（正如我们在第 1 章“编写并运行 Rust 程序”中所做的那样），编译器还是会将那个文件视为一个 crate。crate 可以包含模块，模块可以定义在其他文件，然后和 crate 一起编译，我们会在接下来的章节中遇到。</p>
<p>crate 有两种形式：二进制 crate 和库 crate。<strong>二进制 crate</strong>（<em>Binary crates</em>）可以被编译为可执行程序，比如命令行程序或者服务端。它们必须有一个名为 <code>main</code> 函数来定义当程序被执行的时候所需要做的事情。目前我们所创建的 crate 都是二进制 crate。</p>
<p><strong>库 crate</strong>（<em>Library crates</em>）并没有 <code>main</code> 函数，它们也不会编译为可执行程序。相反它们定义了可供多个项目复用的功能模块。比如 <a target="_blank" rel="noopener" href="https://kaisery.github.io/trpl-zh-cn/ch02-00-guessing-game-tutorial.html#%E7%94%9F%E6%88%90%E4%B8%80%E4%B8%AA%E9%9A%8F%E6%9C%BA%E6%95%B0">第二章</a> 的 <code>rand</code> crate 就提供了生成随机数的功能。大多数时间 <code>Rustaceans</code> 说的 “crate” 指的都是库 crate，这与其他编程语言中 “library” 概念一致。</p>
<h6 id="crate-root-是一个源文件，Rust-编译器以它为起始点，并构成你的-crate-的根模块。"><a href="#crate-root-是一个源文件，Rust-编译器以它为起始点，并构成你的-crate-的根模块。" class="headerlink" title="crate root 是一个源文件，Rust 编译器以它为起始点，并构成你的 crate 的根模块。"></a><em>crate root</em> 是一个源文件，Rust 编译器以它为起始点，并构成你的 crate 的根模块。</h6><p>**包（package）是提供一系列功能的一个或者多个 crate 的捆绑。**一个包会包含一个 <em>Cargo.toml</em> 文件，阐述如何去构建这些 crate。Cargo 实际上就是一个包，它包含了用于构建你代码的命令行工具的二进制 crate。其他项目也依赖 Cargo 库来实现与 Cargo 命令行程序一样的逻辑。</p>
<p>包中可以包含至多一个库 crate(library crate)。包中可以包含任意多个二进制 crate(binary crate)，但是必须至少包含一个 crate（无论是库的还是二进制的）。</p>
<p>让我们来看看创建包的时候会发生什么。首先，我们输入命令 <code>cargo new my-project</code>：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cargo new my-project</span></span><br><span class="line">     Created binary (application) `my-project` package</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> my-project</span></span><br><span class="line">Cargo.toml</span><br><span class="line">src</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> my-project/src</span></span><br><span class="line">main.rs</span><br></pre></td></tr></table></figure>

<p>运行了这条命令后，我们先用 <code>ls</code> （译者注：此命令为 Linux 平台的指令，Windows 下可用 dir）来看看 Cargo 给我们创建了什么，Cargo 会给我们的包创建一个 <em>Cargo.toml</em> 文件。查看 <em>Cargo.toml</em> 的内容，会发现并没有提到 <em>src&#x2F;main.rs</em>，**因为 Cargo 遵循的一个约定：<em>src&#x2F;main.rs</em> 就是一个与包同名的二进制 crate 的 crate 根。**同样的，Cargo 知道如果包目录中包含 <em>src&#x2F;lib.rs</em>，则包带有与其同名的库 crate，且 <em>src&#x2F;lib.rs</em> 是 crate 根。crate 根文件将由 Cargo 传递给 <code>rustc</code> 来实际构建库或者二进制项目。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[package]</span><br><span class="line">name = &quot;Functions&quot;</span><br><span class="line">version = &quot;0.1.0&quot;</span><br><span class="line">edition = &quot;2024&quot;</span><br><span class="line"></span><br><span class="line">[dependencies]</span><br><span class="line">//假如我们要添加main跟lib之外的其他依赖</span><br><span class="line">[[bin]]</span><br><span class="line">name = &quot;another-app&quot; # 这是你希望这个额外二进制 crate 的名称</span><br><span class="line">path = &quot;src/bin/another_app.rs&quot; # 这是它的源文件路径</span><br></pre></td></tr></table></figure>

<p>在此，我们有了一个只包含 <em>src&#x2F;main.rs</em> 的包，意味着它只含有一个名为 <code>my-project</code> 的二进制 crate。如果一个包同时含有 <em>src&#x2F;main.rs</em> 和 <em>src&#x2F;lib.rs</em>，则它有两个 crate：一个二进制的和一个库的，且名字都与包相同。通过将文件放在 <em>src&#x2F;bin</em> 目录下，一个包可以拥有多个二进制 crate：每个 <em>src&#x2F;bin</em> 下的文件都会被编译成一个独立的二进制 crate。</p>
<blockquote>
<p>来点人话</p>
</blockquote>
<h3 id="单一二进制-Crate"><a href="#单一二进制-Crate" class="headerlink" title="单一二进制 Crate"></a>单一二进制 Crate</h3><p>最简单的 Rust 包结构是一个只包含 <code>src/main.rs</code> 文件的包。在这种情况下，你的包将编译成一个名为 <code>my-project</code> 的<strong>二进制 crate</strong>（其中 <code>my-project</code> 是你的包名）。所有代码都将包含在 <code>main.rs</code> 文件中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">my-project/</span><br><span class="line">├── src/</span><br><span class="line">│   └── main.rs</span><br><span class="line">└── Cargo.toml</span><br></pre></td></tr></table></figure>

<h3 id="二进制-Crate-和库-Crate-共存"><a href="#二进制-Crate-和库-Crate-共存" class="headerlink" title="二进制 Crate 和库 Crate 共存"></a>二进制 Crate 和库 Crate 共存</h3><p>如果一个包同时包含 <code>src/main.rs</code> 和 <code>src/lib.rs</code>，那么它将拥有两个 crate：一个<strong>二进制 crate</strong> 和一个<strong>库 crate</strong>。这两个 crate 的名字都默认与包名相同。</p>
<ul>
<li><code>src/main.rs</code> 中的代码会编译成可执行程序。</li>
<li><code>src/lib.rs</code> 中的代码会编译成库，可以被其他项目（包括当前包的二进制 crate）引用。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">my-project/</span><br><span class="line">├── src/</span><br><span class="line">│   ├── main.rs</span><br><span class="line">│   └── lib.rs</span><br><span class="line">└── Cargo.toml</span><br></pre></td></tr></table></figure>

<p>在这种结构中，<code>main.rs</code> 通常会使用 <code>use my_project;</code> 或 <code>use crate;</code>（在 Rust 2018 版及更高版本中）来引用 <code>lib.rs</code> 中定义的模块和函数。</p>
<h3 id="多个二进制-Crate"><a href="#多个二进制-Crate" class="headerlink" title="多个二进制 Crate"></a>多个二进制 Crate</h3><p>Rust 包可以通过将文件放置在 <code>src/bin</code> 目录下拥有多个<strong>二进制 crate</strong>。<code>src/bin</code> 目录下的每个文件都会被编译成一个独立的二进制 crate。每个文件的名称（不包括 <code>.rs</code> 后缀）将成为对应二进制 crate 的名称。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">my-project/</span><br><span class="line">├── src/</span><br><span class="line">│   ├── main.rs         // 默认的二进制 crate</span><br><span class="line">│   ├── lib.rs          // 库 crate</span><br><span class="line">│   └── bin/</span><br><span class="line">│       ├── my_tool.rs  // 额外的二进制 crate: `my_tool`</span><br><span class="line">│       └── another_app.rs // 额外的二进制 crate: `another_app`</span><br><span class="line">└── Cargo.toml</span><br></pre></td></tr></table></figure>

<p>在这个例子中：</p>
<ul>
<li><p><code>cargo run</code> 默认会编译并运行 <code>src/main.rs</code> 对应的二进制 crate。</p>
</li>
<li><p>你可以使用 <code>cargo run --bin my_tool</code> 来运行 <code>src/bin/my_tool.rs</code> 对应的二进制 crate。</p>
</li>
<li><p>同样，<code>cargo run --bin another_app</code> 会运行 <code>src/bin/another_app.rs</code>。</p>
<p>当 Rust 包包含多个二进制 crate 时，<strong><code>src/main.rs</code> 中的内容仍然是默认运行的二进制 crate</strong>。</p>
<p>即使你在 <code>src/bin</code> 目录下添加了其他的 <code>.rs</code> 文件来创建额外的二进制 crate，<code>cargo run</code> 命令在没有额外指定的情况下，依然会查找并运行 <code>src/main.rs</code> 编译而成的可执行文件。</p>
<p>如果你想运行 <code>src/bin</code> 目录下特定的二进制 crate，你需要使用 <code>cargo run --bin &lt;crate-name&gt;</code> 命令，其中 <code>&lt;crate-name&gt;</code> 是你想要运行的二进制 crate 的文件名（不包括 <code>.rs</code> 后缀）。</p>
<p><strong>举个例子：</strong></p>
<p>假设你有这样的项目结构：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">my-project/</span><br><span class="line">├── src/</span><br><span class="line">│   ├── main.rs         // 默认的二进制 crate</span><br><span class="line">│   └── bin/</span><br><span class="line">│       └── my_tool.rs  // 另一个二进制 crate: `my_tool`</span><br><span class="line">└── Cargo.toml</span><br></pre></td></tr></table></figure>

<ul>
<li>运行 <code>cargo run</code> 会编译并执行 <code>src/main.rs</code> 中的代码。</li>
<li>运行 <code>cargo run --bin my_tool</code> 则会编译并执行 <code>src/bin/my_tool.rs</code> 中的代码。</li>
</ul>
<p>所以，<code>src/main.rs</code> 就像是你的项目主要的或默认的入口点，而 <code>src/bin</code> 中的文件则提供了额外的、可独立运行的工具或应用程序。</p>
<blockquote>
<p>暂时不知道有什么用</p>
</blockquote>
</li>
</ul>
<h3 id="模块的组织"><a href="#模块的组织" class="headerlink" title="模块的组织"></a>模块的组织</h3><p>在上述基本结构的基础上，你可以在 <code>src</code> 目录下创建子目录来进一步组织你的模块。每个 <code>mod.rs</code> 文件或与目录同名的 <code>.rs</code> 文件（例如 <code>my_module/mod.rs</code> 或 <code>my_module.rs</code>）都代表一个模块。</p>
<p>例如，如果你在 <code>src/lib.rs</code> 中有一个复杂的库，你可以将其拆分为多个文件和目录：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">my-project/</span><br><span class="line">├── src/</span><br><span class="line">│   ├── main.rs</span><br><span class="line">│   └── lib.rs</span><br><span class="line">│   │   // lib.rs 的内容可能包含 `mod data;` 和 `mod utils;`</span><br><span class="line">│   ├── data/          // 对应 `data` 模块</span><br><span class="line">│   │   ├── mod.rs     // data 模块的根文件</span><br><span class="line">│   │   └── processing.rs // data 模块下的子模块 `processing`</span><br><span class="line">│   └── utils/         // 对应 `utils` 模块</span><br><span class="line">│       └── mod.rs     // utils 模块的根文件</span><br><span class="line">└── Cargo.toml</span><br></pre></td></tr></table></figure>

<p>在这种结构中：</p>
<ul>
<li><code>src/lib.rs</code> 可以通过 <code>mod data;</code> 和 <code>mod utils;</code> 声明并引入 <code>data</code> 和 <code>utils</code> 模块。</li>
<li><code>src/data/mod.rs</code> 是 <code>data</code> 模块的入口点，它可以通过 <code>mod processing;</code> 声明 <code>processing</code> 子模块。</li>
</ul>
<hr>
<p><strong>总结来说，Rust 的文件目录结构和模块系统紧密配合，主要遵循以下原则：</strong></p>
<ul>
<li><strong><code>src/main.rs</code></strong>: 默认的二进制 crate 入口。</li>
<li><strong><code>src/lib.rs</code></strong>: 默认的库 crate 入口。</li>
<li><strong><code>src/bin/</code> 目录</strong>: 用于存放额外的二进制 crate。</li>
<li><strong>子目录和 <code>mod.rs</code> (或与目录同名的 <code>.rs</code> 文件)</strong>: 用于组织更复杂的模块结构。</li>
</ul>
<p>理解这些约定将帮助你有效地组织和管理你的 Rust 项目，无论它们是简单的工具还是大型的应用程序。</p>
<h2 id="Crate-根是什么东西？"><a href="#Crate-根是什么东西？" class="headerlink" title="Crate 根是什么东西？"></a>Crate 根是什么东西？</h2><p>在 Rust 里，<strong>Crate 根 (Crate Root)</strong> 可以理解为你整个 Rust 项目（或者说一个 <strong>Crate</strong>）的“总入口文件”。当 Rust 编译器开始编译你的代码时，它就是从这个文件开始读起，然后根据里面的声明，一步步地找到并包含你项目里所有其他的模块和代码。</p>
<p>可以把它想象成一本书的“扉页”或者一个网站的“首页”。</p>
<h3 id="Crate-根在哪里？"><a href="#Crate-根在哪里？" class="headerlink" title="Crate 根在哪里？"></a>Crate 根在哪里？</h3><p>Crate 根文件的位置是约定俗成的：</p>
<ol>
<li><strong>对于一个库 Crate (Library Crate)</strong>：<ul>
<li>它的 Crate 根文件是 <strong><code>src/lib.rs</code></strong>。</li>
<li>这样的 Crate 编译出来的是一个库（就像一个工具箱，提供很多功能给其他代码使用），而不是一个独立运行的程序。</li>
</ul>
</li>
<li><strong>对于一个二进制 Crate (Binary Crate)</strong>：<ul>
<li>它的 Crate 根文件是 <strong><code>src/main.rs</code></strong>。</li>
<li>这样的 Crate 编译出来的是一个可执行程序（就像一个应用程序，可以直接运行）。</li>
</ul>
</li>
</ol>
<h3 id="Crate-根的作用是什么？"><a href="#Crate-根的作用是什么？" class="headerlink" title="Crate 根的作用是什么？"></a>Crate 根的作用是什么？</h3><p>Crate 根文件主要有以下几个作用：</p>
<ul>
<li><strong>编译起点</strong>：编译器总是从这里开始扫描和解析你的代码。</li>
<li><strong>模块声明</strong>：你会在 Crate 根文件中使用 <code>mod</code> 关键字来声明你 Crate 中所有顶级的模块。比如，在 <code>src/main.rs</code> 中写 <code>mod garden;</code>，就是告诉编译器：“我有一个叫做 <code>garden</code> 的模块，请去 <code>src/garden.rs</code> 或 <code>src/garden/mod.rs</code> 找到它的代码。”</li>
<li><strong>公共接口（对于库 Crate）</strong>：如果你的 Crate 是一个库，<code>src/lib.rs</code> 就定义了这个库向外部暴露的公共 API。其他项目在使用你的库时，会通过这个文件来访问你的功能。</li>
<li><strong>程序入口（对于二进制 Crate）</strong>：如果你的 Crate 是一个二进制程序，<code>src/main.rs</code> 中的 <code>fn main()</code> 函数就是程序执行的起点。</li>
</ul>
<hr>
<p><strong>简单来说：</strong></p>
<p><strong>Crate 根</strong>就是你的 Rust 项目（一个 Crate）的“大脑”或者“指挥中心”，它告诉编译器如何找到并组织你所有的代码。没有它，编译器就不知道从何开始构建你的程序或库。</p>
<blockquote>
<p>官方文档依旧不说人话</p>
</blockquote>
<h2 id="定义模块来控制作用域与私有性"><a href="#定义模块来控制作用域与私有性" class="headerlink" title="定义模块来控制作用域与私有性"></a>定义模块来控制作用域与私有性</h2><p>在本节，我们将讨论模块和其它一些关于模块系统的部分，如允许你命名项的 <em>路径</em>（<em>paths</em>）；用来将路径引入作用域的 <code>use</code> 关键字；以及使项变为公有的 <code>pub</code> 关键字。我们还将讨论 <code>as</code> 关键字、外部包（external packages）和 glob 运算符（glob operator）。</p>
<p>首先，我们将从一系列的规则开始，在你未来组织代码的时候，这些规则可被用作简单的参考。接下来我们将会详细的解释每条规则。</p>
<h2 id="模块小抄（Cheat-Sheet）"><a href="#模块小抄（Cheat-Sheet）" class="headerlink" title="模块小抄（Cheat Sheet）"></a><a target="_blank" rel="noopener" href="https://kaisery.github.io/trpl-zh-cn/ch07-02-defining-modules-to-control-scope-and-privacy.html#%E6%A8%A1%E5%9D%97%E5%B0%8F%E6%8A%84cheat-sheet">模块小抄（Cheat Sheet）</a></h2><p>在深入了解模块和路径的细节之前，这里提供一个简单的参考，用来解释模块、路径、<code>use</code>关键词和<code>pub</code>关键词如何在编译器中工作，以及大部分开发者如何组织他们的代码。我们将在本章中举例说明每条规则，但这是回顾模块工作原理的绝佳参考。</p>
<ul>
<li><p><strong>从 crate 根节点开始</strong>: 当编译一个 crate, 编译器首先在 crate 根文件（通常，对于一个库 crate 而言是 <em>src&#x2F;lib.rs</em>，对于一个二进制 crate 而言是 <em>src&#x2F;main.rs</em>）中寻找需要被编译的代码。</p>
</li>
<li><p>声明模块</p>
<p>: 在 crate 根文件中，你可以声明一个新模块；比如，用</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> garden;</span><br></pre></td></tr></table></figure>

<p>声明了一个叫做</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">garden</span><br></pre></td></tr></table></figure>

<p>的模块。编译器会在下列路径中寻找模块代码：</p>
<ul>
<li>内联，用大括号替换 <code>mod garden</code> 后跟的分号</li>
</ul>
</li>
<li><p>在文件 <em>src&#x2F;garden.rs</em></p>
<ul>
<li>在文件 <em>src&#x2F;garden&#x2F;mod.rs</em></li>
</ul>
</li>
<li><p>声明子模块</p>
<p>: 在除了 crate 根节点以外的任何文件中，你可以定义子模块。比如，你可能在src&#x2F;garden.rs 中声明</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mod vegetables;</span><br></pre></td></tr></table></figure>

<p>。编译器会在以父模块命名的目录中寻找子模块代码：</p>
<ul>
<li>内联，直接在 <code>mod vegetables</code> 后方不是一个分号而是一个大括号</li>
</ul>
</li>
<li><p>在文件 <em>src&#x2F;garden&#x2F;vegetables.rs</em></p>
<ul>
<li>在文件 <em>src&#x2F;garden&#x2F;vegetables&#x2F;mod.rs</em></li>
</ul>
</li>
<li><p><strong>模块中的代码路径</strong>: 一旦一个模块是你 crate 的一部分，你可以在隐私规则允许的前提下，从同一个 crate 内的任意地方，通过代码路径引用该模块的代码。举例而言，一个 garden vegetables 模块下的 <code>Asparagus</code> 类型可以通过 <code>crate::garden::vegetables::Asparagus</code> 访问。</p>
</li>
<li><p><strong>私有 vs 公用</strong>: 一个模块里的代码默认对其父模块私有。为了使一个模块公用，应当在声明时使用 <code>pub mod</code> 替代 <code>mod</code>。为了使一个公用模块内部的成员公用，应当在声明前使用<code>pub</code>。</p>
</li>
<li><p><strong><code>use</code> 关键字</strong>: 在一个作用域内，<code>use</code>关键字创建了一个项的快捷方式，用来减少长路径的重复。在任何可以引用 <code>crate::garden::vegetables::Asparagus</code> 的作用域，你可以通过 <code>use crate::garden::vegetables::Asparagus;</code> 创建一个快捷方式，然后你就可以在作用域中只写 <code>Asparagus</code> 来使用该类型。</p>
</li>
</ul>
<p>这里我们创建一个名为<code>backyard</code>的二进制 crate 来说明这些规则。该 crate 的路径同样命名为<code>backyard</code>，该路径包含了这些文件和目录：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">backyard</span><br><span class="line">├── Cargo.lock</span><br><span class="line">├── Cargo.toml</span><br><span class="line">└── src</span><br><span class="line">    ├── garden</span><br><span class="line">    │   └── vegetables.rs</span><br><span class="line">    ├── garden.rs</span><br><span class="line">    └── main.rs</span><br></pre></td></tr></table></figure>

<p>这个例子中的 crate 根文件是 <em>src&#x2F;main.rs</em>，该文件包含了：</p>
<p>文件名：src&#x2F;main.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> crate::garden::vegetables::Asparagus;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> garden;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">plant</span> = Asparagus &#123;&#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;I&#x27;m growing &#123;plant:?&#125;!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>pub mod garden;</code> 行告诉编译器将 <em>src&#x2F;garden.rs</em> 中发现的代码包含进来：</p>
<p>文件名：src&#x2F;garden.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> vegetables;</span><br></pre></td></tr></table></figure>

<p>在此处，<code>pub mod vegetables;</code> 意味着在 <em>src&#x2F;garden&#x2F;vegetables.rs</em> 中的代码也应该被包含。这些代码是：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Asparagus</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>现在让我们深入了解这些规则的细节并在实践中演示它们！</p>
<h3 id="在模块中对相关代码进行分组"><a href="#在模块中对相关代码进行分组" class="headerlink" title="在模块中对相关代码进行分组"></a>在模块中对相关代码进行分组</h3><p><strong>模块</strong>让我们可以将一个 crate 中的代码进行分组，以提高可读性与重用性。因为一个模块中的代码默认是私有的，所以还可以利用模块控制项的<strong>私有性</strong>（<em>privacy</em>）。私有项是不可为外部使用的内在详细实现。我们也可以将模块和它其中的项标记为公开的，这样，外部代码就可以使用并依赖于它们。</p>
<p>作为示例，让我们编写一个提供餐厅功能的库 <code>crate</code>。我们将定义函数的签名，但将其函数体留空以便将注意力集中在代码的组织结构上而不是餐厅实现的细节。</p>
<p>在餐饮业，餐馆中会有一些地方被称之为<strong>前台</strong>（<em>front of house</em>），还有另外一些地方被称之为<strong>后台</strong>（<em>back of house</em>）。前台是招待顾客的地方；这包括接待员为顾客安排座位、服务员接受点单和付款、调酒师制作饮品的地方。后台则是厨师和烹饪人员在厨房工作、洗碗工清理餐具，以及经理处理行政事务的区域。</p>
<p>为了以这种方式构建我们的 <code>crate</code>，我们可以将其功能组织到嵌套模块中。通过执行 <code>cargo new restaurant --lib</code> 来创建一个新的名为 <code>restaurant</code> 的库。然后将示例 7-1 中所罗列出来的代码放入 <em>src&#x2F;lib.rs</em> 中，来定义一些模块和函数签名；这段代码即为前台部分。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> front_of_house &#123;</span><br><span class="line">    <span class="keyword">mod</span> hosting &#123;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">add_to_waitlist</span>() &#123;&#125;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">seat_at_table</span>() &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">mod</span> serving &#123;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">take_order</span>() &#123;&#125;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">serve_order</span>() &#123;&#125;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">take_payment</span>() &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例 7-1：一个包含了其他内置了函数的模块的 <code>front_of_house</code> 模块</p>
<p>我们使用 <code>mod</code> 关键字来定义模块，后跟模块名（本例中叫做 <code>front_of_house</code>），并且用花括号包围模块的主体。在模块内，我们还可以定义其它的模块，就像本例中的 <code>hosting</code> 和 <code>serving</code> 模块。模块还可以保存一些定义的其它项，比如结构体、枚举、常量、trait、或者如示例 7-1 所示的函数。</p>
<p>通过使用模块，我们可以将相关的定义分组到一起，并指出它们为什么相关。程序员可以通过使用这段代码，更加容易地找到他们想要的定义，因为他们可以基于分组来对代码进行导航，而不需要阅读所有的定义。程序员向这段代码中添加一个新的功能时，他们也会知道代码应该放置在何处，可以保持程序的组织性。</p>
<p>在前面我们提到了，<code>src/main.rs</code> 和 <code>src/lib.rs</code> 叫做 crate 根。之所以这样叫它们是因为这两个文件的内容都分别在 crate 模块结构的根组成了一个名为 <code>crate</code> 的模块，该结构被称为<strong>模块树</strong>（<em>module tree</em>）。</p>
<p>示例 7-2 展示了示例 7-1 中模块树的结构。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">crate</span><br><span class="line"> └── front_of_house</span><br><span class="line">     ├── hosting</span><br><span class="line">     │   ├── add_to_waitlist</span><br><span class="line">     │   └── seat_at_table</span><br><span class="line">     └── serving</span><br><span class="line">         ├── take_order</span><br><span class="line">         ├── serve_order</span><br><span class="line">         └── take_payment</span><br></pre></td></tr></table></figure>

<p>示例 7-2: 示例 7-1 中代码的模块树</p>
<p>这个树展示了一些模块是如何被嵌入到另一个模块的（例如，<code>hosting</code> 嵌套在 <code>front_of_house</code> 中）。这个树还展示了一些模块是互为<strong>兄弟</strong>（<em>siblings</em>）的，这意味着它们定义在同一模块中；<code>hosting</code> 和 <code>serving</code> 被一起定义在 <code>front_of_house</code> 中。继续沿用家庭关系的比喻，如果一个模块 A 被包含在模块 B 中，我们将模块 A 称为模块 B 的 <strong>子</strong>（<em>child</em>）模块，模块 B 则是模块 A 的 <strong>父</strong>（<em>parent</em>）模块。注意，整个模块树都植根于名为 <code>crate</code> 的隐式模块下。</p>
<p>这个模块树可能会令你想起电脑上文件系统的目录树；这是一个非常恰当的类比！就像文件系统的目录，你可以使用模块来组织你的代码。并且，就像目录中的文件，我们需要一种方法来找到模块。</p>
<blockquote>
<p>上面这段话多少看的人有点懵逼,我们现在让AI来说点人话</p>
</blockquote>
<h3 id="1-Rust-代码的起点：从“大门”开始找"><a href="#1-Rust-代码的起点：从“大门”开始找" class="headerlink" title="1. Rust 代码的起点：从“大门”开始找"></a><strong>1. Rust 代码的起点：从“大门”开始找</strong></h3><p>你的整个 Rust 项目，无论多大，都有一个固定的“大门”。</p>
<ul>
<li>如果你写的是一个可执行程序（像一个 <code>.exe</code> 文件），大门通常是 <strong><code>src/main.rs</code></strong>。</li>
<li>如果你写的是一个库（给别人用的代码包），大门就是 <strong><code>src/lib.rs</code></strong>。</li>
</ul>
<p>编译器盖房子时，第一步就是从这个“大门”开始，一步步往里找代码。</p>
<h3 id="2-声明模块：给你的代码分房间"><a href="#2-声明模块：给你的代码分房间" class="headerlink" title="2. 声明模块：给你的代码分房间"></a><strong>2. 声明模块：给你的代码分房间</strong></h3><p>就像家里有客厅、卧室、厨房一样，你的代码也需要分门别类。在“大门”文件里（比如 <code>src/main.rs</code>），你可以用 <code>mod 房间名;</code> 来声明一个新的“房间”。</p>
<p>比如：<code>mod garden;</code></p>
<p>这告诉编译器：“嘿，我有一个叫 <code>garden</code> 的房间！” 编译器就会去以下几个地方找这个房间的具体图纸：</p>
<ul>
<li><strong>直接在大括号里：</strong> 你可以直接在 <code>mod garden</code> 后面跟一对 <code>&#123;&#125;</code>，把所有代码写在里面，就像一个“开放式厨房”。</li>
<li><strong>在同级文件里：</strong> 编译器会去 <code>src/garden.rs</code> 这个文件里找。</li>
<li><strong>在同级文件夹里：</strong> 编译器会去 <code>src/garden/mod.rs</code> 这个文件里找（<code>mod.rs</code> 文件就像这个文件夹的“总说明书”）。</li>
</ul>
<h3 id="3-声明子模块：房间里再隔小间"><a href="#3-声明子模块：房间里再隔小间" class="headerlink" title="3. 声明子模块：房间里再隔小间"></a><strong>3. 声明子模块：房间里再隔小间</strong></h3><p>如果你的“房间”里内容太多，还可以再隔出“小间”。比如，你已经在 <code>src/garden.rs</code>（也就是 <code>garden</code> 房间的图纸）里，想再分一个 <code>vegetables</code> 的“小间”。</p>
<p>你可以写：<code>mod vegetables;</code></p>
<p>这时，编译器就知道要去 <code>garden</code> 这个“房间”里找 <code>vegetables</code> 这个“小间”的图纸了。它会去：</p>
<ul>
<li><strong>直接在大括号里：</strong> 和上面一样，可以直接写在大括号里。</li>
<li><strong>在父房间的子文件夹里：</strong> 编译器会去 <code>src/garden/vegetables.rs</code> 这个文件里找。</li>
<li><strong>在父房间的子文件夹里的 <code>mod.rs</code> 文件：</strong> 编译器会去 <code>src/garden/vegetables/mod.rs</code> 这个文件里找。</li>
</ul>
<h3 id="4-模块中的代码路径：怎么找到某个东西？"><a href="#4-模块中的代码路径：怎么找到某个东西？" class="headerlink" title="4. 模块中的代码路径：怎么找到某个东西？"></a><strong>4. 模块中的代码路径：怎么找到某个东西？</strong></h3><p>想象你在一个大房子里，要描述某个东西在哪儿。你会说“在客厅里沙发的旁边”。在 Rust 里，你要引用一个模块里的东西，也需要指明它的“路径”。</p>
<p>比如，如果你有个叫 <code>Asparagus</code> 的类型，它在 <code>garden</code> 房间的 <code>vegetables</code> 小间里，那么它的完整路径就是： <strong><code>crate::garden::vegetables::Asparagus</code></strong></p>
<ul>
<li><code>crate::</code> 就代表你这个项目的根目录（也就是那个“大门”）。</li>
<li>后面跟着的就是模块一层层嵌套的名字。</li>
</ul>
<h3 id="5-私有-vs-公用：谁能看到我的东西？"><a href="#5-私有-vs-公用：谁能看到我的东西？" class="headerlink" title="5. 私有 vs 公用：谁能看到我的东西？"></a><strong>5. 私有 vs 公用：谁能看到我的东西？</strong></h3><p>这是关于隐私的规则：</p>
<ul>
<li><strong>默认是私有的：</strong> 你在一个模块里写的东西，默认只有这个模块自己能用，外面是看不到的。就像你卧室里的东西，客厅里的人看不到。</li>
<li><strong><code>pub mod</code> 公开模块：</strong> 如果你想让整个 <code>garden</code> 房间都能被外面的人看到，你需要在声明它的时候加上 <code>pub</code>，写成 <code>pub mod garden;</code>。</li>
<li><strong><code>pub</code> 公开模块内部成员：</strong> 即使一个房间是公开的，里面的家具（比如结构体、函数）默认还是私有的。如果你想让 <code>Asparagus</code> 这个“家具”也能被外面看到，你也要在它前面加上 <code>pub</code>。</li>
</ul>
<h3 id="6-use-关键字：走捷径，少写路名！"><a href="#6-use-关键字：走捷径，少写路名！" class="headerlink" title="6. use 关键字：走捷径，少写路名！"></a><strong>6. <code>use</code> 关键字：走捷径，少写路名！</strong></h3><p>想象你每次去厨房都要说“去客厅，然后穿过餐厅，再到厨房”。这太麻烦了！</p>
<p><code>use</code> 关键字就是用来走捷径的。比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use crate::garden::vegetables::Asparagus;</span><br></pre></td></tr></table></figure>

<p>这行代码就是告诉 Rust：“以后在这个地方，我提到 <code>Asparagus</code>，就直接指代 <code>crate::garden::vegetables::Asparagus</code> 这个东西，不用每次都写那么长一串路径了！”</p>
<p>这样，你以后在这个文件里直接写 <code>Asparagus</code> 就可以了，方便很多。</p>
<h3 id="用-backyard-例子来说明："><a href="#用-backyard-例子来说明：" class="headerlink" title="用 backyard 例子来说明："></a><strong>用 <code>backyard</code> 例子来说明：</strong></h3><p>现在，我们把上面的规则套到那个 <code>backyard</code> 项目里，就像搭建一个真实的小花园：</p>
<ol>
<li><strong><code>src/main.rs</code> (主屋，程序的入口)：</strong><ul>
<li><code>pub mod garden;</code>：主屋里声明了一个<strong>公开</strong>的 <code>garden</code> 房间（所以编译器去 <code>src/garden.rs</code> 里找这个房间的图纸）。</li>
<li><code>use crate::garden::vegetables::Asparagus;</code>：这里设置了一个捷径！以后我直接写 <code>Asparagus</code>，就知道指的是 <code>garden</code> 房间里 <code>vegetables</code> 小间里的 <code>Asparagus</code> 这个植物。</li>
<li><code>fn main() &#123; ... &#125;</code>：这是程序真正运行的地方，就像主屋里的客厅。它创建了一个 <code>Asparagus</code> 植物，并打印出来。</li>
</ul>
</li>
<li><strong><code>src/garden.rs</code> (花园的图纸)：</strong><ul>
<li><code>pub mod vegetables;</code>：花园里声明了一个<strong>公开</strong>的 <code>vegetables</code> 小间（所以编译器去 <code>src/garden/vegetables.rs</code> 里找这个小间的图纸）。</li>
</ul>
</li>
<li><strong><code>src/garden/vegetables.rs</code> (蔬菜小间的图纸)：</strong><ul>
<li><code>pub struct Asparagus &#123;&#125;</code>：这里定义了一个<strong>公开</strong>的 <code>Asparagus</code> 植物结构体。</li>
</ul>
</li>
</ol>
<p>通过这些规则，整个项目就被组织得井井有条，各个部分各司其职，又可以通过明确的路径相互引用。</p>
<p><code>src/garden.rs</code> <strong>不是</strong>一个独立的库 crate。它只是一个<strong>模块文件</strong>，是 <code>backyard</code> 这个二进制 crate 的一部分。</p>
<h3 id="src-garden-rs-为什么不在-lib-目录下？"><a href="#src-garden-rs-为什么不在-lib-目录下？" class="headerlink" title="src/garden.rs 为什么不在 lib 目录下？"></a><code>src/garden.rs</code> 为什么不在 <code>lib</code> 目录下？</h3><p><code>src/garden.rs</code> 之所以直接放在 <code>src</code> 目录下，是因为它被 <code>src/main.rs</code> 中的 <code>pub mod garden;</code> 这行代码<strong>声明并包含了进来</strong>。</p>
<p>当你在 <code>src/main.rs</code>（或 <code>src/lib.rs</code>）中声明 <code>mod garden;</code> 时，Rust 编译器会按照你之前看到的规则去寻找 <code>garden</code> 模块的代码：</p>
<ol>
<li>在 <code>src/garden.rs</code> 文件中。</li>
<li>在 <code>src/garden/mod.rs</code> 文件中。</li>
</ol>
<p>在这个例子中，它找到了 <code>src/garden.rs</code>，并将其中的代码（包括它声明的 <code>vegetables</code> 模块）<strong>作为 <code>main.rs</code> 所属的这个二进制 crate 的一部分</strong>编译进去。所以，<code>garden.rs</code> 仅仅是 <code>backyard</code> 这个二进制 crate 内部的一个模块，用来组织代码。</p>
<h3 id="那-lib-目录是干啥用的？"><a href="#那-lib-目录是干啥用的？" class="headerlink" title="那 lib 目录是干啥用的？"></a>那 <code>lib</code> 目录是干啥用的？</h3><p><code>lib</code> 目录（具体来说是 <code>src/lib.rs</code> 文件）是用来创建<strong>库 crate</strong> 的。</p>
<ul>
<li><strong>库 crate</strong> 是一种可以被其他项目（甚至是你自己项目的二进制 crate）<strong>引用和复用</strong>的代码包。它不直接生成可执行文件，而是生成一个库文件（例如 <code>.rlib</code> 文件）。</li>
<li>当你的项目包含 <code>src/lib.rs</code> 时，<code>Cargo</code> 会自动将其视为一个库 crate 的根文件。</li>
</ul>
<p><strong>区别在于：</strong></p>
<ul>
<li><strong><code>src/lib.rs</code></strong>：定义的是整个<strong>库 crate</strong> 的入口和结构，它是一个独立的编译单元，旨在被其他代码导入使用。</li>
<li><strong><code>src/garden.rs</code></strong>：定义的是当前<strong>二进制 crate</strong>（或库 crate）内部的一个<strong>模块</strong>，它只是用来组织该 crate 内部的代码，而不是一个独立的、可被其他外部项目直接引用的 crate。</li>
</ul>
<p><strong>简而言之：</strong></p>
<p><code>src/lib.rs</code> 相当于你的项目要对外提供的“工具箱”的“总说明书”。而 <code>src/garden.rs</code> 只是你这个工具箱（或你的主程序）内部的一个“抽屉”，用来存放相关工具。</p>
<p>为了更好地理解，我们再回顾一下 Rust 包中不同类型的 Crate 和模块文件的角色：</p>
<ol>
<li><strong>默认二进制 Crate (<code>src/main.rs</code>)</strong>:<ul>
<li>这是你运行 <code>cargo run</code> 时默认会编译和执行的程序。</li>
<li>必须包含一个 <code>fn main()</code> 函数。</li>
<li>它可以声明和使用内部的模块文件（比如本例中的 <code>src/garden.rs</code>），这些模块文件最终都成为了这个二进制 Crate 的一部分。</li>
</ul>
</li>
<li><strong>库 Crate (<code>src/lib.rs</code>)</strong>:<ul>
<li>这是为了提供可复用的代码库而存在的。它不包含 <code>main</code> 函数。</li>
<li>编译后生成的是一个库文件（例如 <code>.rlib</code> 或 <code>.so</code>&#x2F;<code>.dll</code>），而不是可执行文件。</li>
<li>这个库 Crate 可以被其他项目（包括当前包的默认二进制 Crate <code>src/main.rs</code> 或其他位于 <code>src/bin</code> 目录下的二进制 Crate）引用和使用。</li>
</ul>
</li>
<li><strong>额外二进制 Crate (<code>src/bin/\*.rs</code>)</strong>:<ul>
<li>如果你的项目需要除了 <code>src/main.rs</code> 之外的<strong>其他独立可执行程序</strong>，你就会把它们放在 <code>src/bin/</code> 目录下。</li>
<li><code>src/bin</code> 目录下的每个 <code>.rs</code> 文件都会被编译成一个独立的二进制 Crate，并且每个文件都需要包含一个 <code>fn main()</code> 函数。</li>
<li>例如，如果你有 <code>src/bin/my_tool.rs</code>，那么你可以用 <code>cargo run --bin my_tool</code> 来运行它。</li>
</ul>
</li>
</ol>
<p>当然可以。在这个餐厅项目中，你可以完全按照 Backyard 项目的模式来组织代码，将餐厅功能模块化，但不是作为一个独立的库 crate，而是作为主二进制 crate (<code>src/main.rs</code>) 的一部分来包含。</p>
<p>这意味着：</p>
<ol>
<li><strong>没有 <code>src/lib.rs</code> 文件</strong>：你的项目将不会包含一个独立的库 crate。</li>
<li><strong><code>src/main.rs</code> 作为主入口</strong>：所有功能将最终通过 <code>src/main.rs</code> 来使用。</li>
<li><strong>模块文件直接在 <code>src/</code> 目录下或其子目录中</strong>：像 <code>src/garden.rs</code> 在 Backyard 项目中一样，你可以在 <code>src/</code> 目录下创建 <code>restaurant_logic.rs</code> 或者 <code>front_of_house.rs</code> 等文件，这些文件会通过 <code>mod</code> 声明被 <code>src/main.rs</code> 包含进来。</li>
</ol>
<p><strong>修改后的餐厅项目结构（类似 Backyard）</strong>：</p>
<p>首先，创建一个新的二进制项目 (如果你之前创建的是库项目，可以新建一个)：</p>
<p>Bash</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cargo new restaurant_app</span><br><span class="line">cd restaurant_app</span><br></pre></td></tr></table></figure>

<p>然后，修改 <code>src/main.rs</code> 来声明和使用模块。</p>
<p><strong>项目文件结构：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">restaurant_app/</span><br><span class="line">├── Cargo.toml</span><br><span class="line">└── src/</span><br><span class="line">    ├── front_of_house.rs  # 对应 Backyard 项目中的 garden.rs</span><br><span class="line">    ├── front_of_house/    # 对应 Backyard 项目中的 garden/ 目录</span><br><span class="line">    │   └── hosting.rs     # 对应 Backyard 项目中的 garden/vegetables.rs</span><br><span class="line">    └── main.rs</span><br></pre></td></tr></table></figure>

<p><strong><code>src/main.rs</code> 的内容：</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明 front_of_house 模块。因为它是顶级模块，并且我们想让它可以在文件中定义，所以用 `mod 模块名;`</span></span><br><span class="line"><span class="comment">// 它会去查找 src/front_of_house.rs 或 src/front_of_house/mod.rs</span></span><br><span class="line"><span class="keyword">mod</span> front_of_house; <span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// 假设 front_of_house::hosting::add_to_waitlist 是公开的</span></span><br><span class="line">    front_of_house::hosting::<span class="title function_ invoke__">add_to_waitlist</span>(); <span class="comment">//</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;顾客已添加到等位列表！&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解释 <code>src/main.rs</code>：</strong></p>
<ul>
<li><code>mod front_of_house;</code> 这行告诉编译器，有一个名为 <code>front_of_house</code> 的模块，它的代码不在 <code>main.rs</code> 中内联，而是要去 <code>src/front_of_house.rs</code> 或 <code>src/front_of_house/mod.rs</code> 中寻找。在这个例子中，我们选择在 <code>src/front_of_house.rs</code> 中定义它。</li>
<li><code>fn main()</code> 中通过 <code>front_of_house::hosting::add_to_waitlist()</code> 来调用功能。这要求 <code>front_of_house</code> 模块及其内部的 <code>hosting</code> 模块和 <code>add_to_waitlist</code> 函数都被声明为 <code>pub</code>，才能被 <code>main</code> 函数访问。</li>
</ul>
<p><strong><code>src/front_of_house.rs</code> 的内容：</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 front_of_house 模块内声明 hosting 和 serving 子模块</span></span><br><span class="line"><span class="comment">// 它们会去查找 src/front_of_house/hosting.rs 或 src/front_of_house/hosting/mod.rs</span></span><br><span class="line"><span class="comment">// 以及 src/front_of_house/serving.rs 或 src/front_of_house/serving/mod.rs</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> hosting; <span class="comment">//</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> serving; <span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 你也可以在这里直接定义一些 front_of_house 模块特有的函数或结构体</span></span><br><span class="line"><span class="comment">// pub fn greet_customer() &#123;</span></span><br><span class="line"><span class="comment">//     println!(&quot;欢迎光临！&quot;);</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>解释 <code>src/front_of_house.rs</code>：</strong></p>
<ul>
<li>这里我们声明了 <code>hosting</code> 和 <code>serving</code> 这两个子模块，并使用了 <code>pub</code> 关键字，表示它们是公开的，可以被它们的父模块（<code>front_of_house</code>）和通过路径访问到 <code>front_of_house</code> 的其他代码（例如 <code>main.rs</code>）使用。</li>
<li>由于是在 <code>src/front_of_house.rs</code> 中声明的，Rust 会继续在 <code>src/front_of_house/</code> 目录下查找 <code>hosting.rs</code> 和 <code>serving.rs</code>。</li>
</ul>
<p><strong><code>src/front_of_house/hosting.rs</code> 的内容：</strong></p>
<p>Rust</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">add_to_waitlist</span>() &#123; <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 实际的等位逻辑</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;顾客已加入等位列表。&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">seat_at_table</span>() &#123; <span class="comment">//</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;顾客已入座。&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><code>src/front_of_house/serving.rs</code> 的内容：</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">take_order</span>() &#123; <span class="comment">//</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;正在点餐...&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">serve_order</span>() &#123; <span class="comment">//</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;正在上菜...&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">take_payment</span>() &#123; <span class="comment">//</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;正在付款...&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行：</p>
<p>现在你可以运行 cargo run，它会编译并执行 src&#x2F;main.rs 中的代码，从而调用你组织在不同文件和模块中的餐厅功能。</p>
<p>这种方式的好处是，你不需要一个单独的库 crate 就能将代码分解到多个文件中，保持项目的整洁和组织性。所有的代码最终都编译成一个单一的二进制可执行文件。</p>
<h3 id="两种模块化的优劣-独立库-Crate-推荐-单一二进制-Crate-简化"><a href="#两种模块化的优劣-独立库-Crate-推荐-单一二进制-Crate-简化" class="headerlink" title="两种模块化的优劣(独立库 Crate (推荐)单一二进制 Crate (简化))"></a>两种模块化的优劣(独立库 Crate (推荐)单一二进制 Crate (简化))</h3><p>这两种实现模块化的方式（即：将功能代码放在一个独立的库 crate 中供二进制 crate 使用，或者将所有模块都作为单一二进制 crate 的一部分）没有绝对的“孰优孰劣”，而是<strong>取决于你的项目需求和目标</strong>。</p>
<p>以下是它们的优缺点对比：</p>
<h3 id="1-将功能代码作为独立库-Crate-的一部分（src-lib-rs-src-main-rs）"><a href="#1-将功能代码作为独立库-Crate-的一部分（src-lib-rs-src-main-rs）" class="headerlink" title="1. 将功能代码作为独立库 Crate 的一部分（src/lib.rs + src/main.rs）"></a>1. 将功能代码作为独立库 Crate 的一部分（<code>src/lib.rs</code> + <code>src/main.rs</code>）</h3><p><strong>优点：</strong></p>
<ul>
<li><strong>代码复用性强</strong>：<ul>
<li>这是最主要的好处。如果你的核心功能将来可能被其他项目、其他二进制工具或测试用例使用，将其封装在一个库 crate 中是最佳选择。其他项目可以直接添加你的库 crate 作为依赖。</li>
<li>你的二进制 crate (<code>src/main.rs</code> 或 <code>src/bin/*.rs</code>) 可以像使用任何外部依赖一样 <code>use</code> 这个库 crate 中的功能。</li>
</ul>
</li>
<li><strong>清晰的职责分离</strong>：库 crate 专注于提供核心功能，而二进制 crate 专注于提供可执行的应用程序入口或命令行界面。这种分离使得代码结构更清晰，更易于理解和维护。</li>
<li><strong>更好的测试粒度</strong>：你可以独立地对库 crate 进行单元测试和集成测试，因为它不依赖于 <code>main</code> 函数或特定的程序入口，这使得测试更纯粹和高效。</li>
<li><strong>减少主二进制文件大小（潜在）</strong>：如果你的库 crate 包含大量可选功能，并且你的二进制 crate 只使用其中一部分，那么在某些编译优化下，最终的二进制文件可能更精简。</li>
<li><strong>便于分享</strong>：如果你想将你的核心功能发布到 crates.io 上供全球 Rust 开发者使用，那么它必须是一个库 crate。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li><strong>初始设置略复杂</strong>：你需要管理 <code>src/lib.rs</code> 和 <code>src/main.rs</code> 两个入口文件，并确保它们之间的 <code>use</code> 路径正确。</li>
<li><strong>额外的层级</strong>：对于非常简单的项目，引入一个独立的库 crate 可能会显得有点“过度设计”，增加了不必要的抽象层级。</li>
</ul>
<h3 id="2-将所有模块都作为单一二进制-Crate-的一部分（只有-src-main-rs-和其内部模块文件）"><a href="#2-将所有模块都作为单一二进制-Crate-的一部分（只有-src-main-rs-和其内部模块文件）" class="headerlink" title="2. 将所有模块都作为单一二进制 Crate 的一部分（只有 src/main.rs 和其内部模块文件）"></a>2. 将所有模块都作为单一二进制 Crate 的一部分（只有 <code>src/main.rs</code> 和其内部模块文件）</h3><p><strong>优点：</strong></p>
<ul>
<li><strong>简单直接</strong>：对于小型或中型项目，如果代码不会被其他项目复用，这种方式是最直接和简单的。你只需要管理一个主要的 <code>main.rs</code> 入口文件。</li>
<li><strong>更容易快速启动</strong>：当你开始一个新项目，不确定哪些代码将来会复用时，这种结构更容易开始。</li>
<li><strong>所有代码编译成一个文件</strong>：最终生成一个单一的可执行文件，没有额外的库文件需要管理。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li><strong>代码复用性差</strong>：如果将来需要将某些功能用于其他项目，或者想将其作为独立的库发布，你就需要手动将这部分代码提取出来，并重新组织成一个库 crate，这会涉及到代码的迁移和路径的调整。</li>
<li><strong>职责不明确</strong>：所有的功能都被包含在同一个二进制 Crate 中，可能导致在大型项目中，核心逻辑和应用程序入口的边界变得模糊。</li>
<li><strong>测试可能更复杂</strong>：如果你想针对非 <code>main</code> 函数的某个内部模块进行独立的单元测试，你可能需要编写一些辅助代码或者使用特定的测试宏，而不能像库 crate 那样直接暴露接口进行测试。</li>
</ul>
<h3 id="总结与选择建议："><a href="#总结与选择建议：" class="headerlink" title="总结与选择建议："></a>总结与选择建议：</h3><table>
<thead>
<tr>
<th>特性&#x2F;场景</th>
<th>独立库 Crate (推荐)</th>
<th>单一二进制 Crate (简化)</th>
</tr>
</thead>
<tbody><tr>
<td><strong>复用性</strong></td>
<td>极佳，核心逻辑可被其他 Crate 引用</td>
<td>差，功能不易被外部项目复用</td>
</tr>
<tr>
<td><strong>项目规模</strong></td>
<td>适合中大型项目，或有复用需求的模块化设计</td>
<td>适合小型或一次性工具，无需对外暴露库功能</td>
</tr>
<tr>
<td><strong>代码组织</strong></td>
<td>清晰的职责分离，库归库，应用归应用</td>
<td>所有模块都在一个 Crate 内，结构可能更扁平</td>
</tr>
<tr>
<td><strong>测试</strong></td>
<td>便于独立测试核心库功能</td>
<td>内部模块测试可能需要更多设置</td>
</tr>
<tr>
<td><strong>发布</strong></td>
<td>可发布到 crates.io，供他人使用</td>
<td>通常只发布可执行文件，不作为库发布</td>
</tr>
<tr>
<td><strong>未来扩展性</strong></td>
<td>高，方便拆分功能和引入新二进制程序</td>
<td>低，后续功能拆分或复用成本较高</td>
</tr>
</tbody></table>
<p><strong>我的建议是：</strong></p>
<ul>
<li><strong>如果你不确定将来是否需要复用代码，或者项目规模可能会增长，</strong> <strong>优先选择“独立库 Crate + 二进制 Crate”的模式</strong>。即使是现在看起来很小的功能，未来也可能被需要。这种结构一开始可能多了一点点设置，但从长远来看可以节省大量重构时间。</li>
<li><strong>如果你确信这是一个非常小、一次性、且永远不会被其他项目复用的工具或脚本，</strong> 那么只使用单一二进制 Crate 的方式会更简单直接。</li>
</ul>
<p>大多数成熟的 Rust 项目，即使是最终产生一个可执行程序的项目，也会倾向于将其核心逻辑放在 <code>src/lib.rs</code> 中，并通过 <code>src/main.rs</code> 来调用这个库，从而获得更好的模块化、复用性和可测试性。</p>
<p>在我们写C语言项目时,经常会有src,inc目录,我们自己编写或者下载好的.h.c文件塞进去,将它们添加进编译列表,然后就可以在项目中使用它们了,RUST中的模块系统是与之类似的,以下是AI给出的两者之间的联系以及区别</p>
<h2 id="Rust-模块系统与-C-语言文件组织对比"><a href="#Rust-模块系统与-C-语言文件组织对比" class="headerlink" title="Rust 模块系统与 C 语言文件组织对比"></a>Rust 模块系统与 C 语言文件组织对比</h2><p>在 C 语言项目中，我们通常将源代码 (<code>.c</code> 文件) 放在 <code>src</code> 目录，头文件 (<code>.h</code> 文件) 放在 <code>inc</code> (或 <code>include</code>) 目录。Rust 的模块系统与 C 语言这种文件组织方式在<strong>逻辑上有一些相似之处，但在实现和理念上存在显著不同</strong>。</p>
<h3 id="相似之处"><a href="#相似之处" class="headerlink" title="相似之处"></a>相似之处</h3><ol>
<li><strong>代码组织与复用：</strong> 无论是 C 语言的头文件&#x2F;源文件分离，还是 Rust 的模块，核心目的都是为了更好地组织代码、提高可读性，并实现代码的复用。通过将相关功能封装在一起，可以避免命名冲突，并使得项目结构更加清晰。</li>
<li><strong>隐藏实现细节：</strong> C 语言中，头文件声明了函数和变量的接口，而 <code>.c</code> 文件包含具体实现。外部用户只需要包含头文件，不需要关心 <code>.c</code> 文件内部的实现细节。Rust 的模块系统也提供了类似的能力，通过 <code>pub</code> 关键字控制可见性，可以隐藏内部实现，只暴露公共 API。</li>
<li><strong>编译单元的概念：</strong> C 语言的 <code>.c</code> 文件是独立的编译单元，通过 <code>#include</code> 预处理器指令将头文件内容插入到编译单元中。Rust 的模块在编译时也会被编译器处理，形成逻辑上的编译单元。</li>
</ol>
<h3 id="不同之处"><a href="#不同之处" class="headerlink" title="不同之处"></a>不同之处</h3><ol>
<li><strong>声明与定义的绑定方式：</strong><ul>
<li><strong>C 语言：</strong> C 语言通过预处理器宏 <code>#include</code> 将头文件的内容（声明）复制到源文件中。编译时，编译器需要同时看到声明和定义，或者通过链接器在链接阶段解析符号。这种方式相对松散，容易出现头文件循环引用、重复定义等问题。</li>
<li><strong>Rust：</strong> Rust 的模块系统是语言级别内置的。它通过 <code>mod</code> 关键字定义模块，并通过 <code>use</code> 关键字引入路径。Rust 编译器在编译时会理解模块的层级结构和可见性规则，不需要像 C 语言那样手动管理头文件依赖。这使得 Rust 的模块管理更加健壮和安全。</li>
</ul>
</li>
<li><strong>可见性控制：</strong><ul>
<li><strong>C 语言：</strong> C 语言主要通过头文件来控制可见性。头文件中声明的符号默认是外部可见的，<code>.c</code> 文件中定义的 <code>static</code> 变量或函数才是文件私有的。</li>
<li><strong>Rust：</strong> Rust 提供了更细粒度的可见性控制。默认情况下，模块中的项（函数、结构体、枚举等）是私有的 (<code>private</code>)，只有通过 <code>pub</code> 关键字明确声明的项才是公共的。此外，Rust 还支持 <code>pub(crate)</code>（当前 crate 可见）、<code>pub(super)</code>（父模块可见）等更灵活的可见性修饰符，极大地增强了封装性。</li>
</ul>
</li>
<li><strong>命名空间与路径：</strong><ul>
<li><strong>C 语言：</strong> C 语言没有内置的命名空间机制，通常通过前缀（例如 <code>my_library_function</code>）来避免不同库之间的命名冲突。头文件的路径管理也相对简单，就是文件系统的路径。</li>
<li><strong>Rust：</strong> Rust 的模块系统本身就提供了强大的命名空间管理。每个模块都有自己的路径，例如 <code>crate::module_name::sub_module::item</code>。通过 <code>use</code> 关键字，我们可以引入特定的项到当前作用域，或者使用 <code>as</code> 关键字为引入的项创建别名，从而解决潜在的命名冲突。这种基于路径的命名空间机制使得代码组织更加清晰和安全。</li>
</ul>
</li>
<li><strong>文件与模块的对应关系：</strong><ul>
<li><strong>C 语言：</strong> 通常一个 <code>.c</code> 文件对应一个独立的编译单元，并可能有一个对应的 <code>.h</code> 文件用于声明接口。</li>
<li><strong>Rust：</strong> 在 Rust 中，一个文件可以包含多个模块，或者一个模块可以分散在多个文件中（通过 <code>mod name;</code> 语法）。Rust 的文件系统布局约定是模块系统的一部分，例如，一个 <code>mod foo;</code> 声明会查找 <code>foo.rs</code> 文件或 <code>foo/mod.rs</code> 目录来加载模块内容。这种灵活的对应关系使得代码组织可以更好地反映逻辑结构。</li>
</ul>
</li>
<li><strong>宏与预处理器：</strong><ul>
<li><strong>C 语言：</strong> 严重依赖预处理器宏（<code>#define</code>, <code>#ifdef</code> 等）进行条件编译、代码生成等操作。</li>
<li><strong>Rust：</strong> Rust 拥有功能更强大的宏系统（过程宏、声明宏），它们在编译时执行，并且具有更好的类型安全性。Rust 强调零成本抽象，通过类型系统和编译器在编译阶段捕获错误，而不是依赖运行时检查或预处理器。</li>
</ul>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/07/21/RUST%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0%E4%B9%8B%E6%9E%9A%E4%B8%BE%E5%92%8C%E7%BB%93%E6%9E%84%E5%8C%B9%E9%85%8D/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.png">
      <meta itemprop="name" content="Chillward">
      <meta itemprop="description" content="谁躺在漆黑的舞台上，用身体迎接着光芒">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chillward的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/07/21/RUST%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0%E4%B9%8B%E6%9E%9A%E4%B8%BE%E5%92%8C%E7%BB%93%E6%9E%84%E5%8C%B9%E9%85%8D/" class="post-title-link" itemprop="url">RUST学习日记之枚举和结构匹配</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-07-21 16:34:40 / 修改时间：19:08:24" itemprop="dateCreated datePublished" datetime="2025-07-21T16:34:40+08:00">2025-07-21</time>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>17k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>31 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>RUST中的枚举远比C语言中的强大的多。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">IpAddrKind</span> &#123;</span><br><span class="line">    V4,</span><br><span class="line">    V6,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">four</span> = IpAddrKind::V4;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">six</span> = IpAddrKind::V6;</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">route</span>(IpAddrKind::V4);</span><br><span class="line">    <span class="title function_ invoke__">route</span>(IpAddrKind::V6);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">route</span>(ip_kind: IpAddrKind) &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>第一个巨大的不同之处就是:RUST的枚举可以关联不同类型和数量的数据</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">IpAddr</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">V4</span>(<span class="type">u8</span>, <span class="type">u8</span>, <span class="type">u8</span>, <span class="type">u8</span>),</span><br><span class="line">    <span class="title function_ invoke__">V6</span>(<span class="type">String</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">home</span> = IpAddr::<span class="title function_ invoke__">V4</span>(<span class="number">127</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">loopback</span> = IpAddr::<span class="title function_ invoke__">V6</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;::1&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>这无疑是非常灵活方便的，当然RUST的枚举可以关联结构体，甚至可以再关联一个枚举。</p>
<p>RUST还允许我们像给结构体定义方法一样给枚举定义方法</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">Message</span> &#123;</span><br><span class="line">        Quit,</span><br><span class="line">        Move &#123; x: <span class="type">i32</span>, y: <span class="type">i32</span> &#125;,</span><br><span class="line">        <span class="title function_ invoke__">Write</span>(<span class="type">String</span>),</span><br><span class="line">        <span class="title function_ invoke__">ChangeColor</span>(<span class="type">i32</span>, <span class="type">i32</span>, <span class="type">i32</span>),</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">impl</span> <span class="title class_">Message</span> &#123;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">call</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">            <span class="comment">// 在这里定义方法体</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">m</span> = Message::<span class="title function_ invoke__">Write</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>));</span><br><span class="line">    m.<span class="title function_ invoke__">call</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Option枚举"><a href="#Option枚举" class="headerlink" title="Option枚举"></a>Option枚举</h3><p>RUST中没有类似于C语言的NULL这种东西，在C语言中，假设你malloc&#x2F;calloc一个内存区域，如果失败了，会返回一个NULL，调用者需要手动处理NULL的情况，不然程序就会出现bug，而RUST通过Option枚举避免了这种问题。</p>
<p>问题不在于概念而在于具体的实现。为此，Rust 并没有空值，不过它确实拥有一个可以编码存在或不存在概念的枚举。这个枚举是 <code>Option&lt;T&gt;</code>，而且它<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/option/enum.Option.html">定义于标准库中</a>，如下：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#![allow(unused)]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Option</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="literal">None</span>,</span><br><span class="line">    <span class="title function_ invoke__">Some</span>(T),</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Option&lt;T&gt;</code> 枚举是如此有用以至于它甚至被包含在了 prelude 之中，无需将其显式引入作用域。另外，它的变体也是如此：可以不需要 <code>Option::</code> 前缀来直接使用 <code>Some</code> 和 <code>None</code>。即便如此 <code>Option&lt;T&gt;</code> 也仍是常规的枚举，<code>Some(T)</code> 和 <code>None</code> 仍是 <code>Option&lt;T&gt;</code> 的变体。</p>
<p><code>&lt;T&gt;</code> 语法是一个我们还未讲到的 Rust 功能。它是一个泛型类型参数，第十章会更详细的讲解泛型。目前，所有你需要知道的就是 <code>&lt;T&gt;</code> 意味着 <code>Option</code> 枚举的 <code>Some</code> 变体可以包含任意类型的数据，同时每一个用于 <code>T</code> 位置的具体类型使得 <code>Option&lt;T&gt;</code> 整体作为不同的类型。这里是一些包含数字类型和字符类型 <code>Option</code> 值的例子：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">some_number</span> = <span class="title function_ invoke__">Some</span>(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">some_char</span> = <span class="title function_ invoke__">Some</span>(<span class="string">&#x27;e&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">absent_number</span>: <span class="type">Option</span>&lt;<span class="type">i32</span>&gt; = <span class="literal">None</span>;</span><br></pre></td></tr></table></figure>

<p><code>some_number</code> 的类型是 <code>Option&lt;i32&gt;</code>。<code>some_char</code> 的类型是 <code>Option&lt;char&gt;</code>，是不同于 <code>some_number</code> 的类型。因为我们在 <code>Some</code> 变体中指定了值，Rust 可以推断其类型。对于 <code>absent_number</code>，Rust 需要我们指定 <code>Option</code> 整体的类型，因为编译器只通过 <code>None</code> 值无法推断出 <code>Some</code> 变体保存的值的类型。这里我们告诉 Rust 希望 <code>absent_number</code> 是 <code>Option&lt;i32&gt;</code> 类型的。</p>
<p>当有一个 <code>Some</code> 值时，我们就知道存在一个值，而这个值保存在 <code>Some</code> 中。当有个 <code>None</code> 值时，在某种意义上，它跟空值具有相同的意义：并没有一个有效的值。那么，<code>Option&lt;T&gt;</code> 为什么就比空值要好呢？</p>
<p>简而言之，因为 <code>Option&lt;T&gt;</code> 和 <code>T</code>（这里 <code>T</code> 可以是任何类型）是不同的类型，编译器不允许像一个肯定有效的值那样使用 <code>Option&lt;T&gt;</code>。例如，这段代码不能编译，因为它尝试将 <code>Option&lt;i8&gt;</code> 与 <code>i8</code> 相加：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">x</span>: <span class="type">i8</span> = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">y</span>: <span class="type">Option</span>&lt;<span class="type">i8</span>&gt; = <span class="title function_ invoke__">Some</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">sum</span> = x + y;</span><br></pre></td></tr></table></figure>

<p>如果运行这些代码，将得到类似这样的错误信息：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cargo run</span></span><br><span class="line">   Compiling enums v0.1.0 (file:///projects/enums)</span><br><span class="line">error[E0277]: cannot add `Option&lt;i8&gt;` to `i8`</span><br><span class="line"><span class="meta prompt_"> --&gt; </span><span class="language-bash">src/main.rs:5:17</span></span><br><span class="line">  |</span><br><span class="line">5 |     let sum = x + y;</span><br><span class="line">  |                 ^ no implementation for `i8 + Option&lt;i8&gt;`</span><br><span class="line">  |</span><br><span class="line">  = help: the trait `Add&lt;Option&lt;i8&gt;&gt;` is not implemented for `i8`</span><br><span class="line">  = help: the following other types implement trait `Add&lt;Rhs&gt;`:</span><br><span class="line">            `&amp;i8` implements `Add&lt;i8&gt;`</span><br><span class="line">            `&amp;i8` implements `Add`</span><br><span class="line">            `i8` implements `Add&lt;&amp;i8&gt;`</span><br><span class="line">            `i8` implements `Add`</span><br><span class="line"></span><br><span class="line">For more information about this error, try `rustc --explain E0277`.</span><br><span class="line">error: could not compile `enums` (bin &quot;enums&quot;) due to 1 previous error</span><br></pre></td></tr></table></figure>

<p>很好！事实上，错误信息意味着 Rust 不知道该如何将 <code>Option&lt;i8&gt;</code> 与 <code>i8</code> 相加，因为它们的类型不同。当在 Rust 中拥有一个像 <code>i8</code> 这样类型的值时，编译器确保它总是有一个有效的值。我们可以自信地使用而无需做空值检查。只有当使用 <code>Option&lt;i8&gt;</code>（或者任何用到的类型）的时候需要担心可能没有值，而编译器会确保我们在使用值之前处理了为空的情况。</p>
<p>换句话说，在对 <code>Option&lt;T&gt;</code> 进行运算之前必须将其转换为 <code>T</code>。通常这能帮助我们捕获到空值最常见的问题之一：假设某值不为空但实际上为空的情况。</p>
<p>消除了错误地假设一个非空值的风险，会让你对代码更加有信心。为了拥有一个可能为空的值，你必须要显式的将其放入对应类型的 <code>Option&lt;T&gt;</code> 中。接着，当使用这个值时，必须明确的处理值为空的情况。只要一个值不是 <code>Option&lt;T&gt;</code> 类型，你就<strong>可以</strong>安全的认定它的值不为空。这是 Rust 的一个经过深思熟虑的设计决策，来限制空值的泛滥以增加 Rust 代码的安全性。</p>
<p>那么当有一个 <code>Option&lt;T&gt;</code> 的值时，如何从 <code>Some</code> 变体中取出 <code>T</code> 的值来使用它呢？<code>Option&lt;T&gt;</code> 枚举拥有大量用于各种情况的方法：你可以查看<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/option/enum.Option.html">它的文档</a>。熟悉 <code>Option&lt;T&gt;</code> 的方法将对你的 Rust 之旅非常有用。</p>
<p>总的来说，为了使用 <code>Option&lt;T&gt;</code> 值，需要编写处理每个变体的代码。你想要一些代码只当拥有 <code>Some(T)</code> 值时运行，允许这些代码使用其中的 <code>T</code>。也希望一些代码只在值为 <code>None</code> 时运行，这些代码并没有一个可用的 <code>T</code> 值。<code>match</code> 表达式就是这么一个处理枚举的控制流结构：它会根据枚举的变体运行不同的代码，这些代码可以使用匹配到的值中的数据。</p>
<p>除了match跟if let外，还有以下方法可以提取Option&lt;&gt;中的值</p>
<h3 id="unwrap-和-expect"><a href="#unwrap-和-expect" class="headerlink" title="unwrap() 和 expect()"></a><code>unwrap()</code> 和 <code>expect()</code></h3><p><code>unwrap()</code> 和 <code>expect()</code> 是提取 <code>Option</code> 值的直接方法，但它们是不安全的，因为它们在 <code>Option</code> 是 <code>None</code> 时会<strong>panic</strong>（导致程序崩溃）。</p>
<ul>
<li><p><strong><code>unwrap()</code></strong>: 如果 <code>Option</code> 是 <code>Some(T)</code>，它会返回 <code>T</code>。如果 <code>Option</code> 是 <code>None</code>，它会 panic。</p>
<p>Rust</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let some_value = Some(100);</span><br><span class="line">    let value = some_value.unwrap(); // value is 100</span><br><span class="line">    println!(&quot;Unwrapped value: &#123;&#125;&quot;, value);</span><br><span class="line"></span><br><span class="line">    let none_value: Option&lt;i32&gt; = None;</span><br><span class="line">    // let another_value = none_value.unwrap(); // 这行代码会导致 panic!</span><br><span class="line">    // println!(&quot;Another unwrapped value: &#123;&#125;&quot;, another_value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>expect(&quot;自定义错误信息&quot;)</code></strong>: 和 <code>unwrap()</code> 类似，但允许你提供一个自定义的 panic 错误信息，这在调试时很有用。</p>
<p>Rust</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let file_content = Some(String::from(&quot;Some text in the file.&quot;));</span><br><span class="line">    let content = file_content.expect(&quot;文件内容不存在！&quot;);</span><br><span class="line">    println!(&quot;文件内容: &#123;&#125;&quot;, content);</span><br><span class="line"></span><br><span class="line">    let empty_file: Option&lt;String&gt; = None;</span><br><span class="line">    // let empty_content = empty_file.expect(&quot;读取文件失败，文件为空或不存在。&quot;); // 这行代码会导致 panic!</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>重要提示：</strong> 除非你百分之百确定 <code>Option</code> 永远不会是 <code>None</code>（或者在 <code>None</code> 的情况下程序崩溃是可以接受的），否则<strong>应避免使用 <code>unwrap()</code> 和 <code>expect()</code></strong>。它们主要用于原型开发、测试或在明确知道 <code>None</code> 是一个不可恢复的错误时。</p>
<h3 id="unwrap-or-unwrap-or-default-unwrap-or-else"><a href="#unwrap-or-unwrap-or-default-unwrap-or-else" class="headerlink" title="unwrap_or(), unwrap_or_default(), unwrap_or_else()"></a><code>unwrap_or()</code>, <code>unwrap_or_default()</code>, <code>unwrap_or_else()</code></h3><p>这些方法提供了在 <code>Option</code> 是 <code>None</code> 时提供一个默认值或通过闭包计算一个默认值的方式，而不会 panic。</p>
<ul>
<li><p><strong><code>unwrap_or(default_value)</code></strong>: 如果 <code>Option</code> 是 <code>Some(T)</code>，返回 <code>T</code>。如果 <code>Option</code> 是 <code>None</code>，返回提供的 <code>default_value</code>。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">user_input</span> = <span class="title function_ invoke__">Some</span>(<span class="string">&quot;Hello&quot;</span>.<span class="title function_ invoke__">to_string</span>());</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span> = user_input.<span class="title function_ invoke__">unwrap_or</span>(<span class="string">&quot;Guest&quot;</span>.<span class="title function_ invoke__">to_string</span>());</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;欢迎: &#123;&#125;&quot;</span>, result); <span class="comment">// 输出: 欢迎: Hello</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">no_input</span>: <span class="type">Option</span>&lt;<span class="type">String</span>&gt; = <span class="literal">None</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result_none</span> = no_input.<span class="title function_ invoke__">unwrap_or</span>(<span class="string">&quot;Guest&quot;</span>.<span class="title function_ invoke__">to_string</span>());</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;欢迎: &#123;&#125;&quot;</span>, result_none); <span class="comment">// 输出: 欢迎: Guest</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>unwrap_or_default()</code></strong>: 如果 <code>Option</code> 是 <code>Some(T)</code>，返回 <code>T</code>。如果 <code>Option</code> 是 <code>None</code>，返回 <code>T</code> 类型的默认值（要求 <code>T</code> 实现 <code>Default</code> trait）。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">count</span> = <span class="title function_ invoke__">Some</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">num</span> = count.<span class="title function_ invoke__">unwrap_or_default</span>(); <span class="comment">// num 是 5</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Count: &#123;&#125;&quot;</span>, num);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">no_count</span>: <span class="type">Option</span>&lt;<span class="type">u32</span>&gt; = <span class="literal">None</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">default_num</span> = no_count.<span class="title function_ invoke__">unwrap_or_default</span>(); <span class="comment">// default_num 是 0 (u32 的默认值)</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Default Count: &#123;&#125;&quot;</span>, default_num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>unwrap_or_else(|| &#123; /\* 闭包计算默认值 \*/ &#125;)</code></strong>: 如果 <code>Option</code> 是 <code>Some(T)</code>，返回 <code>T</code>。如果 <code>Option</code> 是 <code>None</code>，执行提供的闭包并返回其结果。这在计算默认值比较复杂或有副作用时很有用。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">get_default_username</span>() <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;正在生成默认用户名...&quot;</span>);</span><br><span class="line">    <span class="string">&quot;Anonymous&quot;</span>.<span class="title function_ invoke__">to_string</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">username</span> = <span class="title function_ invoke__">Some</span>(<span class="string">&quot;Alice&quot;</span>.<span class="title function_ invoke__">to_string</span>());</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">final_username</span> = username.<span class="title function_ invoke__">unwrap_or_else</span>(|| <span class="title function_ invoke__">get_default_username</span>());</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;用户: &#123;&#125;&quot;</span>, final_username);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">no_username</span>: <span class="type">Option</span>&lt;<span class="type">String</span>&gt; = <span class="literal">None</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">final_no_username</span> = no_username.<span class="title function_ invoke__">unwrap_or_else</span>(|| <span class="title function_ invoke__">get_default_username</span>());</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;用户: &#123;&#125;&quot;</span>, final_no_username);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="5-其他辅助方法"><a href="#5-其他辅助方法" class="headerlink" title="5. 其他辅助方法"></a>5. 其他辅助方法</h3><p><code>Option</code> 还提供了许多其他有用的方法，例如：</p>
<ul>
<li><strong><code>is_some()</code></strong>: 返回 <code>true</code> 如果是 <code>Some</code>，否则返回 <code>false</code>。</li>
<li><strong><code>is_none()</code></strong>: 返回 <code>true</code> 如果是 <code>None</code>，否则返回 <code>false</code>。</li>
<li><strong><code>map(|value| new_value)</code></strong>: 如果是 <code>Some(T)</code>，应用闭包到 <code>T</code> 并返回 <code>Some(U)</code>；如果是 <code>None</code>，返回 <code>None</code>。用于转换 <code>Option</code> 内的值类型。</li>
<li><strong><code>and_then(|value| Option&lt;U&gt;)</code></strong>: 如果是 <code>Some(T)</code>，应用闭包到 <code>T</code>（闭包返回另一个 <code>Option</code>）并返回结果；如果是 <code>None</code>，返回 <code>None</code>。常用于链式处理多个可能失败的操作。</li>
</ul>
<h2 id="match-控制流结构"><a href="#match-控制流结构" class="headerlink" title="match 控制流结构"></a><a target="_blank" rel="noopener" href="https://kaisery.github.io/trpl-zh-cn/ch06-02-match.html#match-%E6%8E%A7%E5%88%B6%E6%B5%81%E7%BB%93%E6%9E%84"><code>match</code> 控制流结构</a></h2><p>Rust 有一个叫做 <code>match</code> 的极为强大的控制流运算符，它允许我们将一个值与一系列的模式相比较，并根据相匹配的模式执行相应代码。模式可由字面值、变量、通配符和许多其他内容构成；<a target="_blank" rel="noopener" href="https://kaisery.github.io/trpl-zh-cn/ch19-00-patterns.html">第十九章</a>会涉及到所有不同种类的模式以及它们的作用。<code>match</code> 的力量来源于模式的表现力，以及编译器能够确认所有可能情况均已被覆盖。</p>
<p>可以把 <code>match</code> 表达式想象成某种硬币分类器：硬币滑入有着不同大小孔洞的轨道，每一个硬币都会掉入符合它大小的孔洞。同样地，值也会通过 <code>match</code> 的每一个模式，并且在遇到第一个 “符合” 的模式时，值会进入相关联的代码块并在执行中被使用。</p>
<p>因为刚刚提到了硬币，让我们用它们来作为一个使用 <code>match</code> 的例子！我们可以编写一个函数来获取一个未知的美国硬币，并以一种类似验钞机的方式，确定它是何种硬币并返回它的美分值，如示例 6-3 中所示。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Coin</span> &#123;</span><br><span class="line">    Penny,</span><br><span class="line">    Nickel,</span><br><span class="line">    Dime,</span><br><span class="line">    Quarter,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">value_in_cents</span>(coin: Coin) <span class="punctuation">-&gt;</span> <span class="type">u8</span> &#123;</span><br><span class="line">    <span class="keyword">match</span> coin &#123;</span><br><span class="line">        Coin::Penny =&gt; <span class="number">1</span>,</span><br><span class="line">        Coin::Nickel =&gt; <span class="number">5</span>,</span><br><span class="line">        Coin::Dime =&gt; <span class="number">10</span>,</span><br><span class="line">        Coin::Quarter =&gt; <span class="number">25</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例 6-3：一个枚举和一个以枚举变体作为模式的 <code>match</code> 表达式</p>
<p>拆开 <code>value_in_cents</code> 函数中的 <code>match</code> 来看。首先，我们列出 <code>match</code> 关键字后跟一个表达式，在这个例子中是 <code>coin</code> 的值。这看起来非常像 <code>if</code> 所使用的条件表达式，不过这里有一个非常大的区别：对于 <code>if</code>，表达式必须返回一个布尔值，而这里它可以是任何类型的。例子中的 <code>coin</code> 的类型是示例 6-3 中定义的 <code>Coin</code> 枚举。</p>
<p>接下来是 <code>match</code> 的分支。一个分支有两个部分：一个模式和一些代码。第一个分支的模式是值 <code>Coin::Penny</code> 而之后的 <code>=&gt;</code> 运算符将模式和将要运行的代码分开。这里的代码就仅仅是值 <code>1</code>。每一个分支之间使用逗号分隔。</p>
<p>当 <code>match</code> 表达式执行时，它将结果值按顺序与每一个分支的模式相比较。如果模式匹配了这个值，这个模式相关联的代码将被执行。如果模式并不匹配这个值，将继续执行下一个分支，非常类似一个硬币分类器。可以拥有任意多的分支：示例 6-3 中的 <code>match</code> 有四个分支。</p>
<p>每个分支相关联的代码是一个表达式，而表达式的结果值将作为整个 <code>match</code> 表达式的返回值。</p>
<p>如果分支代码较短的话通常不使用大括号，正如示例 6-3 中的每个分支都只是返回一个值。如果想要在分支中运行多行代码，可以使用大括号，而分支后的逗号是可选的。例如，如下代码在每次使用<code>Coin::Penny</code> 调用时都会打印出 “Lucky penny!”，同时仍然返回代码块最后的值，<code>1</code>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">value_in_cents</span>(coin: Coin) <span class="punctuation">-&gt;</span> <span class="type">u8</span> &#123;</span><br><span class="line">    <span class="keyword">match</span> coin &#123;</span><br><span class="line">        Coin::Penny =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Lucky penny!&quot;</span>);</span><br><span class="line">            <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        Coin::Nickel =&gt; <span class="number">5</span>,</span><br><span class="line">        Coin::Dime =&gt; <span class="number">10</span>,</span><br><span class="line">        Coin::Quarter =&gt; <span class="number">25</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="绑定值的模式"><a href="#绑定值的模式" class="headerlink" title="绑定值的模式"></a><a target="_blank" rel="noopener" href="https://kaisery.github.io/trpl-zh-cn/ch06-02-match.html#%E7%BB%91%E5%AE%9A%E5%80%BC%E7%9A%84%E6%A8%A1%E5%BC%8F">绑定值的模式</a></h3><p>匹配分支的另一个有用的功能是可以绑定匹配的模式的部分值。这也就是如何从枚举变体中提取值的。</p>
<p>作为一个例子，让我们修改枚举的一个变体来存放数据。1999 年到 2008 年间，美国在 25 美分的硬币的一侧为 50 个州的每一个都印刷了不同的设计。其他的硬币都没有这种区分州的设计，所以只有这些 25 美分硬币有特殊的价值。可以将这些信息加入我们的 <code>enum</code>，通过改变 <code>Quarter</code> 变体来包含一个 <code>State</code> 值，示例 6-4 中完成了这些修改：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span> <span class="comment">// 这样可以立刻看到州的名称</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">UsState</span> &#123;</span><br><span class="line">    Alabama,</span><br><span class="line">    Alaska,</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Coin</span> &#123;</span><br><span class="line">    Penny,</span><br><span class="line">    Nickel,</span><br><span class="line">    Dime,</span><br><span class="line">    <span class="title function_ invoke__">Quarter</span>(UsState),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例 6-4：<code>Quarter</code> 变体也存放了一个 <code>UsState</code> 值的 <code>Coin</code> 枚举</p>
<p>想象一下我们的一个朋友尝试收集所有 50 个州的 25 美分硬币。在根据硬币类型分类零钱的同时，也可以报告出每个 25 美分硬币所对应的州名称，这样如果我们的朋友没有的话，他可以将其加入收藏。</p>
<p>在这些代码的匹配表达式中，我们在匹配 <code>Coin::Quarter</code> 变体的分支的模式中增加了一个叫做 <code>state</code> 的变量。当匹配到 <code>Coin::Quarter</code> 时，变量 <code>state</code> 将会绑定 25 美分硬币所对应州的值。接着在那个分支的代码中使用 <code>state</code>，如下：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">value_in_cents</span>(coin: Coin) <span class="punctuation">-&gt;</span> <span class="type">u8</span> &#123;</span><br><span class="line">    <span class="keyword">match</span> coin &#123;</span><br><span class="line">        Coin::Penny =&gt; <span class="number">1</span>,</span><br><span class="line">        Coin::Nickel =&gt; <span class="number">5</span>,</span><br><span class="line">        Coin::Dime =&gt; <span class="number">10</span>,</span><br><span class="line">        Coin::<span class="title function_ invoke__">Quarter</span>(state) =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;State quarter from &#123;state:?&#125;!&quot;</span>);</span><br><span class="line">            <span class="number">25</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果调用 <code>value_in_cents(Coin::Quarter(UsState::Alaska))</code>，<code>coin</code> 将是 <code>Coin::Quarter(UsState::Alaska)</code>。当将值与每个分支相比较时，没有分支会匹配，直到遇到 <code>Coin::Quarter(state)</code>。这时，<code>state</code> 绑定的将会是值 <code>UsState::Alaska</code>。接着就可以在 <code>println!</code> 表达式中使用这个绑定了，像这样就可以获取 <code>Coin</code> 枚举的 <code>Quarter</code> 变体中内部的州的值。</p>
<h3 id="匹配-Option"><a href="#匹配-Option" class="headerlink" title="匹配 Option"></a><a target="_blank" rel="noopener" href="https://kaisery.github.io/trpl-zh-cn/ch06-02-match.html#%E5%8C%B9%E9%85%8D-optiont">匹配 <code>Option</code></a></h3><p>我们在之前的部分中使用 <code>Option&lt;T&gt;</code> 时，是为了从 <code>Some</code> 中取出其内部的 <code>T</code> 值；我们还可以像处理 <code>Coin</code> 枚举那样使用 <code>match</code> 处理 <code>Option&lt;T&gt;</code>！只不过这回比较的不再是硬币，而是 <code>Option&lt;T&gt;</code> 的变体，但 <code>match</code> 表达式的工作方式保持不变。</p>
<p>比如我们想要编写一个函数，它获取一个 <code>Option&lt;i32&gt;</code> ，如果其中含有一个值，将其加一。如果其中没有值，函数应该返回 <code>None</code> 值，而不尝试执行任何操作。</p>
<p>得益于 <code>match</code>，编写这个函数非常简单，它将看起来像示例 6-5 中这样：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">plus_one</span>(x: <span class="type">Option</span>&lt;<span class="type">i32</span>&gt;) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="type">i32</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">match</span> x &#123;</span><br><span class="line">        <span class="literal">None</span> =&gt; <span class="literal">None</span>,</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(i) =&gt; <span class="title function_ invoke__">Some</span>(i + <span class="number">1</span>),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">five</span> = <span class="title function_ invoke__">Some</span>(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">six</span> = <span class="title function_ invoke__">plus_one</span>(five);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">none</span> = <span class="title function_ invoke__">plus_one</span>(<span class="literal">None</span>);</span><br></pre></td></tr></table></figure>

<p>示例 6-5：一个在 <code>Option&lt;i32&gt;</code> 上使用 <code>match</code> 表达式的函数</p>
<p>让我们更仔细地检查 <code>plus_one</code> 的第一行操作。当调用 <code>plus_one(five)</code> 时，<code>plus_one</code> 函数体中的 <code>x</code> 将会是值 <code>Some(5)</code>。接着将其与每个分支比较。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">None</span> =&gt; <span class="literal">None</span>,</span><br></pre></td></tr></table></figure>

<p>值 <code>Some(5)</code> 并不匹配模式 <code>None</code>，所以继续进行下一个分支。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_ invoke__">Some</span>(i) =&gt; <span class="title function_ invoke__">Some</span>(i + <span class="number">1</span>),</span><br></pre></td></tr></table></figure>

<p><code>Some(5)</code> 与 <code>Some(i)</code> 匹配吗？当然匹配！它们是相同的变体。<code>i</code> 绑定了 <code>Some</code> 中包含的值，所以 <code>i</code> 的值是 <code>5</code>。接着匹配分支的代码被执行，所以我们将 <code>i</code> 的值加一并返回一个含有值 <code>6</code> 的新 <code>Some</code>。</p>
<p>接着考虑下示例 6-5 中 <code>plus_one</code> 的第二个调用，这里 <code>x</code> 是 <code>None</code>。我们进入 <code>match</code> 并与第一个分支相比较。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">None</span> =&gt; <span class="literal">None</span>,</span><br></pre></td></tr></table></figure>

<p>匹配成功！这里没有值来加一，所以程序结束并返回 <code>=&gt;</code> 右侧的值 <code>None</code>，因为第一个分支就匹配到了，其他的分支将不再比较。</p>
<p>将 <code>match</code> 与枚举相结合在很多场景中都是有用的。你会在 Rust 代码中看到很多这样的模式：<code>match</code> 一个枚举，绑定其中的值到一个变量，接着根据其值执行代码。这在一开始有点复杂，不过一旦习惯了，你会希望所有语言都拥有它！这一直是用户的最爱。</p>
<h3 id="匹配是穷尽的"><a href="#匹配是穷尽的" class="headerlink" title="匹配是穷尽的"></a><a target="_blank" rel="noopener" href="https://kaisery.github.io/trpl-zh-cn/ch06-02-match.html#%E5%8C%B9%E9%85%8D%E6%98%AF%E7%A9%B7%E5%B0%BD%E7%9A%84">匹配是穷尽的</a></h3><p><code>match</code> 还有另一方面需要讨论：这些分支必须覆盖了所有的可能性。考虑一下 <code>plus_one</code> 函数的这个版本，它有一个 bug 并不能编译：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">plus_one</span>(x: <span class="type">Option</span>&lt;<span class="type">i32</span>&gt;) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="type">i32</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">match</span> x &#123;</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(i) =&gt; <span class="title function_ invoke__">Some</span>(i + <span class="number">1</span>),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们没有处理 <code>None</code> 的情况，所以这些代码会造成一个 bug。幸运的是，这是一个 Rust 知道如何处理的 bug。如果尝试编译这段代码，会得到这个错误：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cargo run</span></span><br><span class="line">   Compiling enums v0.1.0 (file:///projects/enums)</span><br><span class="line">error[E0004]: non-exhaustive patterns: `None` not covered</span><br><span class="line"><span class="meta prompt_"> --&gt; </span><span class="language-bash">src/main.rs:3:15</span></span><br><span class="line">  |</span><br><span class="line">3 |         match x &#123;</span><br><span class="line">  |               ^ pattern `None` not covered</span><br><span class="line">  |</span><br><span class="line">note: `Option&lt;i32&gt;` defined here</span><br><span class="line"><span class="meta prompt_"> --&gt; </span><span class="language-bash">/rustc/4eb161250e340c8f48f66e2b929ef4a5bed7c181/library/core/src/option.rs:572:1</span></span><br><span class="line"> ::: /rustc/4eb161250e340c8f48f66e2b929ef4a5bed7c181/library/core/src/option.rs:576:5</span><br><span class="line">  |</span><br><span class="line">  = note: not covered</span><br><span class="line">  = note: the matched value is of type `Option&lt;i32&gt;`</span><br><span class="line">help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown</span><br><span class="line">  |</span><br><span class="line">4 ~             Some(i) =&gt; Some(i + 1),</span><br><span class="line">5 ~             None =&gt; todo!(),</span><br><span class="line">  |</span><br><span class="line"></span><br><span class="line">For more information about this error, try `rustc --explain E0004`.</span><br><span class="line">error: could not compile `enums` (bin &quot;enums&quot;) due to 1 previous error</span><br></pre></td></tr></table></figure>

<p>Rust 知道我们没有覆盖所有可能的情况甚至知道哪些模式被忘记了！Rust 中的匹配是 <strong>穷尽的</strong>（<em>exhaustive</em>）：必须穷举到最后的可能性来使代码有效。特别的在这个 <code>Option&lt;T&gt;</code> 的例子中，Rust 防止我们忘记明确的处理 <code>None</code> 的情况，这让我们免于假设拥有一个实际上为空的值，从而使之前提到的价值亿万的错误不可能发生。</p>
<h3 id="通配模式和-占位符"><a href="#通配模式和-占位符" class="headerlink" title="通配模式和 _ 占位符"></a><a target="_blank" rel="noopener" href="https://kaisery.github.io/trpl-zh-cn/ch06-02-match.html#%E9%80%9A%E9%85%8D%E6%A8%A1%E5%BC%8F%E5%92%8C-_-%E5%8D%A0%E4%BD%8D%E7%AC%A6">通配模式和 <code>_</code> 占位符</a></h3><p>使用枚举，我们也可以针对少数几个特定值执行特殊操作，而对其他所有值采取默认操作。想象我们正在玩一个游戏，如果你掷出骰子的值为 3，角色不会移动，而是会得到一顶新奇的帽子。如果你掷出了 7，你的角色将失去一顶新奇的帽子。对于其他的数值，你的角色会在棋盘上移动相应的格子。这是一个实现了上述逻辑的 <code>match</code>，骰子的结果是硬编码而不是一个随机值，其他的逻辑部分使用了没有函数体的函数来表示，实现它们超出了本例的范围：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">dice_roll</span> = <span class="number">9</span>;</span><br><span class="line"><span class="keyword">match</span> dice_roll &#123;</span><br><span class="line">    <span class="number">3</span> =&gt; <span class="title function_ invoke__">add_fancy_hat</span>(),</span><br><span class="line">    <span class="number">7</span> =&gt; <span class="title function_ invoke__">remove_fancy_hat</span>(),</span><br><span class="line">    other =&gt; <span class="title function_ invoke__">move_player</span>(other),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">add_fancy_hat</span>() &#123;&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">remove_fancy_hat</span>() &#123;&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">move_player</span>(num_spaces: <span class="type">u8</span>) &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>对于前两个分支，匹配模式是字面值 <code>3</code> 和 <code>7</code>，最后一个分支则涵盖了所有其他可能的值，模式是我们命名为 <code>other</code> 的一个变量。<code>other</code> 分支的代码通过将其传递给 <code>move_player</code> 函数来使用这个变量。</p>
<p>即使我们没有列出 <code>u8</code> 所有可能的值，这段代码依然能够编译，因为最后一个模式将匹配所有未被特殊列出的值。这种通配模式满足了 <code>match</code> 必须被穷尽的要求。请注意，我们必须将通配分支放在最后，因为模式是按顺序匹配的。如果我们在通配分支后添加其他分支，Rust 将会警告我们，因为此后的分支永远不会被匹配到。</p>
<p>Rust 还提供了一个模式，当我们不想使用通配模式获取的值时，请使用 <code>_</code> ，这是一个特殊的模式，可以匹配任意值而不绑定到该值。这告诉 Rust 我们不会使用这个值，所以 Rust 也不会警告我们存在未使用的变量。</p>
<p>让我们改变游戏规则：现在，当你掷出的值不是 3 或 7 的时候，你必须再次掷出。这种情况下我们不需要使用这个值，所以我们改动代码使用 <code>_</code> 来替代变量 <code>other</code> ：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">dice_roll</span> = <span class="number">9</span>;</span><br><span class="line"><span class="keyword">match</span> dice_roll &#123;</span><br><span class="line">    <span class="number">3</span> =&gt; <span class="title function_ invoke__">add_fancy_hat</span>(),</span><br><span class="line">    <span class="number">7</span> =&gt; <span class="title function_ invoke__">remove_fancy_hat</span>(),</span><br><span class="line">    _ =&gt; <span class="title function_ invoke__">reroll</span>(),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">add_fancy_hat</span>() &#123;&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">remove_fancy_hat</span>() &#123;&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">reroll</span>() &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>这个例子也满足穷尽性要求，因为我们在最后一个分支中显式地忽略了其它值。我们没有忘记处理任何东西。</p>
<p>最后，让我们再次改变游戏规则，如果你掷出 3 或 7 以外的值，你的回合将无事发生。我们可以使用单元值（在<a target="_blank" rel="noopener" href="https://kaisery.github.io/trpl-zh-cn/ch03-02-data-types.html#%E5%85%83%E7%BB%84%E7%B1%BB%E5%9E%8B">“元组类型”</a>一节中提到的空元组）作为 <code>_</code> 分支的代码：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">dice_roll</span> = <span class="number">9</span>;</span><br><span class="line"><span class="keyword">match</span> dice_roll &#123;</span><br><span class="line">    <span class="number">3</span> =&gt; <span class="title function_ invoke__">add_fancy_hat</span>(),</span><br><span class="line">    <span class="number">7</span> =&gt; <span class="title function_ invoke__">remove_fancy_hat</span>(),</span><br><span class="line">    _ =&gt; (),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">add_fancy_hat</span>() &#123;&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">remove_fancy_hat</span>() &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>在这里，我们明确告诉 Rust 我们不会使用与前面模式不匹配的值，并且这种情况下我们不想运行任何代码。</p>
<h3 id="（下划线）"><a href="#（下划线）" class="headerlink" title="_（下划线）"></a><code>_</code>（下划线）</h3><p><code>_</code> 在 <code>match</code> 语句中是一个<strong>通配符模式</strong>。它的作用是：</p>
<ul>
<li><strong>匹配任何值，但不会将该值绑定到任何变量</strong>。这意味着你不在乎具体匹配到的值是什么，只要模式匹配成功就执行对应的代码块。</li>
<li><strong>表示剩余情况的穷尽匹配</strong>。它通常作为 <code>match</code> 表达式的最后一个分支，用来捕获所有之前没有明确处理的模式。</li>
</ul>
<p><strong><code>_</code> 的主要特点：</strong></p>
<ul>
<li><strong>不绑定</strong>：匹配到的值不会绑定到任何变量，因此你不能在该分支的代码块中使用它。</li>
<li><strong>不可驳斥</strong>：它总是会匹配成功。</li>
<li><strong>常用于默认或“包罗万象”的情况</strong>。</li>
</ul>
<p><strong>示例：</strong></p>
<p>Rust</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">fn process_number(x: i32) &#123;</span><br><span class="line">    match x &#123;</span><br><span class="line">        1 =&gt; println!(&quot;数字是1！&quot;),</span><br><span class="line">        2 =&gt; println!(&quot;数字是2！&quot;),</span><br><span class="line">        _ =&gt; println!(&quot;其他数字！&quot;), // 匹配任何其他 i32 值</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    process_number(1);</span><br><span class="line">    process_number(5);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>_</code> 处理了所有不是 <code>1</code> 或 <code>2</code> 的 <code>i32</code> 值。</p>
<h3 id="other（或任何其他标识符）"><a href="#other（或任何其他标识符）" class="headerlink" title="other（或任何其他标识符）"></a><code>other</code>（或任何其他标识符）</h3><p>当你使用 <code>other</code>（或 <code>x</code>、<code>value</code>、<code>remainder</code> 等）这样的标识符在 <code>match</code> 语句中时，它充当一个<strong>变量绑定模式</strong>。它的作用是：</p>
<ul>
<li><strong>匹配任何值并将其绑定到一个新的变量</strong>，变量名就是你指定的标识符。这允许你在该分支的代码块中使用匹配到的值。</li>
<li><strong>捕获值</strong>以便进一步处理。</li>
</ul>
<p><strong>标识符（如 <code>other</code>）的主要特点：</strong></p>
<ul>
<li><strong>绑定</strong>：匹配到的值会绑定到指定的变量，然后可以在该分支的代码中使用。</li>
<li><strong>可驳斥（但可以作为包罗万象的情况）</strong>：虽然如果放在最后它也可以作为包罗万象的分支，但它的主要目的是绑定值。</li>
<li><strong>当需要处理匹配到的值时非常有用</strong>。</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Result</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Success</span>(<span class="type">String</span>),</span><br><span class="line">    <span class="title function_ invoke__">Error</span>(<span class="type">u32</span>),</span><br><span class="line">    Loading,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">handle_result</span>(res: <span class="type">Result</span>) &#123;</span><br><span class="line">    <span class="keyword">match</span> res &#123;</span><br><span class="line">        <span class="type">Result</span>::<span class="title function_ invoke__">Success</span>(message) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;成功：&#123;&#125;&quot;</span>, message),</span><br><span class="line">        <span class="type">Result</span>::<span class="title function_ invoke__">Error</span>(code) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;错误码：&#123;&#125;&quot;</span>, code),</span><br><span class="line">        other =&gt; <span class="built_in">println!</span>(<span class="string">&quot;接收到其他状态：&#123;:?&#125;&quot;</span>, other), <span class="comment">// 将剩余的 Result 值绑定到 &#x27;other&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="title function_ invoke__">handle_result</span>(<span class="type">Result</span>::<span class="title function_ invoke__">Success</span>(<span class="string">&quot;操作完成&quot;</span>.<span class="title function_ invoke__">to_string</span>()));</span><br><span class="line">    <span class="title function_ invoke__">handle_result</span>(<span class="type">Result</span>::<span class="title function_ invoke__">Error</span>(<span class="number">404</span>));</span><br><span class="line">    <span class="title function_ invoke__">handle_result</span>(<span class="type">Result</span>::Loading); <span class="comment">// &#x27;Loading&#x27; 将被绑定到 &#x27;other&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，当匹配到 <code>Result::Loading</code> 时，<code>Loading</code> 变体本身被绑定到 <code>other</code> 变量，然后你可以在代码中打印或使用 <code>other</code>。</p>
<hr>
<h3 id="区别总结-📊"><a href="#区别总结-📊" class="headerlink" title="区别总结 📊"></a>区别总结 📊</h3><table>
<thead>
<tr>
<th>特征</th>
<th><code>_</code>（通配符）</th>
<th><code>other</code>（变量绑定）</th>
</tr>
</thead>
<tbody><tr>
<td><strong>目的</strong></td>
<td>忽略值；作为“包罗万象”的模式</td>
<td>将值绑定到变量以供使用</td>
</tr>
<tr>
<td><strong>值的使用</strong></td>
<td>不能在该分支中使用匹配到的值</td>
<td>可以使用匹配到的值（通过变量）在该分支中</td>
</tr>
<tr>
<td><strong>绑定</strong></td>
<td>不发生绑定</td>
<td>将匹配到的值绑定到标识符</td>
</tr>
<tr>
<td><strong>常见用例</strong></td>
<td>默认情况，忽略模式的特定部分</td>
<td>捕获和处理匹配到的值</td>
</tr>
</tbody></table>
<h2 id="什么是“愉快路径”（Happy-Path）？"><a href="#什么是“愉快路径”（Happy-Path）？" class="headerlink" title="什么是“愉快路径”（Happy Path）？"></a>什么是“愉快路径”（Happy Path）？</h2><p>首先，理解“愉快路径”的概念很重要。在编程中，“愉快路径”指的是程序在<strong>没有遇到错误、异常或意外情况</strong>时，按照预期顺利执行的流程。就像你在一条平坦的路上开车，没有堵车，没有故障，一路畅通。</p>
<p>相反，如果出现错误或不匹配的情况，我们就需要处理**“不愉快路径”**，比如报错、返回空值、退出程序等。</p>
<hr>
<h2 id="let-else-的核心思想"><a href="#let-else-的核心思想" class="headerlink" title="let...else 的核心思想"></a><code>let...else</code> 的核心思想</h2><p><code>let...else</code> 的核心目的是为了让你的代码在处理可能失败的操作时，能够<strong>清晰地把“愉快路径”的代码放在主线上，而把“不愉快路径”的退出逻辑快速处理掉</strong>。它就像一个“快速出口”，当条件不满足时，直接从函数中跳出，避免让主逻辑变得复杂。</p>
<h3 id="为什么需要-let-else？（C-语言类比：繁琐的错误检查）"><a href="#为什么需要-let-else？（C-语言类比：繁琐的错误检查）" class="headerlink" title="为什么需要 let...else？（C 语言类比：繁琐的错误检查）"></a>为什么需要 <code>let...else</code>？（C 语言类比：繁琐的错误检查）</h3><p>在 C 语言中，当你调用一个可能失败的函数，或者需要检查一个指针是否为 <code>NULL</code> 时，你通常会看到这样的模式：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C 语言示例：模拟一个可能失败的函数调用</span></span><br><span class="line"><span class="type">int</span>* <span class="title function_">get_data</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 假设这个函数可能返回 NULL 表示失败</span></span><br><span class="line">    <span class="keyword">if</span> (rand() % <span class="number">2</span> == <span class="number">0</span>) &#123; <span class="comment">// 模拟随机失败</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span>* data = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    *data = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">process_data</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span>* data = get_data(); <span class="comment">// 调用可能失败的函数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 经典 C 语言的错误检查模式：if (data == NULL) &#123; return; &#125;</span></span><br><span class="line">    <span class="keyword">if</span> (data == <span class="literal">NULL</span>) &#123; <span class="comment">// 检查“不愉快路径”</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;获取数据失败，提前返回。\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">// 从函数中提前返回</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 走到这里，data 肯定不是 NULL，这是“愉快路径”</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;成功获取数据: %d\n&quot;</span>, *data);</span><br><span class="line">    <span class="built_in">free</span>(data); <span class="comment">// 释放资源</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    srand(time(<span class="literal">NULL</span>)); <span class="comment">// 初始化随机数种子</span></span><br><span class="line">    process_data();</span><br><span class="line">    process_data();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的 C 语言代码中，<code>if (data == NULL)</code> 就是处理“不愉快路径”的代码。它打断了主逻辑（处理数据）的流畅性，因为你必须先进行检查，如果失败就 <code>return</code>。</p>
<p>如果有很多这样的检查，或者你需要从多个函数中获取数据并检查，你的代码可能会变成这样：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C 语言中嵌套的错误检查可能很丑陋</span></span><br><span class="line">TypeA* objA = get_obj_a();</span><br><span class="line"><span class="keyword">if</span> (objA == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> ERROR_A;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TypeB* objB = get_obj_b(objA);</span><br><span class="line"><span class="keyword">if</span> (objB == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> ERROR_B;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TypeC* objC = get_obj_c(objB);</span><br><span class="line"><span class="keyword">if</span> (objC == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> ERROR_C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只有当所有都成功时，才能执行核心逻辑</span></span><br><span class="line">process_final_data(objA, objB, objC);</span><br></pre></td></tr></table></figure>

<p>这就是 <code>if let</code> 有时显得“繁琐”或“不对称”的原因。它虽然能绑定值，但在处理不匹配时，如果你想提前返回，就需要在 <code>else</code> 块中明确写 <code>return</code>，让控制流看起来有点跳跃：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对应上面 C 语言的 if (data == NULL) &#123; return; &#125;</span></span><br><span class="line"><span class="comment">// Rust 的 if let 模拟：</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">describe_state_quarter_if_let</span>(coin: Coin) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="type">String</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">state</span> = <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Coin</span>::<span class="title function_ invoke__">Quarter</span>(s) = coin &#123;</span><br><span class="line">        s <span class="comment">// 匹配成功，绑定 state</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span>; <span class="comment">// 匹配失败，直接返回 None</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 只有匹配成功，才会执行到这里</span></span><br><span class="line">    <span class="comment">// 接下来是处理 state 的“愉快路径”代码</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="title function_ invoke__">Some</span>(<span class="built_in">format!</span>(<span class="string">&quot;&#123;state:?&#125;&quot;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段 <code>if let</code> 的代码虽然可以实现功能，但你会感觉 <code>let state = if let ... else &#123; return None; &#125;;</code> 这一行有点别扭。成功的逻辑是赋值，失败的逻辑是返回，两种控制流类型不一样。</p>
<h3 id="let-else-如何简化？（C-语言类比：更直接的错误处理）"><a href="#let-else-如何简化？（C-语言类比：更直接的错误处理）" class="headerlink" title="let...else 如何简化？（C 语言类比：更直接的错误处理）"></a><code>let...else</code> 如何简化？（C 语言类比：更直接的错误处理）</h3><p><code>let...else</code> 的出现就是为了让这种“如果模式匹配就绑定值，否则直接退出”的场景变得更简洁、更符合“愉快路径”的直觉。它强制 <code>else</code> 块必须包含一个<strong>非局部退出</strong>（Non-local Return），也就是跳出当前函数、循环或者直接使程序中断。</p>
<p>我们可以将 <code>let...else</code> 类比为 C 语言中结合了<strong>宏</strong>或<strong>特定的错误处理约定</strong>来简化这种“检查-退出”模式：</p>
<p>想象一下，在 C 语言中，你可能会定义一个宏来做这样的事情（虽然不完全一样，但思想相似）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 伪 C 语言宏类比 let...else</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CHECK_AND_GET_DATA(ptr_var, func_call) \</span></span><br><span class="line"><span class="meta">    ptr_var = func_call;                     \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> (ptr_var == NULL) &#123;                   \</span></span><br><span class="line"><span class="meta">        printf(<span class="string">&quot;错误，提前退出！\n&quot;</span>);         \</span></span><br><span class="line"><span class="meta">        return;                              \</span></span><br><span class="line"><span class="meta">    &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">process_data_simplified</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span>* data;</span><br><span class="line">    CHECK_AND_GET_DATA(data, get_data()); <span class="comment">// 使用宏，如果 get_data 失败就直接返回</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 走到这里，data 肯定有效，直接处理“愉快路径”</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;成功获取数据（简化版）: %d\n&quot;</span>, *data);</span><br><span class="line">    <span class="built_in">free</span>(data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Rust 的 <code>let...else</code> 就是把这种模式内置到了语言层面，让它安全且优雅。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">describe_state_quarter_let_else</span>(coin: Coin) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="type">String</span>&gt; &#123;</span><br><span class="line">    <span class="comment">// let Coin::Quarter(state) = coin else &#123; ... &#125;;</span></span><br><span class="line">    <span class="comment">// 尝试将 coin 匹配为 Coin::Quarter。</span></span><br><span class="line">    <span class="comment">// 如果匹配成功，那么 state 变量就会被绑定，程序会继续往下执行（“愉快路径”）。</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">Coin</span>::<span class="title function_ invoke__">Quarter</span>(state) = coin <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span>; <span class="comment">// 如果不匹配（比如 coin 是 Coin::Dime 或 Coin::Nickel），直接从函数返回 None。</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 只有当 coin 确实是 Coin::Quarter 时，代码才会执行到这里。</span></span><br><span class="line">    <span class="comment">// 此时 state 变量已经包含了 Quarter 中的 UsState 值。</span></span><br><span class="line">    <span class="comment">// 这就是我们的“愉快路径”：直接使用 state 进行后续操作。</span></span><br><span class="line">    <span class="keyword">if</span> state.<span class="title function_ invoke__">existed_in</span>(<span class="number">1900</span>) &#123;</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(<span class="built_in">format!</span>(<span class="string">&quot;&#123;state:?&#125; is pretty old, for America!&quot;</span>))</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(<span class="built_in">format!</span>(<span class="string">&quot;&#123;state:?&#125; is relatively new.&quot;</span>))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><code>let...else</code> 的优点：</strong></p>
<ol>
<li><strong>保持“愉快路径”的简洁性</strong>：它允许你的主要逻辑（即成功时执行的代码）保持在左对齐的、不被中断的块中。那些会导致函数退出的“不愉快路径”逻辑被清晰地隔离在 <code>else</code> 块里，而且这个块必须执行一个非局部返回，避免了遗漏。</li>
<li><strong>更清晰的控制流</strong>：一眼就能看出如果模式不匹配，函数会立即退出，避免了 <code>if let</code> 某些情况下可能出现的控制流跳跃或分支逻辑不一致的问题。这使得代码更易读、易懂。</li>
</ol>
<p>简而言之，<code>let...else</code> 是 Rust 语言为处理“如果能成功解构就继续，否则立即退出”这种常见模式提供的一个语法糖，让代码在面对潜在失败时，依然能保持“愉快路径”的简洁和直观。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/07/20/RUST%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0%E4%B9%8B%E7%BB%93%E6%9E%84%E4%BD%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.png">
      <meta itemprop="name" content="Chillward">
      <meta itemprop="description" content="谁躺在漆黑的舞台上，用身体迎接着光芒">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chillward的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/07/20/RUST%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0%E4%B9%8B%E7%BB%93%E6%9E%84%E4%BD%93/" class="post-title-link" itemprop="url">RUST学习日记之结构体</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-07-20 11:41:40 / 修改时间：15:56:53" itemprop="dateCreated datePublished" datetime="2025-07-20T11:41:40+08:00">2025-07-20</time>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>7.4k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>13 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="结构体的定义和示例化"><a href="#结构体的定义和示例化" class="headerlink" title="结构体的定义和示例化"></a>结构体的定义和示例化</h2><h3 id="结构体的定义以及实例化"><a href="#结构体的定义以及实例化" class="headerlink" title="结构体的定义以及实例化"></a>结构体的定义以及实例化</h3><p>定义语法:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    active: <span class="type">bool</span>,</span><br><span class="line">    username: <span class="type">String</span>,</span><br><span class="line">    email: <span class="type">String</span>,</span><br><span class="line">    sign_in_count: <span class="type">u64</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>没有**;**，需要指明类型。</p>
<p>实例化语法:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">user1</span> = User &#123;</span><br><span class="line">    active: <span class="literal">true</span>,</span><br><span class="line">    username: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;someusername123&quot;</span>),</span><br><span class="line">    email: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;someone@example.com&quot;</span>),</span><br><span class="line">    sign_in_count: <span class="number">1</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>如果整个实例是可变的，那我们就可以通过<code>user1.email = String::from(&quot;anotheremail@example.com&quot;);</code>来修改实例中字段的值。</p>
<p>通过函数返回实例:</p>
<blockquote>
<p>另外需要注意同其他任何表达式一样，我们可以在函数体的最后一个表达式中构造一个结构体的新实例，来隐式地返回这个实例。</p>
</blockquote>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">build_user</span>(email: <span class="type">String</span>, username: <span class="type">String</span>) <span class="punctuation">-&gt;</span> User &#123;</span><br><span class="line">    User &#123;</span><br><span class="line">        active: <span class="literal">true</span>,</span><br><span class="line">        username: username,</span><br><span class="line">        email: email,</span><br><span class="line">        sign_in_count: <span class="number">1</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="字段初始化"><a href="#字段初始化" class="headerlink" title="字段初始化"></a>字段初始化</h3><p>我们可以通过<strong>字段初始化</strong>来简写语法,如下:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">build_user</span>(email: <span class="type">String</span>, username: <span class="type">String</span>) <span class="punctuation">-&gt;</span> User &#123;</span><br><span class="line">    User &#123;</span><br><span class="line">        active: <span class="literal">true</span>,</span><br><span class="line">        username,</span><br><span class="line">        email,</span><br><span class="line">        sign_in_count: <span class="number">1</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当参数与结构体中字段的名字相同时可以使用字段初始化来简写语法。</p>
<h3 id="结构体更新语法"><a href="#结构体更新语法" class="headerlink" title="结构体更新语法"></a>结构体更新语法</h3><p>结构体更新语法:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">user2</span> = User &#123;</span><br><span class="line">        email: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;another@example.com&quot;</span>),</span><br><span class="line">        ..user1</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请注意，结构更新语法就像带有 <code>=</code> 的赋值，因为它移动了数据，就像我们在“使用移动的变量与数据交互”部分讲到的一样。在这个例子中，总体上说我们在创建 <code>user2</code> 后就不能再使用 <code>user1</code> 了，因为 <code>user1</code> 的 <code>username</code> 字段中的 <code>String</code> 被移到 <code>user2</code> 中。如果我们给 <code>user2</code> 的 <code>email</code> 和 <code>username</code> 都赋予新的 <code>String</code> 值，从而只复用 <code>user1</code> 的 <code>active</code> 和 <code>sign_in_count</code> 值，那么 <code>user1</code> 在创建 <code>user2</code> 后仍然有效。<code>active</code> 和 <code>sign_in_count</code> 的类型是实现 <code>Copy</code> trait 的类型，所以我们在[“使用克隆的变量与数据交互”]部分讨论的行为同样适用。在本例中我们也可以继续使用 <code>user1.email</code>，因为它的值并未从 <code>user1</code> 中移动出去。</p>
<p><strong>如果想不影响原来实例的话，可以使用.clone()方法来复制数据。</strong></p>
<h3 id="使用没有命名字段的元组结构体来创建不同的类型"><a href="#使用没有命名字段的元组结构体来创建不同的类型" class="headerlink" title="使用没有命名字段的元组结构体来创建不同的类型"></a>使用没有命名字段的元组结构体来创建不同的类型</h3><p>也可以定义与元组类似的结构体，称为 <strong>元组结构体</strong>（<em>tuple structs</em>）。元组结构体有着结构体名称提供的含义，但没有具体的字段名，只有字段的类型。当你想给整个元组取一个名字，并使元组成为与其他元组不同的类型时，元组结构体是很有用的，这时像常规结构体那样为每个字段命名就显得多余和形式化了。</p>
<p>要定义元组结构体，以 <code>struct</code> 关键字和结构体名开头并后跟元组中的类型。例如，下面是两个分别叫做 <code>Color</code> 和 <code>Point</code> 元组结构体的定义和用法：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Color</span>(<span class="type">i32</span>, <span class="type">i32</span>, <span class="type">i32</span>);</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span>(<span class="type">i32</span>, <span class="type">i32</span>, <span class="type">i32</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">black</span> = <span class="title function_ invoke__">Color</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">origin</span> = <span class="title function_ invoke__">Point</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意 <code>black</code> 和 <code>origin</code> 值的类型不同，因为它们是不同的元组结构体的实例。你定义的每一个结构体有其自己的类型，即使结构体中的字段可能有着相同的类型。例如，一个获取 <code>Color</code> 类型参数的函数不能接受 <code>Point</code> 作为参数，即便这两个类型都由三个 <code>i32</code> 值组成。除此之外，元组结构体实例类似于元组，你可以将它们解构为单独的部分，也可以使用 <code>.</code> 后跟索引来访问单独的值。与元组不同的是，解构元组结构体时必须写明结构体的类型。例如，我们可以写 <code>let Point(x, y, z) = origin;</code>，将 <code>origin</code> 的值解构到名为 <code>x</code>、<code>y</code> 和 <code>z</code> 的变量中。</p>
<h3 id="类单元结构体"><a href="#类单元结构体" class="headerlink" title="类单元结构体"></a>类单元结构体</h3><p>暂时用不到，就先不写了</p>
<h3 id="结构体中字段的所有权"><a href="#结构体中字段的所有权" class="headerlink" title="结构体中字段的所有权"></a>结构体中字段的所有权</h3><p>目前就是注意一点，结构体字段中不要包含引用就好了。</p>
<hr>
<h3 id="打印结构体中所有值"><a href="#打印结构体中所有值" class="headerlink" title="打印结构体中所有值"></a>打印结构体中所有值</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    width: <span class="type">u32</span>,</span><br><span class="line">    height: <span class="type">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rect1</span> = Rectangle &#123;</span><br><span class="line">        width: <span class="number">30</span>,</span><br><span class="line">        height: <span class="number">50</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;rect1 is &#123;rect1:#?&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="结构体中的方法"><a href="#结构体中的方法" class="headerlink" title="结构体中的方法"></a>结构体中的方法</h2><blockquote>
<p>RUST官方教程中这一块写的非常清晰易懂，我直接复制下来了</p>
</blockquote>
<h2 id="方法语法"><a href="#方法语法" class="headerlink" title="方法语法"></a><a target="_blank" rel="noopener" href="https://kaisery.github.io/trpl-zh-cn/ch05-03-method-syntax.html#%E6%96%B9%E6%B3%95%E8%AF%AD%E6%B3%95">方法语法</a></h2><p><strong>方法</strong>（method）与函数类似：它们使用 <code>fn</code> 关键字和名称声明，可以拥有参数和返回值，同时包含在某处调用该方法时会执行的代码。不过方法与函数是不同的，因为它们在结构体的上下文中被定义（或者是枚举或 trait 对象的上下文，将分别在<a target="_blank" rel="noopener" href="https://kaisery.github.io/trpl-zh-cn/ch06-00-enums.html">第六章</a>和<a target="_blank" rel="noopener" href="https://kaisery.github.io/trpl-zh-cn/ch18-02-trait-objects.html">第十八章</a>讲解），并且它们第一个参数总是 <code>self</code>，它代表调用该方法的结构体实例。</p>
<h3 id="定义方法"><a href="#定义方法" class="headerlink" title="定义方法"></a><a target="_blank" rel="noopener" href="https://kaisery.github.io/trpl-zh-cn/ch05-03-method-syntax.html#%E5%AE%9A%E4%B9%89%E6%96%B9%E6%B3%95">定义方法</a></h3><p>让我们把前面实现的获取一个 <code>Rectangle</code> 实例作为参数的 <code>area</code> 函数，改写成一个定义于 <code>Rectangle</code> 结构体上的 <code>area</code> 方法，如示例 5-13 所示：</p>
<p>文件名：src&#x2F;main.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    width: <span class="type">u32</span>,</span><br><span class="line">    height: <span class="type">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">area</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">u32</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.width * <span class="keyword">self</span>.height</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rect1</span> = Rectangle &#123;</span><br><span class="line">        width: <span class="number">30</span>,</span><br><span class="line">        height: <span class="number">50</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(</span><br><span class="line">        <span class="string">&quot;The area of the rectangle is &#123;&#125; square pixels.&quot;</span>,</span><br><span class="line">        rect1.<span class="title function_ invoke__">area</span>()</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例 5-13：在 <code>Rectangle</code> 结构体上定义 <code>area</code> 方法</p>
<p>为了使函数定义于 <code>Rectangle</code> 的上下文中，我们开始了一个 <code>impl</code> 块（<code>impl</code> 是 <em>implementation</em> 的缩写），这个 <code>impl</code> 块中的所有内容都将与 <code>Rectangle</code> 类型相关联。接着将 <code>area</code> 函数移动到 <code>impl</code> 大括号中，并将签名中的第一个（在这里也是唯一一个）参数和函数体中其他地方的对应参数改成 <code>self</code>。然后在 <code>main</code> 中将我们先前调用 <code>area</code> 方法并传递 <code>rect1</code> 作为参数的地方，改成使用 <strong>方法语法</strong>（<em>method syntax</em>）在 <code>Rectangle</code> 实例上调用 <code>area</code> 方法。方法语法获取一个实例并加上一个点号，后跟方法名、圆括号以及任何参数。</p>
<p>在 <code>area</code> 的签名中，使用 <code>&amp;self</code> 来替代 <code>rectangle: &amp;Rectangle</code>，<code>&amp;self</code> 实际上是 <code>self: &amp;Self</code> 的缩写。在一个 <code>impl</code> 块中，<code>Self</code> 类型是 <code>impl</code> 块的类型的别名。方法的第一个参数必须有一个名为 <code>self</code> 的<code>Self</code> 类型的参数，所以 Rust 让你在第一个参数位置上只用 <code>self</code> 这个名字来简化。注意，我们仍然需要在 <code>self</code> 前面使用 <code>&amp;</code> 来表示这个方法借用了 <code>Self</code> 实例，就像我们在 <code>rectangle: &amp;Rectangle</code> 中做的那样。方法可以选择获得 <code>self</code> 的所有权，或者像我们这里一样不可变地借用 <code>self</code>，或者可变地借用 <code>self</code>，就跟其他参数一样。</p>
<p>这里选择 <code>&amp;self</code> 的理由跟在函数版本中使用 <code>&amp;Rectangle</code> 是相同的：我们并不想获取所有权，只希望能够读取结构体中的数据，而不是写入。如果想要在方法中改变调用方法的实例，需要将第一个参数改为 <code>&amp;mut self</code>。通过仅仅使用 <code>self</code> 作为第一个参数来使方法获取实例的所有权是很少见的；这种技术通常用在当方法将 <code>self</code> 转换成别的实例的时候，这时我们想要防止调用者在转换之后使用原始的实例。</p>
<p>使用方法替代函数，除了可使用方法语法和不需要在每个函数签名中重复 <code>self</code> 的类型之外，其主要好处在于组织性。我们将某个类型实例能做的所有事情都一起放入 <code>impl</code> 块中，而不是让将来的用户在我们的库中到处寻找 <code>Rectangle</code> 的功能。</p>
<p>请注意，我们可以选择将方法的名称与结构中的一个字段相同。例如，我们可以在 <code>Rectangle</code> 上定义一个方法，并命名为 <code>width</code>：</p>
<p>文件名：src&#x2F;main.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">width</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.width &gt; <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rect1</span> = Rectangle &#123;</span><br><span class="line">        width: <span class="number">30</span>,</span><br><span class="line">        height: <span class="number">50</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> rect1.<span class="title function_ invoke__">width</span>() &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;The rectangle has a nonzero width; it is &#123;&#125;&quot;</span>, rect1.width);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里，我们选择让 <code>width</code> 方法在实例的 <code>width</code> 字段的值大于 <code>0</code> 时返回 <code>true</code>，等于 <code>0</code> 时则返回 <code>false</code>：我们可以出于任何目的，在同名的方法中使用同名的字段。在 <code>main</code> 中，当我们在 <code>rect1.width</code> 后面加上括号时。Rust 知道我们指的是方法 <code>width</code>。当我们不使用圆括号时，Rust 知道我们指的是字段 <code>width</code>。</p>
<p>通常，但并不总是如此，与字段同名的方法将被定义为只返回字段中的值，而不做其他事情。这样的方法被称为 <em>getters</em>，Rust 并不像其他一些语言那样为结构字段自动实现它们。Getters 很有用，因为你可以把字段变成私有的，但方法是公共的，这样就可以把对字段的只读访问作为该类型公共 API 的一部分。我们将在<a target="_blank" rel="noopener" href="https://kaisery.github.io/trpl-zh-cn/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html#%E4%BD%BF%E7%94%A8-pub-%E5%85%B3%E9%94%AE%E5%AD%97%E6%9A%B4%E9%9C%B2%E8%B7%AF%E5%BE%84">第七章</a>中讨论什么是公有和私有，以及如何将一个字段或方法指定为公有或私有。</p>
<blockquote>
<h3 id="运算符到哪去了？"><a href="#运算符到哪去了？" class="headerlink" title="-&gt; 运算符到哪去了？"></a><a target="_blank" rel="noopener" href="https://kaisery.github.io/trpl-zh-cn/ch05-03-method-syntax.html#--%E8%BF%90%E7%AE%97%E7%AC%A6%E5%88%B0%E5%93%AA%E5%8E%BB%E4%BA%86"><code>-&gt;</code> 运算符到哪去了？</a></h3><p>在 C&#x2F;C++ 语言中，有两个不同的运算符来调用方法：<code>.</code> 直接在对象上调用方法，而 <code>-&gt;</code> 在一个对象的指针上调用方法，这时需要先解引用（dereference）指针。换句话说，如果 <code>object</code> 是一个指针，那么 <code>object-&gt;something()</code> 就像 <code>(*object).something()</code> 一样。</p>
<p>Rust 并没有一个与 <code>-&gt;</code> 等效的运算符；相反，Rust 有一个叫 <strong>自动引用和解引用</strong>（<em>automatic referencing and dereferencing</em>）的功能。方法调用是 Rust 中少数几个拥有这种行为的地方。</p>
<p>它是这样工作的：当使用 <code>object.something()</code> 调用方法时，Rust 会自动为 <code>object</code> 添加 <code>&amp;</code>、<code>&amp;mut</code> 或 <code>*</code> 以便使 <code>object</code> 与方法签名匹配。也就是说，这些代码是等价的：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p1.<span class="title function_ invoke__">distance</span>(&amp;p2);</span><br><span class="line">(&amp;p1).<span class="title function_ invoke__">distance</span>(&amp;p2);</span><br></pre></td></tr></table></figure>

<p>第一行看起来简洁的多。这种自动引用的行为之所以有效，是因为方法有一个明确的接收者———— <code>self</code> 的类型。在给出接收者和方法名的前提下，Rust 可以明确地计算出方法是仅仅读取（<code>&amp;self</code>），做出修改（<code>&amp;mut self</code>）或者是获取所有权（<code>self</code>）。事实上，Rust 对方法接收者的隐式借用让所有权在实践中更友好。</p>
</blockquote>
<h3 id="带有更多参数的方法"><a href="#带有更多参数的方法" class="headerlink" title="带有更多参数的方法"></a><a target="_blank" rel="noopener" href="https://kaisery.github.io/trpl-zh-cn/ch05-03-method-syntax.html#%E5%B8%A6%E6%9C%89%E6%9B%B4%E5%A4%9A%E5%8F%82%E6%95%B0%E7%9A%84%E6%96%B9%E6%B3%95">带有更多参数的方法</a></h3><p>让我们通过实现 <code>Rectangle</code> 结构体上的另一方法来练习使用方法。这回，我们让一个 <code>Rectangle</code> 的实例获取另一个 <code>Rectangle</code> 实例，如果 <code>self</code> （第一个 <code>Rectangle</code>）能完全包含第二个长方形则返回 <code>true</code>；否则返回 <code>false</code>。一旦我们定义了 <code>can_hold</code> 方法，就可以编写示例 5-14 中的代码。</p>
<p>文件名：src&#x2F;main.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rect1</span> = Rectangle &#123;</span><br><span class="line">        width: <span class="number">30</span>,</span><br><span class="line">        height: <span class="number">50</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rect2</span> = Rectangle &#123;</span><br><span class="line">        width: <span class="number">10</span>,</span><br><span class="line">        height: <span class="number">40</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rect3</span> = Rectangle &#123;</span><br><span class="line">        width: <span class="number">60</span>,</span><br><span class="line">        height: <span class="number">45</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Can rect1 hold rect2? &#123;&#125;&quot;</span>, rect1.<span class="title function_ invoke__">can_hold</span>(&amp;rect2));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Can rect1 hold rect3? &#123;&#125;&quot;</span>, rect1.<span class="title function_ invoke__">can_hold</span>(&amp;rect3));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同时我们希望看到如下输出，因为 <code>rect2</code> 的两个维度都小于 <code>rect1</code>，而 <code>rect3</code> 比 <code>rect1</code> 要宽：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Can rect1 hold rect2? true</span><br><span class="line">Can rect1 hold rect3? false</span><br></pre></td></tr></table></figure>

<p>因为我们想定义一个方法，所以它应该位于 <code>impl Rectangle</code> 块中。方法名是 <code>can_hold</code>，并且它会获取另一个 <code>Rectangle</code> 的不可变借用作为参数。通过观察调用方法的代码可以看出参数是什么类型的：<code>rect1.can_hold(&amp;rect2)</code> 传入了 <code>&amp;rect2</code>，它是一个 <code>Rectangle</code> 的实例 <code>rect2</code> 的不可变借用。这是可以理解的，因为我们只需要读取 <code>rect2</code>（而不是写入，这意味着我们需要一个不可变借用），而且希望 <code>main</code> 保持 <code>rect2</code> 的所有权，这样就可以在调用这个方法后继续使用它。<code>can_hold</code> 的返回值是一个布尔值，其实现会分别检查 <code>self</code> 的宽高是否都大于另一个 <code>Rectangle</code>。让我们在示例 5-13 的 <code>impl</code> 块中增加这个新的 <code>can_hold</code> 方法，如示例 5-15 所示：</p>
<p>文件名：src&#x2F;main.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">area</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">u32</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.width * <span class="keyword">self</span>.height</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">can_hold</span>(&amp;<span class="keyword">self</span>, other: &amp;Rectangle) <span class="punctuation">-&gt;</span> <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.width &gt; other.width &amp;&amp; <span class="keyword">self</span>.height &gt; other.height</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例 5-15：在 <code>Rectangle</code> 上实现 <code>can_hold</code> 方法，它获取另一个 <code>Rectangle</code> 实例作为参数</p>
<p>如果结合示例 5-14 的 <code>main</code> 函数来运行，就会看到期望的输出。在方法签名中，可以在 <code>self</code> 后增加多个参数，而且这些参数就像函数中的参数一样工作。</p>
<h3 id="关联函数"><a href="#关联函数" class="headerlink" title="关联函数"></a><a target="_blank" rel="noopener" href="https://kaisery.github.io/trpl-zh-cn/ch05-03-method-syntax.html#%E5%85%B3%E8%81%94%E5%87%BD%E6%95%B0">关联函数</a></h3><p>所有在 <code>impl</code> 块中定义的函数被称为 <strong>关联函数</strong>（<em>associated functions</em>），因为它们与 <code>impl</code> 后面命名的类型相关。我们可以定义不以 <code>self</code> 为第一参数的关联函数（因此不是方法），因为它们并不作用于一个结构体的实例。我们已经使用了一个这样的函数：在 <code>String</code> 类型上定义的 <code>String::from</code> 函数。</p>
<p>不是方法的关联函数经常被用作返回一个结构体新实例的构造函数。这些函数的名称通常为 <code>new</code> ，但 <code>new</code> 并不是一个关键字。例如我们可以提供一个叫做 <code>square</code> 关联函数，它接受一个维度参数并且同时作为宽和高，这样可以更轻松的创建一个正方形 <code>Rectangle</code> 而不必指定两次同样的值：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">square</span>(size: <span class="type">u32</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">Self</span> &#123;</span><br><span class="line">            width: size,</span><br><span class="line">            height: size,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关键字 <code>Self</code> 在函数的返回类型和函数体中，都是对 <code>impl</code> 关键字后所示类型的别名，这里是 <code>Rectangle</code>。</p>
<p>要调用这个关联函数，我们使用结构体名和 <code>::</code> 语法；比如 <code>let sq = Rectangle::square(3);</code>。这个函数位于结构体的命名空间中：<code>::</code> 语法用于关联函数和模块创建的命名空间。<a target="_blank" rel="noopener" href="https://kaisery.github.io/trpl-zh-cn/ch07-02-defining-modules-to-control-scope-and-privacy.html">第七章</a>会讲到模块。</p>
<h3 id="多个-impl-块"><a href="#多个-impl-块" class="headerlink" title="多个 impl 块"></a><a target="_blank" rel="noopener" href="https://kaisery.github.io/trpl-zh-cn/ch05-03-method-syntax.html#%E5%A4%9A%E4%B8%AA-impl-%E5%9D%97">多个 <code>impl</code> 块</a></h3><p>每个结构体都允许拥有多个 <code>impl</code> 块。例如，示例 5-15 中的代码等同于示例 5-16 中所示的代码，但后者每个方法有其自己的 <code>impl</code> 块。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">area</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">u32</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.width * <span class="keyword">self</span>.height</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">can_hold</span>(&amp;<span class="keyword">self</span>, other: &amp;Rectangle) <span class="punctuation">-&gt;</span> <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.width &gt; other.width &amp;&amp; <span class="keyword">self</span>.height &gt; other.height</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里没有理由将这些方法分散在多个 <code>impl</code> 块中，不过这是有效的语法。第十章讨论泛型和 trait 时会看到实用的多 <code>impl</code> 块的用例。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><a target="_blank" rel="noopener" href="https://kaisery.github.io/trpl-zh-cn/ch05-03-method-syntax.html#%E6%80%BB%E7%BB%93">总结</a></h2><p>结构体让你可以创建出在你的领域中有意义的自定义类型。通过结构体，我们可以将相关联的数据片段联系起来并命名它们，这样可以使得代码更加清晰。在 <code>impl</code> 块中，你可以定义与你的类型相关联的函数，而方法是一种相关联的函数，让你指定结构体的实例所具有的行为。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/07/20/RUST%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0%E4%B9%8B%E6%8E%A7%E5%88%B6%E6%B5%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.png">
      <meta itemprop="name" content="Chillward">
      <meta itemprop="description" content="谁躺在漆黑的舞台上，用身体迎接着光芒">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chillward的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/07/20/RUST%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0%E4%B9%8B%E6%8E%A7%E5%88%B6%E6%B5%81/" class="post-title-link" itemprop="url">RUST学习日记之控制流</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-07-20 09:21:17 / 修改时间：15:56:46" itemprop="dateCreated datePublished" datetime="2025-07-20T09:21:17+08:00">2025-07-20</time>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>4k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>7 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="if表达式"><a href="#if表达式" class="headerlink" title="if表达式"></a>if表达式</h3><p>rust中的if语句跟C语言中的是类似的，基本格式如下</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">number</span> = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">if</span> (number &lt; <span class="number">5</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;condition was true&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;condition was false&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但也有不同的地方：</p>
<ol>
<li>if后紧跟的条件必须是一个bool值，如果不是的话，程序会无法编译</li>
<li>在rust中，if是一个表达式而不是语句，二者之间的区别就是语句仅仅只是执行一个动作而不返回值，表达式会在执行后返回一个值。</li>
</ol>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = <span class="keyword">if</span> x &gt; <span class="number">5</span> &#123;</span><br><span class="line">        <span class="number">20</span> <span class="comment">// 这个块的值是 20</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="number">30</span> <span class="comment">// 这个块的值是 30</span></span><br><span class="line">    &#125;; <span class="comment">// 注意这里的分号，表示表达式的结束</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;y = &#123;&#125;&quot;</span>, y); <span class="comment">// 输出 y = 20</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 另一个例子：隐式返回</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">description</span> = <span class="keyword">if</span> x &gt; <span class="number">100</span> &#123;</span><br><span class="line">        <span class="string">&quot;非常大&quot;</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> x &gt; <span class="number">50</span> &#123;</span><br><span class="line">        <span class="string">&quot;比较大&quot;</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="string">&quot;不大&quot;</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;x 的值: &#123;&#125;&quot;</span>, description); <span class="comment">// 输出 x 的值: 不大</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>关键点：</strong></p>
<ol>
<li><p><strong>返回类型一致性</strong>：当 <code>if</code> 作为表达式使用时，所有分支（<code>if</code>、<code>else if</code> 和 <code>else</code>）必须返回<strong>相同类型</strong>的值。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">result</span> = <span class="keyword">if</span> <span class="literal">true</span> &#123;</span><br><span class="line">    <span class="number">10</span> <span class="comment">// 返回 i32</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="string">&quot;hello&quot;</span> <span class="comment">// 错误！返回 &amp;str，类型不匹配</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>编译器会报错，因为 <code>10</code> 是整数，而 <code>&quot;hello&quot;</code> 是字符串切片，它们的类型不同。</p>
</li>
<li><p><strong>块的最后一个表达式是返回值</strong>：在 Rust 中，一个代码块的值是其最后一个表达式的值（没有分号），没法使用return ***;的形式返回。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">value</span> = <span class="keyword">if</span> condition &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">temp</span> = <span class="number">10</span>;</span><br><span class="line">    temp + <span class="number">5</span> <span class="comment">// 这个表达式的值 15 就是整个 if 分支的返回值</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="number">20</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><p>rust中的循环分3种:</p>
<ol>
<li>loop</li>
<li>while</li>
<li>for</li>
</ol>
<p>需要注意的是，rust中是没有类似于C语言中do while()这种循环结构的，等效的功能可以由loop实现。</p>
<h4 id="loop"><a href="#loop" class="headerlink" title="loop:"></a>loop:</h4><p>loop循环类似于C语言中while(1)或者for(;;)，不手动用Break退出的话就会一直循环下去。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;again!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是,rust中有一个C语言中没有的特性:<strong>循环标签</strong></p>
<h5 id="循环标签-loop-labels-："><a href="#循环标签-loop-labels-：" class="headerlink" title="循环标签(loop labels)："></a>循环标签(loop labels)：</h5><p>语法:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">&#x27;label_name</span>: <span class="keyword">loop</span> &#123;</span><br><span class="line">    <span class="comment">// 循环体</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="symbol">&#x27;label_name</span>: <span class="keyword">while</span> condition &#123;</span><br><span class="line">    <span class="comment">// 循环体</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="symbol">&#x27;label_name</span>: <span class="keyword">for</span> <span class="variable">item</span> <span class="keyword">in</span> collection &#123;</span><br><span class="line">    <span class="comment">// 循环体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>循环标签的语法是在 <code>loop</code>、<code>while</code> 或 <code>for</code> 关键字之前加上一个<strong>单引号开头的名称</strong>，后面紧跟着一个<strong>冒号</strong>，然后在使用 <code>break</code> 或 <code>continue</code> 时指定这个标签，从而控制跳出或继续执行哪个具体的循环，即使它不是最内层循环。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">count</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="symbol">&#x27;outer_loop</span>: <span class="keyword">loop</span> &#123; <span class="comment">// 这是一个名为 &#x27;outer_loop 的循环</span></span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Outer loop count: &#123;count&#125;&quot;</span>);</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">inner_count</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="symbol">&#x27;inner_loop</span>: <span class="keyword">loop</span> &#123; <span class="comment">// 这是一个名为 &#x27;inner_loop 的循环</span></span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Inner loop count: &#123;inner_count&#125;&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> inner_count &gt;= <span class="number">2</span> &#123;</span><br><span class="line">                <span class="keyword">break</span> <span class="symbol">&#x27;inner_loop</span>; <span class="comment">// 跳出 &#x27;inner_loop</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> count &gt;= <span class="number">1</span> &#123;</span><br><span class="line">                <span class="keyword">break</span> <span class="symbol">&#x27;outer_loop</span>; <span class="comment">// 跳出 &#x27;outer_loop</span></span><br><span class="line">            &#125;</span><br><span class="line">            inner_count += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        count += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> count &gt;= <span class="number">3</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">// 跳出当前（外层）循环，这里其实效果和 break &#x27;outer_loop 一样，因为这是最外层循环</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Loop finished. Final count: &#123;count&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>rust的这种特性很好的避免了C语言中需要跳出复杂循环时需要设置标志位以及单独判断的情况。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> done = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">1</span> &amp;&amp; j == <span class="number">1</span>) &#123;</span><br><span class="line">            done = <span class="number">1</span>; <span class="comment">// 设置标志</span></span><br><span class="line">            <span class="keyword">break</span>;    <span class="comment">// 跳出内层循环</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i: %d, j: %d\n&quot;</span>, i, j);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (done) &#123;</span><br><span class="line">        <span class="keyword">break</span>; <span class="comment">// 根据标志跳出外层循环</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="while"><a href="#while" class="headerlink" title="while:"></a>while:</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Hello World&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>while循环的语法跟特性与C语言都是类似的，唯一的不同就是它的条件必须是一个bool量而不能是其他类型。</p>
<hr>
<h4 id="for"><a href="#for" class="headerlink" title="for:"></a>for:</h4><p>Rust的for循环与C语言的for循环有较大不同，Rust中的for循环类似于其他现代语言中的”for each”。</p>
<h2 id="核心差异总结"><a href="#核心差异总结" class="headerlink" title="核心差异总结"></a>核心差异总结</h2><table>
<thead>
<tr>
<th>特性</th>
<th align="center">C 语言的 <code>for</code> 循环</th>
<th align="center">Rust 的 <code>for</code> 循环</th>
</tr>
</thead>
<tbody><tr>
<td><strong>基础</strong></td>
<td align="center">基于<strong>计数器和条件</strong>，手动控制迭代过程</td>
<td align="center">基于<strong>迭代器</strong>，遍历集合中的每个元素</td>
</tr>
<tr>
<td><strong>语法</strong></td>
<td align="center"><code>for (init; condition; step)</code></td>
<td align="center"><code>for element in iterator</code></td>
</tr>
<tr>
<td><strong>安全性</strong></td>
<td align="center">容易出现索引越界和“差一错误”，需要手动管理</td>
<td align="center">Rust 的所有权和借用系统保证安全，避免越界访问</td>
</tr>
<tr>
<td><strong>简洁性</strong></td>
<td align="center">对于简单计数循环简洁，但遍历集合时需要额外索引管理</td>
<td align="center">遍历集合和范围时非常简洁，不需要手动索引或长度计算</td>
</tr>
<tr>
<td><strong>灵活性</strong></td>
<td align="center">可以实现任何循环逻辑，包括非标准迭代（但可能不清晰）</td>
<td align="center">通过迭代器适配器（<code>map</code>, <code>filter</code> 等）实现复杂迭代逻辑</td>
</tr>
<tr>
<td><strong>返回值</strong></td>
<td align="center">循环本身不返回值</td>
<td align="center">循环本身不返回值，但可以结合 <code>break</code> 来返回值</td>
</tr>
</tbody></table>
<p>语法如下:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> 元素 <span class="keyword">in</span> 迭代器 &#123;</span><br><span class="line">    <span class="comment">// 循环体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是简单的示例:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// Rust 示例：遍历向量（Vector）</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">numbers</span> = <span class="built_in">vec!</span>[<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// .iter() 方法返回一个迭代器，它产出对元素的不可变引用</span></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">number</span> <span class="keyword">in</span> numbers.<span class="title function_ invoke__">iter</span>() &#123;</span><br><span class="line">        <span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125; &quot;</span>, number);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(); <span class="comment">// 输出: 10 20 30 40 50</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Rust 示例：使用范围（Range）</span></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span>..<span class="number">5</span> &#123; <span class="comment">// 范围 [0, 5) 不包含 5</span></span><br><span class="line">        <span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125; &quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(); <span class="comment">// 输出: 0 1 2 3 4</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果需要索引，可以使用 .enumerate()</span></span><br><span class="line">    <span class="keyword">for</span> (index, number) <span class="keyword">in</span> numbers.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">enumerate</span>() &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Index: &#123;&#125;, Value: &#123;&#125;&quot;</span>, index, number);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>注意</strong>:Rust是可以通过break;在循环(for while loop)中返回值的，例子如下：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">counter</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// `loop` 作为一个表达式，通过 `break` 返回值</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span> = <span class="keyword">loop</span> &#123; <span class="comment">// 整个 loop 表达式将被赋值给 result</span></span><br><span class="line">        counter += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> counter == <span class="number">10</span> &#123;</span><br><span class="line">            <span class="keyword">break</span> counter * <span class="number">2</span>; <span class="comment">// 当 counter 等于 10 时，跳出循环，并将 counter * 2 作为 loop 表达式的值</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;; <span class="comment">// 注意这里的分号，表示表达式的结束</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The result is: &#123;&#125;&quot;</span>, result); <span class="comment">// 输出: The result is: 20</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The final counter value is: &#123;&#125;&quot;</span>, counter); <span class="comment">// 输出: The final counter value is: 10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/07/19/RUST%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0%E4%B9%8B%E6%89%80%E6%9C%89%E6%9D%83%E4%B8%8E%E5%BC%95%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.png">
      <meta itemprop="name" content="Chillward">
      <meta itemprop="description" content="谁躺在漆黑的舞台上，用身体迎接着光芒">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chillward的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/07/19/RUST%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0%E4%B9%8B%E6%89%80%E6%9C%89%E6%9D%83%E4%B8%8E%E5%BC%95%E7%94%A8/" class="post-title-link" itemprop="url">RUST学习日记之所有权与引用</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-07-19 10:22:13" itemprop="dateCreated datePublished" datetime="2025-07-19T10:22:13+08:00">2025-07-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-07-20 15:56:38" itemprop="dateModified" datetime="2025-07-20T15:56:38+08:00">2025-07-20</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>23k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>42 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>注意一个引用的作用域从声明的地方开始一直持续到最后一次使用为止。</p>
<p>生命周期 作用域</p>
<h2 id="核心区别总结"><a href="#核心区别总结" class="headerlink" title="核心区别总结"></a>核心区别总结</h2><table>
<thead>
<tr>
<th>特性</th>
<th>作用域 (Scope)</th>
<th>生命周期 (Lifetime)</th>
</tr>
</thead>
<tbody><tr>
<td><strong>定义对象</strong></td>
<td><strong>变量</strong>的可见性区域及其存活期</td>
<td><strong>引用</strong>的有效性时间段，即引用指向的数据存活的时间</td>
</tr>
<tr>
<td><strong>控制对象</strong></td>
<td>变量何时<strong>创建</strong>和<strong>销毁</strong></td>
<td>引用何时<strong>有效</strong>（不指向无效内存）</td>
</tr>
<tr>
<td><strong>关注点</strong></td>
<td>内存的<strong>分配与释放</strong></td>
<td><strong>内存安全</strong>，尤其是防止悬垂引用</td>
</tr>
<tr>
<td><strong>目的</strong></td>
<td>组织代码和管理资源</td>
<td>确保引用的有效性，由借用检查器（Borrow Checker）强制执行</td>
</tr>
<tr>
<td><strong>形式</strong></td>
<td>通常由 <code>&#123;&#125;</code> 代码块隐式定义</td>
<td>通常通过 <code>&#39;a</code>, <code>&#39;b</code> 等显式注解（当编译器无法推断时）</td>
</tr>
</tbody></table>
<blockquote>
<p>剩下的，官方的文档写的非常好，我也是直接复制过来用了(Bushi)</p>
</blockquote>
<h2 id="什么是所有权？"><a href="#什么是所有权？" class="headerlink" title="什么是所有权？"></a><a target="_blank" rel="noopener" href="https://kaisery.github.io/trpl-zh-cn/ch04-01-what-is-ownership.html#%E4%BB%80%E4%B9%88%E6%98%AF%E6%89%80%E6%9C%89%E6%9D%83">什么是所有权？</a></h2><p><strong>所有权</strong>（<em>ownership</em>）是 Rust 用于如何管理内存的一组规则。所有程序都必须管理其运行时使用计算机内存的方式。一些语言中具有垃圾回收机制，在程序运行时有规律地寻找不再使用的内存；在另一些语言中，程序员必须亲自分配和释放内存。Rust 则选择了第三种方式：通过所有权系统管理内存，编译器在编译时会根据一系列的规则进行检查。如果违反了任何这些规则，程序都不能编译。在运行时，所有权系统的任何功能都不会减慢程序的运行。</p>
<p>因为所有权对很多程序员来说都是一个新概念，需要一些时间来适应。好消息是随着你对 Rust 和所有权系统的规则越来越有经验，你就越能自然地编写出安全和高效的代码。持之以恒！</p>
<p>当你理解了所有权，你将有一个坚实的基础来理解那些使 Rust 独特的功能。在本章中，你将通过完成一些示例来学习所有权，这些示例基于一个常用的数据结构：字符串。</p>
<blockquote>
<h3 id="栈（Stack）与堆（Heap）"><a href="#栈（Stack）与堆（Heap）" class="headerlink" title="栈（Stack）与堆（Heap）"></a><a target="_blank" rel="noopener" href="https://kaisery.github.io/trpl-zh-cn/ch04-01-what-is-ownership.html#%E6%A0%88stack%E4%B8%8E%E5%A0%86heap">栈（Stack）与堆（Heap）</a></h3><p>在很多语言中，你并不需要经常考虑到栈与堆。不过在像 Rust 这样的系统编程语言中，值是位于栈上还是堆上在更大程度上影响了语言的行为以及为何必须做出这样的抉择。我们会在本章的稍后部分描述所有权与栈和堆相关的内容，所以这里只是一个用来预热的简要解释。</p>
<p>栈和堆都是代码在运行时可供使用的内存，但是它们的结构不同。栈以放入值的顺序存储值并以相反顺序取出值。这也被称作 <strong>后进先出</strong>（<em>last in, first out</em>）。想象一下一叠盘子：当增加更多盘子时，把它们放在盘子堆的顶部，当需要盘子时，也从顶部拿走。不能从中间也不能从底部增加或拿走盘子！增加数据叫做 <strong>入栈</strong>（<em>pushing onto the stack</em>），而移出数据叫做 <strong>出栈</strong>（<em>popping off the stack</em>）。栈中的所有数据都必须占用已知且固定的大小。在编译时大小未知或大小可能变化的数据，要改为存储在堆上。</p>
<p>堆是缺乏组织的：当向堆放入数据时，你要请求一定大小的空间。内存分配器（memory allocator）在堆的某处找到一块足够大的空位，把它标记为已使用，并返回一个表示该位置地址的 <strong>指针</strong>（<em>pointer</em>）。这个过程称作 <strong>在堆上分配内存</strong>（<em>allocating on the heap</em>），有时简称为 “分配”（allocating）。（将数据推入栈中并不被认为是分配）。因为指向放入堆中数据的指针是已知的并且大小是固定的，你可以将该指针存储在栈上，不过当需要实际数据时，必须访问指针。想象一下去餐馆就座吃饭。当进入时，你说明有几个人，餐馆员工会找到一个够大的空桌子并领你们过去。如果有人来迟了，他们也可以通过询问来找到你们坐在哪。</p>
<p>入栈比在堆上分配内存要快，因为（入栈时）分配器无需为存储新数据去搜索内存空间；其位置总是在栈顶。相比之下，在堆上分配内存则需要更多的工作，这是因为分配器必须首先找到一块足够存放数据的内存空间，并接着做一些记录为下一次分配做准备。</p>
<p>访问堆上的数据比访问栈上的数据慢，因为必须通过指针来访问。现代处理器在内存中跳转越少就越快。继续类比，假设有一个服务员在餐厅里处理多个桌子的点菜。在一个桌子报完所有菜后再移动到下一个桌子是最有效率的。从桌子 A 听一个菜，接着桌子 B 听一个菜，然后再桌子 A，然后再桌子 B 这样的流程会更加缓慢。出于同样原因，处理器在处理的数据彼此较近的时候（比如在栈上）比较远的时候（比如可能在堆上）更高效。</p>
<p>当你的代码调用一个函数时，传递给函数的值（包括可能指向堆上数据的指针）和函数的局部变量被压入栈中。当函数结束时，这些值被移出栈。</p>
<p>跟踪哪部分代码正在使用堆上的哪些数据，最大限度的减少堆上的重复数据的数量，以及清理堆上不再使用的数据确保不会耗尽空间，这些问题正是所有权系统要处理的。一旦理解了所有权，你就不需要经常考虑栈和堆了，不过明白了所有权的主要目的就是管理堆数据，能够帮助解释为什么所有权要以这种方式工作。</p>
</blockquote>
<h3 id="所有权规则"><a href="#所有权规则" class="headerlink" title="所有权规则"></a><a target="_blank" rel="noopener" href="https://kaisery.github.io/trpl-zh-cn/ch04-01-what-is-ownership.html#%E6%89%80%E6%9C%89%E6%9D%83%E8%A7%84%E5%88%99">所有权规则</a></h3><p>首先，让我们看一下所有权的规则。当我们通过举例说明时，请谨记这些规则：</p>
<blockquote>
<ol>
<li>Rust 中的每一个值都有一个 <strong>所有者</strong>（<em>owner</em>）。</li>
<li>值在任一时刻有且只有一个所有者。</li>
<li>当所有者离开作用域，这个值将被丢弃。</li>
</ol>
</blockquote>
<h3 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a><a target="_blank" rel="noopener" href="https://kaisery.github.io/trpl-zh-cn/ch04-01-what-is-ownership.html#%E5%8F%98%E9%87%8F%E4%BD%9C%E7%94%A8%E5%9F%9F">变量作用域</a></h3><p>既然我们已经掌握了基本语法，将不会在之后的例子中包含 <code>fn main() &#123;</code> 代码，所以如果你是一路跟过来的，必须手动将之后例子的代码放入一个 <code>main</code> 函数中。这样，例子将显得更加简明，使我们可以关注实际细节而不是样板代码。</p>
<p>在所有权的第一个例子中，我们看看一些变量的 <strong>作用域</strong>（<em>scope</em>）。作用域是一个项（item）在程序中有效的范围。假设有这样一个变量：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="string">&quot;hello&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>变量 <code>s</code> 绑定到了一个字符串字面值，这个字符串值是硬编码进程序代码中的。这个变量从声明的点开始直到当前<strong>作用域</strong>结束时都是有效的。示例 4-1 中的注释标明了变量 <code>s</code> 在何处是有效的。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;                      <span class="comment">// s 在这里无效，它尚未声明</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="string">&quot;hello&quot;</span>;   <span class="comment">// 从此处起，s 是有效的</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 s</span></span><br><span class="line">&#125;                      <span class="comment">// 此作用域已结束，s 不再有效</span></span><br></pre></td></tr></table></figure>

<p>示例 4-1：一个变量和其有效的作用域</p>
<p>换句话说，这里有两个重要的时间点：</p>
<ul>
<li>当 <code>s</code> <strong>进入作用域</strong>时，它就是有效的。</li>
<li>这一直持续到它<strong>离开作用域</strong>为止。</li>
</ul>
<p>目前为止，变量是否有效与作用域的关系跟其他编程语言是类似的。现在我们在此基础上介绍 <code>String</code> 类型。</p>
<h3 id="String-类型"><a href="#String-类型" class="headerlink" title="String 类型"></a><a target="_blank" rel="noopener" href="https://kaisery.github.io/trpl-zh-cn/ch04-01-what-is-ownership.html#string-%E7%B1%BB%E5%9E%8B"><code>String</code> 类型</a></h3><p>为了演示所有权的规则，我们需要一个比第三章 <a target="_blank" rel="noopener" href="https://kaisery.github.io/trpl-zh-cn/ch03-02-data-types.html#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">“数据类型”</a> 中讲到的都要复杂的数据类型。前面介绍的类型都是已知大小的，可以存储在栈中，并且当离开作用域时被移出栈，如果代码的另一部分需要在不同的作用域中使用相同的值，可以快速简单地复制它们来创建一个新的独立实例。不过我们需要寻找一个存储在堆上的数据来探索 Rust 是如何知道该在何时清理数据的，而 <code>String</code> 类型就是一个很好的例子。</p>
<p>我们会专注于 <code>String</code> 与所有权相关的部分。这些方面也同样适用于标准库提供的或你自己创建的其他复杂数据类型。在<a target="_blank" rel="noopener" href="https://kaisery.github.io/trpl-zh-cn/ch08-02-strings.html">第八章</a>会更深入地讲解 <code>String</code>。</p>
<p>我们已经见过字符串字面值，即被硬编码进程序里的字符串值。字符串字面值是很方便的，不过它们并不适合使用文本的每一种场景。原因之一就是它们是不可变的。另一个原因是并非所有字符串的值都能在编写代码时就知道：例如，要是想获取用户输入并存储该怎么办呢？为此，Rust 有另一种字符串类型，<code>String</code>。这个类型管理被分配到堆上的数据，所以能够存储在编译时未知大小的文本。可以使用 <code>from</code> 函数基于字符串字面值来创建 <code>String</code>，如下：</p>
<p>这两个冒号 <code>::</code> 是运算符，允许将特定的 <code>from</code> 函数置于 <code>String</code> 类型的命名空间（namespace）下，而不需要使用类似 <code>string_from</code> 这样的名字。在第五章的 <a target="_blank" rel="noopener" href="https://kaisery.github.io/trpl-zh-cn/ch05-03-method-syntax.html#%E6%96%B9%E6%B3%95%E8%AF%AD%E6%B3%95">“方法语法”（“Method Syntax”）</a> 部分会着重讲解这个语法，而且在第七章的 <a target="_blank" rel="noopener" href="https://kaisery.github.io/trpl-zh-cn/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html">“路径用于引用模块树中的项”</a> 中会讲到模块的命名空间。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">s.<span class="title function_ invoke__">push_str</span>(<span class="string">&quot;, world!&quot;</span>); <span class="comment">// push_str() 在字符串后追加字面值</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;s&#125;&quot;</span>); <span class="comment">// 将打印 `hello, world!`</span></span><br></pre></td></tr></table></figure>

<p>那么这里有什么区别呢？为什么 <code>String</code> 可变而字面值却不行呢？区别在于两个类型对内存的处理上。</p>
<h3 id="内存与分配"><a href="#内存与分配" class="headerlink" title="内存与分配"></a><a target="_blank" rel="noopener" href="https://kaisery.github.io/trpl-zh-cn/ch04-01-what-is-ownership.html#%E5%86%85%E5%AD%98%E4%B8%8E%E5%88%86%E9%85%8D">内存与分配</a></h3><p>就字符串字面值来说，我们在编译时就知道其内容，所以文本被直接硬编码进最终的可执行文件中。这使得字符串字面值快速且高效。不过这些特性都只得益于字符串字面值的不可变性。不幸的是，我们不能为了每一个在编译时大小未知的文本而将一块内存放入二进制文件中，并且它的大小还可能随着程序运行而改变。</p>
<p>对于 <code>String</code> 类型，为了支持一个可变，可增长的文本片段，需要在堆上分配一块在编译时未知大小的内存来存放内容。这意味着：</p>
<ul>
<li>必须在运行时向内存分配器（memory allocator）请求内存。</li>
<li>需要一个当我们处理完 <code>String</code> 时将内存返回给分配器的方法。</li>
</ul>
<p>第一部分由我们完成：当调用 <code>String::from</code> 时，它的实现 (<em>implementation</em>) 请求其所需的内存。这在编程语言中是非常通用的。</p>
<p>然而，第二部分实现起来就各有区别了。在有 <strong>垃圾回收</strong>（<em>garbage collector</em>，<em>GC</em>）的语言中，GC 记录并清除不再使用的内存，而我们并不需要关心它。在大部分没有 GC 的语言中，识别出不再使用的内存并调用代码显式释放就是我们的责任了，跟请求内存的时候一样。从历史的角度上说正确处理内存回收曾经是一个困难的编程问题。如果忘记回收了会浪费内存。如果过早回收了，将会出现无效变量。如果重复回收，这也是个 bug。我们需要精确的为一个 <code>allocate</code> 配对一个 <code>free</code>。</p>
<p>Rust 采取了一个不同的策略：内存在拥有它的变量离开作用域后就被自动释放。下面是示例 4-1 中作用域例子的一个使用 <code>String</code> 而不是字符串字面值的版本：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>); <span class="comment">// 从此处起，s 是有效的</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 s</span></span><br><span class="line">&#125;                                  <span class="comment">// 此作用域已结束，</span></span><br><span class="line">                                   <span class="comment">// s 不再有效</span></span><br></pre></td></tr></table></figure>

<p>这是一个将 <code>String</code> 需要的内存返回给分配器的很自然的位置：当 <code>s</code> 离开作用域的时候。当变量离开作用域，Rust 为我们调用一个特殊的函数。这个函数叫做 <a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/ops/trait.Drop.html#tymethod.drop"><code>drop</code></a>，在这里 <code>String</code> 的作者可以放置释放内存的代码。Rust 在结尾的 <code>&#125;</code> 处自动调用 <code>drop</code>。</p>
<blockquote>
<p>注意：在 C++ 中，这种 item 在生命周期结束时释放资源的模式有时被称作 <strong>资源获取即初始化</strong>（<em>Resource Acquisition Is Initialization (RAII)</em>）。如果你使用过 RAII 模式的话应该对 Rust 的 <code>drop</code> 函数并不陌生。</p>
</blockquote>
<p>这个模式对编写 Rust 代码的方式有着深远的影响。现在它看起来很简单，不过在更复杂的场景下代码的行为可能是不可预测的，比如当有多个变量使用在堆上分配的内存时。现在让我们探索一些这样的场景。</p>
<h4 id="使用移动的变量与数据交互"><a href="#使用移动的变量与数据交互" class="headerlink" title="使用移动的变量与数据交互"></a><a target="_blank" rel="noopener" href="https://kaisery.github.io/trpl-zh-cn/ch04-01-what-is-ownership.html#%E4%BD%BF%E7%94%A8%E7%A7%BB%E5%8A%A8%E7%9A%84%E5%8F%98%E9%87%8F%E4%B8%8E%E6%95%B0%E6%8D%AE%E4%BA%A4%E4%BA%92">使用移动的变量与数据交互</a></h4><p>在 Rust 中，多个变量可以采取不同的方式与同一数据进行交互。让我们看看示例 4-2 中一个使用整型的例子。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">y</span> = x;</span><br></pre></td></tr></table></figure>

<p>示例 4-2：将变量 <code>x</code> 的整数值赋给 <code>y</code></p>
<p>我们大致可以猜到这在干什么：“将 <code>5</code> 绑定到 <code>x</code>；接着生成一个值 <code>x</code> 的拷贝并绑定到 <code>y</code>”。现在有了两个变量，<code>x</code> 和 <code>y</code>，都等于 <code>5</code>。这也正是事实上发生了的，因为整数是有已知固定大小的简单值，所以这两个 <code>5</code> 被压入了栈中。</p>
<p>现在看看这个 <code>String</code> 版本：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s2</span> = s1;</span><br></pre></td></tr></table></figure>

<p>这看起来与上面的代码非常类似，所以我们可能会假设它们的运行方式也是类似的：也就是说，第二行可能会生成一个 <code>s1</code> 的拷贝并绑定到 <code>s2</code> 上。但事实并非如此。</p>
<p>看看图 4-1 以了解 <code>String</code> 的底层会发生什么。<code>String</code> 由三部分组成，如图左侧所示：一个指向存放字符串内容内存的指针，一个长度，和一个容量。这一组数据存储在栈上。右侧则是堆上存放内容的内存部分。</p>
<p><img data-src="https://kaisery.github.io/trpl-zh-cn/img/trpl04-01.svg" alt="Two tables: the first table contains the representation of s1 on the stack, consisting of its length (5), capacity (5), and a pointer to the first value in the second table. The second table contains the representation of the string data on the heap, byte by byte."></p>
<p>图 4-1：将值 <code>&quot;hello&quot;</code> 绑定给 <code>s1</code> 的 <code>String</code> 在内存中的表现形式</p>
<p>长度表示 <code>String</code> 的内容当前使用了多少字节的内存。容量是 <code>String</code> 从分配器总共获取了多少字节的内存。长度与容量的区别是很重要的，不过在当前上下文中并不重要，所以现在可以忽略容量。</p>
<p>当我们将 <code>s1</code> 赋值给 <code>s2</code>，<code>String</code> 的数据被复制了，这意味着我们从栈上拷贝了它的指针、长度和容量。我们并没有复制指针指向的堆上数据。换句话说，内存中数据的表现如图 4-2 所示。</p>
<p><img data-src="https://kaisery.github.io/trpl-zh-cn/img/trpl04-02.svg" alt="Three tables: tables s1 and s2 representing those strings on the stack, respectively, and both pointing to the same string data on the heap."></p>
<p>图 4-2：变量 <code>s2</code> 的内存表现，它有一份 <code>s1</code> 指针、长度和容量的拷贝</p>
<p>这个表现形式看起来<strong>并不像</strong>图 4-3 中的那样，如果 Rust 也拷贝了堆上的数据，那么内存看起来就是这样的。如果 Rust 这么做了，那么操作 <code>s2 = s1</code> 在堆上数据比较大的时候会对运行时性能造成非常大的影响。</p>
<p><img data-src="https://kaisery.github.io/trpl-zh-cn/img/trpl04-03.svg" alt="Four tables: two tables representing the stack data for s1 and s2, and each points to its own copy of string data on the heap."></p>
<p>图 4-3：另一个 <code>s2 = s1</code> 时可能的内存表现，如果 Rust 同时也拷贝了堆上的数据的话</p>
<p>之前我们提到过当变量离开作用域后，Rust 自动调用 <code>drop</code> 函数并清理变量的堆内存。不过图 4-2 展示了两个数据指针指向了同一位置。这就有了一个问题：当 <code>s2</code> 和 <code>s1</code> 离开作用域，它们都会尝试释放相同的内存。这是一个叫做 <strong>二次释放</strong>（<em>double free</em>）的错误，也是之前提到过的内存安全性 bug 之一。两次释放（相同）内存会导致内存污染，它可能会导致潜在的安全漏洞。</p>
<p>为了确保内存安全，在 <code>let s2 = s1;</code> 之后，Rust 认为 <code>s1</code> 不再有效，因此 Rust 不需要在 <code>s1</code> 离开作用域后清理任何东西。看看在 <code>s2</code> 被创建之后尝试使用 <code>s1</code> 会发生什么；这段代码不能运行：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s2</span> = s1;</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;s1&#125;, world!&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>你会得到一个类似如下的错误，因为 Rust 禁止你使用无效的引用。</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cargo run</span></span><br><span class="line">   Compiling ownership v0.1.0 (file:///projects/ownership)</span><br><span class="line">error[E0382]: borrow of moved value: `s1`</span><br><span class="line"><span class="meta prompt_"> --&gt; </span><span class="language-bash">src/main.rs:5:15</span></span><br><span class="line">  |</span><br><span class="line">2 |     let s1 = String::from(&quot;hello&quot;);</span><br><span class="line">  |         -- move occurs because `s1` has type `String`, which does not implement the `Copy` trait</span><br><span class="line">3 |     let s2 = s1;</span><br><span class="line">  |              -- value moved here</span><br><span class="line">4 |</span><br><span class="line">5 |     println!(&quot;&#123;s1&#125;, world!&quot;);</span><br><span class="line">  |               ^^^^ value borrowed here after move</span><br><span class="line">  |</span><br><span class="line">  = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)</span><br><span class="line">help: consider cloning the value if the performance cost is acceptable</span><br><span class="line">  |</span><br><span class="line">3 |     let s2 = s1.clone();</span><br><span class="line">  |                ++++++++</span><br><span class="line"></span><br><span class="line">For more information about this error, try `rustc --explain E0382`.</span><br><span class="line">error: could not compile `ownership` (bin &quot;ownership&quot;) due to 1 previous error</span><br></pre></td></tr></table></figure>

<p>如果你在其他语言中听说过术语 <strong>浅拷贝</strong>（<em>shallow copy</em>）和 <strong>深拷贝</strong>（<em>deep copy</em>），那么拷贝指针、长度和容量而不拷贝数据可能听起来像浅拷贝。不过因为 Rust 同时使第一个变量无效了，这个操作被称为 <strong>移动</strong>（<em>move</em>），而不是叫做浅拷贝。上面的例子可以解读为 <code>s1</code> 被 <strong>移动</strong> 到了 <code>s2</code> 中。那么具体发生了什么，如图 4-4 所示。</p>
<p><img data-src="https://kaisery.github.io/trpl-zh-cn/img/trpl04-04.svg" alt="Three tables: tables s1 and s2 representing those strings on the stack, respectively, and both pointing to the same string data on the heap. Table s1 is grayed out be-cause s1 is no longer valid; only s2 can be used to access the heap data."></p>
<p>图 4-4：<code>s1</code> 无效之后的内存表现</p>
<p>这样就解决了我们的问题！因为只有 <code>s2</code> 是有效的，当其离开作用域，它就释放自己的内存，完毕。</p>
<p>另外，这里还隐含了一个设计选择：Rust 永远也不会自动创建数据的 “深拷贝”。因此，任何<strong>自动</strong>的复制都可以被认为是对运行时性能影响较小的。</p>
<h4 id="作用域与赋值"><a href="#作用域与赋值" class="headerlink" title="作用域与赋值"></a><a target="_blank" rel="noopener" href="https://kaisery.github.io/trpl-zh-cn/ch04-01-what-is-ownership.html#%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E8%B5%8B%E5%80%BC">作用域与赋值</a></h4><p>作用域、所有权和通过 <code>drop</code> 函数释放内存之间的关系反过来也同样成立。当你给一个已有的变量赋一个全新的值时，Rust 将会立即调用 <code>drop</code> 并释放原始值的内存。例如，考虑如下代码：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">s = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;ahoy&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;s&#125;, world!&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>起初我们声明了变量 <code>s</code> 并绑定为一个 <code>&quot;hello&quot;</code> 值的 <code>String</code>。接着立即创建了一个值为 <code>&quot;ahoy&quot;</code> 的 <code>String</code> 并赋值给 <code>s</code>。在这里，完全没有任何内容指向了原始堆上的值。</p>
<p><img data-src="https://kaisery.github.io/trpl-zh-cn/img/trpl04-05.svg" alt="One table s representing the string value on the stack, pointing to the second piece of string data (ahoy) on the heap, with the original string data (hello) grayed out because it cannot be accessed anymore."></p>
<p>图 4-5: 当初始值被整体替换后的内存表现</p>
<p>因此原始的字符串立刻就离开了作用域。Rust 会在其上运行 <code>drop</code> 函数同时内存会马上释放。当结尾打印其值时，将会是 <code>&quot;ahoy, world!&quot;</code>。</p>
<h4 id="使用克隆的变量与数据交互"><a href="#使用克隆的变量与数据交互" class="headerlink" title="使用克隆的变量与数据交互"></a><a target="_blank" rel="noopener" href="https://kaisery.github.io/trpl-zh-cn/ch04-01-what-is-ownership.html#%E4%BD%BF%E7%94%A8%E5%85%8B%E9%9A%86%E7%9A%84%E5%8F%98%E9%87%8F%E4%B8%8E%E6%95%B0%E6%8D%AE%E4%BA%A4%E4%BA%92">使用克隆的变量与数据交互</a></h4><p>如果我们 <strong>确实</strong> 需要深度复制 <code>String</code> 中堆上的数据，而不仅仅是栈上的数据，可以使用一个叫做 <code>clone</code> 的常用方法。第五章会讨论方法语法，不过因为方法在很多语言中是一个常见功能，所以之前你可能已经见过了。</p>
<p>这是一个实际使用 <code>clone</code> 方法的例子：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s2</span> = s1.<span class="title function_ invoke__">clone</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;s1 = &#123;s1&#125;, s2 = &#123;s2&#125;&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>这段代码能正常运行，并且明确产生图 4-3 中行为，这里堆上的数据<strong>确实</strong>被复制了。</p>
<p>当出现 <code>clone</code> 调用时，你知道一些特定的代码被执行而且这些代码可能相当消耗资源。你很容易察觉到一些不寻常的事情正在发生。</p>
<h4 id="只在栈上的数据：拷贝"><a href="#只在栈上的数据：拷贝" class="headerlink" title="只在栈上的数据：拷贝"></a><a target="_blank" rel="noopener" href="https://kaisery.github.io/trpl-zh-cn/ch04-01-what-is-ownership.html#%E5%8F%AA%E5%9C%A8%E6%A0%88%E4%B8%8A%E7%9A%84%E6%95%B0%E6%8D%AE%E6%8B%B7%E8%B4%9D">只在栈上的数据：拷贝</a></h4><p>这里还有一个没有提到的细节。这些代码使用了整型并且是有效的，它们是示例 4-2 中的一部分：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">y</span> = x;</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;x = &#123;x&#125;, y = &#123;y&#125;&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>但这段代码似乎与我们刚刚学到的内容相矛盾：没有调用 <code>clone</code>，不过 <code>x</code> 依然有效且没有被移动到 <code>y</code> 中。</p>
<p>原因是像整型这样的在编译时已知大小的类型被整个存储在栈上，所以拷贝其实际的值是快速的。这意味着没有理由在创建变量 <code>y</code> 后使 <code>x</code> 无效。换句话说，这里没有深浅拷贝的区别，所以这里调用 <code>clone</code> 并不会与通常的浅拷贝有什么不同，我们可以不用管它。</p>
<p>Rust 有一个叫做 <code>Copy</code> trait 的特殊注解，可以用在类似整型这样的存储在栈上的类型上（<a target="_blank" rel="noopener" href="https://kaisery.github.io/trpl-zh-cn/ch10-00-generics.html">第十章</a>将会详细讲解 trait）。如果一个类型实现了 <code>Copy</code> trait，那么一个旧的变量在将其赋值给其他变量后仍然有效。</p>
<p>Rust 不允许自身或其任何部分实现了 <code>Drop</code> trait 的类型使用 <code>Copy</code> trait。如果我们对其值离开作用域时需要特殊处理的类型使用 <code>Copy</code> 注解，将会出现一个编译时错误。要学习如何为你的类型添加 <code>Copy</code> 注解以实现该 trait，请阅读附录 C 中的 <a target="_blank" rel="noopener" href="https://kaisery.github.io/trpl-zh-cn/appendix-03-derivable-traits.html">“可派生的 trait”</a>。</p>
<p>那么哪些类型实现了 <code>Copy</code> trait 呢？你可以查看给定类型的文档来确认，不过作为一个通用的规则，任何一组简单标量值的组合都可以实现 <code>Copy</code>，任何不需要分配内存或某种形式资源的类型都可以实现 <code>Copy</code> 。如下是一些 <code>Copy</code> 的类型：</p>
<ul>
<li>所有整数类型，比如 <code>u32</code>。</li>
<li>布尔类型，<code>bool</code>，它的值是 <code>true</code> 和 <code>false</code>。</li>
<li>所有浮点数类型，比如 <code>f64</code>。</li>
<li>字符类型，<code>char</code>。</li>
<li>元组，当且仅当其包含的类型也都实现 <code>Copy</code> 的时候。比如，<code>(i32, i32)</code> 实现了 <code>Copy</code>，但 <code>(i32, String)</code> 就没有。</li>
</ul>
<h3 id="所有权与函数"><a href="#所有权与函数" class="headerlink" title="所有权与函数"></a><a target="_blank" rel="noopener" href="https://kaisery.github.io/trpl-zh-cn/ch04-01-what-is-ownership.html#%E6%89%80%E6%9C%89%E6%9D%83%E4%B8%8E%E5%87%BD%E6%95%B0">所有权与函数</a></h3><p>将值传递给函数与给变量赋值的原理相似。向函数传递值可能会移动或者复制，就像赋值语句一样。示例 4-3 使用注释展示变量何时进入和离开作用域：</p>
<p>文件名：src&#x2F;main.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);  <span class="comment">// s 进入作用域</span></span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">takes_ownership</span>(s);             <span class="comment">// s 的值移动到函数里 ...</span></span><br><span class="line">                                    <span class="comment">// ... 所以到这里不再有效</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;                      <span class="comment">// x 进入作用域</span></span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">makes_copy</span>(x);                  <span class="comment">// x 应该移动函数里，</span></span><br><span class="line">                                    <span class="comment">// 但 i32 是 Copy 的，</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, x);              <span class="comment">// 所以在后面可继续使用 x</span></span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// 这里，x 先移出了作用域，然后是 s。但因为 s 的值已被移走，</span></span><br><span class="line">  <span class="comment">// 没有特殊之处</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">takes_ownership</span>(some_string: <span class="type">String</span>) &#123; <span class="comment">// some_string 进入作用域</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;some_string&#125;&quot;</span>);</span><br><span class="line">&#125; <span class="comment">// 这里，some_string 移出作用域并调用 `drop` 方法。</span></span><br><span class="line">  <span class="comment">// 占用的内存被释放</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">makes_copy</span>(some_integer: <span class="type">i32</span>) &#123; <span class="comment">// some_integer 进入作用域</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;some_integer&#125;&quot;</span>);</span><br><span class="line">&#125; <span class="comment">// 这里，some_integer 移出作用域。没有特殊之处</span></span><br></pre></td></tr></table></figure>

<p>示例 4-3：带有所有权和作用域注释的函数</p>
<p>当尝试在调用 <code>takes_ownership</code> 后使用 <code>s</code> 时，Rust 会抛出一个编译时错误。这些静态检查使我们免于犯错。试试在 <code>main</code> 函数中添加使用 <code>s</code> 和 <code>x</code> 的代码来看看哪里能使用它们，以及所有权规则会在哪里阻止我们这么做。</p>
<h3 id="返回值与作用域"><a href="#返回值与作用域" class="headerlink" title="返回值与作用域"></a><a target="_blank" rel="noopener" href="https://kaisery.github.io/trpl-zh-cn/ch04-01-what-is-ownership.html#%E8%BF%94%E5%9B%9E%E5%80%BC%E4%B8%8E%E4%BD%9C%E7%94%A8%E5%9F%9F">返回值与作用域</a></h3><p>返回值也可以转移所有权。示例 4-4 展示了一个返回了某些值的示例，与示例 4-3 一样带有类似的注释。</p>
<p>文件名：src&#x2F;main.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s1</span> = <span class="title function_ invoke__">gives_ownership</span>();        <span class="comment">// gives_ownership 将它的返回值传递给 s1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s2</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);    <span class="comment">// s2 进入作用域</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s3</span> = <span class="title function_ invoke__">takes_and_gives_back</span>(s2); <span class="comment">// s2 被传入 takes_and_gives_back, </span></span><br><span class="line">                                       <span class="comment">// 它的返回值又传递给 s3</span></span><br><span class="line">&#125; <span class="comment">// 此处，s3 移出作用域并被丢弃。s2 被 move，所以无事发生</span></span><br><span class="line">  <span class="comment">// s1 移出作用域并被丢弃</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">gives_ownership</span>() <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;       <span class="comment">// gives_ownership 将会把返回值传入</span></span><br><span class="line">                                       <span class="comment">// 调用它的函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">some_string</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;yours&quot;</span>); <span class="comment">// some_string 进入作用域</span></span><br><span class="line"></span><br><span class="line">    some_string                        <span class="comment">// 返回 some_string 并将其移至调用函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 该函数将传入字符串并返回该值</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">takes_and_gives_back</span>(a_string: <span class="type">String</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">    <span class="comment">// a_string 进入作用域</span></span><br><span class="line"></span><br><span class="line">    a_string  <span class="comment">// 返回 a_string 并移出给调用的函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例 4-4: 转移返回值的所有权</p>
<p>变量的所有权总是遵循相同的模式：将值赋给另一个变量时它会移动。当持有堆中数据值的变量离开作用域时，其值将通过 <code>drop</code> 被清理掉，除非数据被移动为另一个变量所有。</p>
<p>虽然这样是可以的，但是在每一个函数中都获取所有权并接着返回所有权有些啰嗦。如果我们想要函数使用一个值但不获取所有权该怎么办呢？如果我们还要接着使用它的话，每次都传进去再返回来就有点烦人了，除此之外，我们也可能想返回函数体中产生的一些数据。</p>
<p>我们可以使用元组来返回多个值，如示例 4-5 所示。</p>
<p>文件名：src&#x2F;main.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> (s2, len) = <span class="title function_ invoke__">calculate_length</span>(s1);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The length of &#x27;&#123;s2&#125;&#x27; is &#123;len&#125;.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">calculate_length</span>(s: <span class="type">String</span>) <span class="punctuation">-&gt;</span> (<span class="type">String</span>, <span class="type">usize</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">length</span> = s.<span class="title function_ invoke__">len</span>(); <span class="comment">// len() 返回字符串的长度</span></span><br><span class="line"></span><br><span class="line">    (s, length)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例 4-5: 返回参数的所有权</p>
<h2 id="引用与借用"><a href="#引用与借用" class="headerlink" title="引用与借用"></a><a target="_blank" rel="noopener" href="https://kaisery.github.io/trpl-zh-cn/ch04-02-references-and-borrowing.html#%E5%BC%95%E7%94%A8%E4%B8%8E%E5%80%9F%E7%94%A8">引用与借用</a></h2><p>示例 4-5 中的元组代码有这样一个问题：我们必须将 <code>String</code> 返回给调用函数，以便在调用 <code>calculate_length</code> 后仍能使用 <code>String</code>，因为 <code>String</code> 被移动到了 <code>calculate_length</code> 内。相反我们可以提供一个 <code>String</code> 值的引用（reference）。<strong>引用</strong>（<em>reference</em>）像一个指针，因为它是一个地址，我们可以由此访问储存于该地址的属于其他变量的数据。与指针不同，引用在其生命周期内保证指向某个特定类型的有效值。</p>
<p>下面是如何定义并使用一个（新的）<code>calculate_length</code> 函数，它以一个对象的引用作为参数而不是获取值的所有权：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">len</span> = <span class="title function_ invoke__">calculate_length</span>(&amp;s1);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The length of &#x27;&#123;s1&#125;&#x27; is &#123;len&#125;.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">calculate_length</span>(s: &amp;<span class="type">String</span>) <span class="punctuation">-&gt;</span> <span class="type">usize</span> &#123;</span><br><span class="line">    s.<span class="title function_ invoke__">len</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先，注意变量声明和函数返回值中的所有元组代码都消失了。其次，注意我们传递 <code>&amp;s1</code> 给 <code>calculate_length</code>，同时在函数定义中，我们获取 <code>&amp;String</code> 而不是 <code>String</code>。这些 &amp; 符号就是 <strong>引用</strong>，它们允许你使用值但不获取其所有权。图 4-6 展示了一张示意图。</p>
<p><img data-src="https://kaisery.github.io/trpl-zh-cn/img/trpl04-06.svg" alt="Three tables: the table for s contains only a pointer to the table for s1. The table for s1 contains the stack data for s1 and points to the string data on the heap."></p>
<p>图 4-6：<code>&amp;String s</code> 指向 <code>String s1</code> 示意图</p>
<blockquote>
<p>注意：与使用 <code>&amp;</code> 引用相反的操作是 <strong>解引用</strong>（<em>dereferencing</em>），它使用解引用运算符 <code>*</code> 实现。我们将会在第八章遇到一些解引用运算符，并在第十五章详细讨论解引用。</p>
</blockquote>
<p>仔细看看这个函数调用：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">len</span> = <span class="title function_ invoke__">calculate_length</span>(&amp;s1);</span><br></pre></td></tr></table></figure>

<p><code>&amp;s1</code> 语法让我们创建一个<strong>指向</strong>值 <code>s1</code> 的引用，但是并不拥有它。因为并不拥有这个值，所以当引用停止使用时，它所指向的值也不会被丢弃。</p>
<p>同理，函数签名使用 <code>&amp;</code> 来表明参数 <code>s</code> 的类型是一个引用。让我们增加一些解释性的注释：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">calculate_length</span>(s: &amp;<span class="type">String</span>) <span class="punctuation">-&gt;</span> <span class="type">usize</span> &#123; <span class="comment">// s 是 String 的引用</span></span><br><span class="line">    s.<span class="title function_ invoke__">len</span>()</span><br><span class="line">&#125; <span class="comment">// 这里，s 离开了作用域。但因为它并不拥有引用值的所有权，</span></span><br><span class="line">  <span class="comment">// 所以什么也不会发生</span></span><br></pre></td></tr></table></figure>

<p>变量 <code>s</code> 有效的作用域与函数参数的作用域一样，不过当 <code>s</code> 停止使用时并不丢弃引用指向的数据，因为 <code>s</code> 并没有所有权。当函数使用引用而不是实际值作为参数，无需返回值来交还所有权，因为就不曾拥有所有权。</p>
<p>我们将创建一个引用的行为称为 <strong>借用</strong>（<em>borrowing</em>）。正如现实生活中，如果一个人拥有某样东西，你可以从他那里借来。当你使用完后，必须还回去。因为我们并不拥有它的所有权。</p>
<p>那如果我们尝试修改借用的变量呢？尝试示例 4-6 中的代码。剧透：这行不通！</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">change</span>(&amp;s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">change</span>(some_string: &amp;<span class="type">String</span>) &#123;</span><br><span class="line">    some_string.<span class="title function_ invoke__">push_str</span>(<span class="string">&quot;, world&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例 4-6：尝试修改借用的值</p>
<p>这里是错误：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cargo run</span></span><br><span class="line">   Compiling ownership v0.1.0 (file:///projects/ownership)</span><br><span class="line">error[E0596]: cannot borrow `*some_string` as mutable, as it is behind a `&amp;` reference</span><br><span class="line"><span class="meta prompt_"> --&gt; </span><span class="language-bash">src/main.rs:8:5</span></span><br><span class="line">  |</span><br><span class="line">8 |     some_string.push_str(&quot;, world&quot;);</span><br><span class="line">  |     ^^^^^^^^^^^ `some_string` is a `&amp;` reference, so the data it refers to cannot be borrowed as mutable</span><br><span class="line">  |</span><br><span class="line">help: consider changing this to be a mutable reference</span><br><span class="line">  |</span><br><span class="line">7 | fn change(some_string: &amp;mut String) &#123;</span><br><span class="line">  |                         +++</span><br><span class="line"></span><br><span class="line">For more information about this error, try `rustc --explain E0596`.</span><br><span class="line">error: could not compile `ownership` (bin &quot;ownership&quot;) due to 1 previous error</span><br></pre></td></tr></table></figure>

<p>正如变量默认是不可变的，引用也一样。（默认）不允许修改引用的值。</p>
<h3 id="可变引用"><a href="#可变引用" class="headerlink" title="可变引用"></a><a target="_blank" rel="noopener" href="https://kaisery.github.io/trpl-zh-cn/ch04-02-references-and-borrowing.html#%E5%8F%AF%E5%8F%98%E5%BC%95%E7%94%A8">可变引用</a></h3><p>我们通过一个小调整就能修复示例 4-6 代码中的错误，允许我们修改一个借用的值，这就是 <strong>可变引用</strong>（<em>mutable reference</em>）：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">change</span>(&amp;<span class="keyword">mut</span> s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">change</span>(some_string: &amp;<span class="keyword">mut</span> <span class="type">String</span>) &#123;</span><br><span class="line">    some_string.<span class="title function_ invoke__">push_str</span>(<span class="string">&quot;, world&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先，我们必须将 <code>s</code> 改为 <code>mut</code>。然后在调用 <code>change</code> 函数的地方创建一个可变引用 <code>&amp;mut s</code>，并更新函数签名以接受一个可变引用 <code>some_string: &amp;mut String</code>。这就非常清楚地表明，<code>change</code> 函数将改变它所借用的值。</p>
<p>可变引用有一个很大的限制：如果你有一个对该变量的可变引用，你就不能再创建对该变量的引用。这些尝试创建两个 <code>s</code> 的可变引用的代码会失败：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">r1</span> = &amp;<span class="keyword">mut</span> s;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">r2</span> = &amp;<span class="keyword">mut</span> s;</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;, &#123;&#125;&quot;</span>, r1, r2);</span><br></pre></td></tr></table></figure>

<p>错误如下：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cargo run</span></span><br><span class="line">   Compiling ownership v0.1.0 (file:///projects/ownership)</span><br><span class="line">error[E0499]: cannot borrow `s` as mutable more than once at a time</span><br><span class="line"><span class="meta prompt_"> --&gt; </span><span class="language-bash">src/main.rs:5:14</span></span><br><span class="line">  |</span><br><span class="line">4 |     let r1 = &amp;mut s;</span><br><span class="line">  |              ------ first mutable borrow occurs here</span><br><span class="line">5 |     let r2 = &amp;mut s;</span><br><span class="line">  |              ^^^^^^ second mutable borrow occurs here</span><br><span class="line">6 |</span><br><span class="line">7 |     println!(&quot;&#123;&#125;, &#123;&#125;&quot;, r1, r2);</span><br><span class="line">  |                        -- first borrow later used here</span><br><span class="line"></span><br><span class="line">For more information about this error, try `rustc --explain E0499`.</span><br><span class="line">error: could not compile `ownership` (bin &quot;ownership&quot;) due to 1 previous error</span><br></pre></td></tr></table></figure>

<p>这个报错说这段代码是无效的，因为我们不能在同一时间多次将 <code>s</code> 作为可变变量借用。第一个可变的借入在 <code>r1</code> 中，并且必须持续到在 <code>println!</code> 中使用它，但是在那个可变引用的创建和它的使用之间，我们又尝试在 <code>r2</code> 中创建另一个可变引用，该引用借用与 <code>r1</code> 相同的数据。</p>
<p>这一限制以一种非常小心谨慎的方式允许可变性，防止同一时间对同一数据存在多个可变引用。新 Rustacean 们经常难以适应这一点，因为大部分语言中变量任何时候都是可变的。这个限制的好处是 Rust 可以在编译时就避免数据竞争。<strong>数据竞争</strong>（<em>data race</em>）类似于竞态条件，它可由这三个行为造成：</p>
<ul>
<li>两个或更多指针同时访问同一数据。</li>
<li>至少有一个指针被用来写入数据。</li>
<li>没有同步数据访问的机制。</li>
</ul>
<p>数据竞争会导致未定义行为，难以在运行时追踪，并且难以诊断和修复；Rust 通过拒绝编译存在数据竞争的代码来避免此问题！</p>
<p>一如既往，可以使用大括号来创建一个新的作用域，以允许拥有多个可变引用，只是不能<strong>同时</strong>拥有：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r1</span> = &amp;<span class="keyword">mut</span> s;</span><br><span class="line">&#125; <span class="comment">// r1 在这里离开了作用域，所以我们完全可以创建一个新的引用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">r2</span> = &amp;<span class="keyword">mut</span> s;</span><br></pre></td></tr></table></figure>

<p>Rust 在同时使用可变与不可变引用时也强制采用类似的规则。这些代码会导致一个错误：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">r1</span> = &amp;s; <span class="comment">// 没问题</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">r2</span> = &amp;s; <span class="comment">// 没问题</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">r3</span> = &amp;<span class="keyword">mut</span> s; <span class="comment">// 大问题</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;, &#123;&#125;, and &#123;&#125;&quot;</span>, r1, r2, r3);</span><br></pre></td></tr></table></figure>

<p>错误如下：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cargo run</span></span><br><span class="line">   Compiling ownership v0.1.0 (file:///projects/ownership)</span><br><span class="line">error[E0502]: cannot borrow `s` as mutable because it is also borrowed as immutable</span><br><span class="line"><span class="meta prompt_"> --&gt; </span><span class="language-bash">src/main.rs:6:14</span></span><br><span class="line">  |</span><br><span class="line">4 |     let r1 = &amp;s; // no problem</span><br><span class="line">  |              -- immutable borrow occurs here</span><br><span class="line">5 |     let r2 = &amp;s; // no problem</span><br><span class="line">6 |     let r3 = &amp;mut s; // BIG PROBLEM</span><br><span class="line">  |              ^^^^^^ mutable borrow occurs here</span><br><span class="line">7 |</span><br><span class="line">8 |     println!(&quot;&#123;&#125;, &#123;&#125;, and &#123;&#125;&quot;, r1, r2, r3);</span><br><span class="line">  |                                -- immutable borrow later used here</span><br><span class="line"></span><br><span class="line">For more information about this error, try `rustc --explain E0502`.</span><br><span class="line">error: could not compile `ownership` (bin &quot;ownership&quot;) due to 1 previous error</span><br></pre></td></tr></table></figure>

<p>呼！我们<strong>也</strong>不能在拥有不可变引用的同时拥有可变引用。</p>
<p>不可变引用的借用者可不希望在借用时值会突然发生改变！然而，多个不可变引用是可以的，因为没有哪个只能读取数据的引用者能够影响其他引用者读取到的数据。</p>
<p>注意一个引用的作用域从声明的地方开始一直持续到最后一次使用为止。例如，因为最后一次使用不可变引用的位置在 <code>println!</code>，它发生在声明可变引用之前，所以如下代码是可以编译的：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">r1</span> = &amp;s; <span class="comment">// 没问题</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">r2</span> = &amp;s; <span class="comment">// 没问题</span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;r1&#125; and &#123;r2&#125;&quot;</span>);</span><br><span class="line"><span class="comment">// 此位置之后 r1 和 r2 不再使用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">r3</span> = &amp;<span class="keyword">mut</span> s; <span class="comment">// 没问题</span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;r3&#125;&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>不可变引用 <code>r1</code> 和 <code>r2</code> 的作用域在 <code>println!</code> 最后一次使用之后结束，这发生在可变引用 <code>r3</code> 被创建之前。因为它们的作用域没有重叠，所以代码是可以编译的。编译器可以在作用域结束之前判断不再使用的引用。</p>
<p>尽管借用错误有时令人沮丧，但请牢记这是 Rust 编译器在提前指出一个潜在的 bug（在编译时而不是在运行时）并精准显示问题所在。这样你就不必去跟踪为何数据并不是你想象中的那样。</p>
<h3 id="悬垂引用（Dangling-References）"><a href="#悬垂引用（Dangling-References）" class="headerlink" title="悬垂引用（Dangling References）"></a><a target="_blank" rel="noopener" href="https://kaisery.github.io/trpl-zh-cn/ch04-02-references-and-borrowing.html#%E6%82%AC%E5%9E%82%E5%BC%95%E7%94%A8dangling-references">悬垂引用（Dangling References）</a></h3><p>在具有指针的语言中，很容易通过释放内存时保留指向它的指针而错误地生成一个<strong>悬垂指针</strong>（<em>dangling pointer</em>）—— 指向可能已被分配给其他用途的内存位置的指针。相比之下，在 Rust 中编译器确保引用永远也不会变成悬垂引用：当你拥有一些数据的引用，编译器确保数据不会在其引用之前离开作用域。</p>
<p>让我们尝试创建一个悬垂引用，看看 Rust 如何通过通过一个编译时错误来防止它：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">reference_to_nothing</span> = <span class="title function_ invoke__">dangle</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">dangle</span>() <span class="punctuation">-&gt;</span> &amp;<span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &amp;s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里是错误：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cargo run</span></span><br><span class="line">   Compiling ownership v0.1.0 (file:///projects/ownership)</span><br><span class="line">error[E0106]: missing lifetime specifier</span><br><span class="line"><span class="meta prompt_"> --&gt; </span><span class="language-bash">src/main.rs:5:16</span></span><br><span class="line">  |</span><br><span class="line">5 | fn dangle() -&gt; &amp;String &#123;</span><br><span class="line">  |                ^ expected named lifetime parameter</span><br><span class="line">  |</span><br><span class="line">  = help: this function&#x27;s return type contains a borrowed value, but there is no value for it to be borrowed from</span><br><span class="line">help: consider using the `&#x27;static` lifetime, but this is uncommon unless you&#x27;re returning a borrowed value from a `const` or a `static`</span><br><span class="line">  |</span><br><span class="line">5 | fn dangle() -&gt; &amp;&#x27;static String &#123;</span><br><span class="line">  |                 +++++++</span><br><span class="line">help: instead, you are more likely to want to return an owned value</span><br><span class="line">  |</span><br><span class="line">5 - fn dangle() -&gt; &amp;String &#123;</span><br><span class="line">5 + fn dangle() -&gt; String &#123;</span><br><span class="line">  |</span><br><span class="line"></span><br><span class="line">error[E0515]: cannot return reference to local variable `s`</span><br><span class="line"><span class="meta prompt_"> --&gt; </span><span class="language-bash">src/main.rs:8:5</span></span><br><span class="line">  |</span><br><span class="line">8 |     &amp;s</span><br><span class="line">  |     ^^ returns a reference to data owned by the current function</span><br><span class="line"></span><br><span class="line">Some errors have detailed explanations: E0106, E0515.</span><br><span class="line">For more information about an error, try `rustc --explain E0106`.</span><br><span class="line">error: could not compile `ownership` (bin &quot;ownership&quot;) due to 2 previous errors</span><br></pre></td></tr></table></figure>

<p>错误信息引用了一个我们还未介绍的功能：生命周期（lifetimes）。第十章会详细介绍生命周期。不过，如果你不理会生命周期部分，错误信息中确实包含了为什么这段代码有问题的关键信息：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">this function&#x27;s return type contains a borrowed value, but there is no value</span><br><span class="line">for it to be borrowed from</span><br></pre></td></tr></table></figure>

<p>让我们仔细看看我们的 <code>dangle</code> 代码的每个阶段到底发生了什么：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">dangle</span>() <span class="punctuation">-&gt;</span> &amp;<span class="type">String</span> &#123; <span class="comment">// dangle 返回一个字符串的引用</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>); <span class="comment">// s 是一个新字符串</span></span><br><span class="line"></span><br><span class="line">    &amp;s <span class="comment">// 返回字符串 s 的引用</span></span><br><span class="line">&#125; <span class="comment">// 这里 s 离开作用域并被丢弃。其内存被释放。</span></span><br><span class="line">  <span class="comment">// 危险！</span></span><br></pre></td></tr></table></figure>

<p>因为 <code>s</code> 是在 <code>dangle</code> 函数内创建的，当 <code>dangle</code> 的代码执行完毕后，<code>s</code> 将被释放。不过我们尝试返回它的引用。这意味着这个引用会指向一个无效的 <code>String</code>，这可不对！Rust 不会允许我们这么做。</p>
<p>这里的解决方法是直接返回 <code>String</code>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">no_dangle</span>() <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">    s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就没有任何错误了。所有权被移动出去，所以没有值被释放。</p>
<h3 id="引用的规则"><a href="#引用的规则" class="headerlink" title="引用的规则"></a><a target="_blank" rel="noopener" href="https://kaisery.github.io/trpl-zh-cn/ch04-02-references-and-borrowing.html#%E5%BC%95%E7%94%A8%E7%9A%84%E8%A7%84%E5%88%99">引用的规则</a></h3><p>让我们概括一下之前对引用的讨论：</p>
<ul>
<li>在任意给定时间，<strong>要么</strong>只能有一个可变引用，<strong>要么</strong>只能有多个不可变引用。</li>
<li>引用必须总是有效的。</li>
</ul>
<p>接下来，我们来看看另一种不同类型的引用：slice。</p>
<h2 id="Slice-类型"><a href="#Slice-类型" class="headerlink" title="Slice 类型"></a><a target="_blank" rel="noopener" href="https://kaisery.github.io/trpl-zh-cn/ch04-03-slices.html#slice-%E7%B1%BB%E5%9E%8B">Slice 类型</a></h2><p><strong>切片</strong>（<em>slice</em>）允许你引用集合中一段连续的元素序列，而不用引用整个集合。slice 是一种引用，所以它不拥有所有权。</p>
<p>这里有一个编程小习题：编写一个函数，该函数接收一个用空格分隔单词的字符串，并返回在该字符串中找到的第一个单词。如果函数在该字符串中并未找到空格，则整个字符串就是一个单词，所以应该返回整个字符串。</p>
<blockquote>
<p>注意：出于介绍字符串 slice 的目的，本小节假设只使用 ASCII 字符集；一个关于 UTF-8 处理的更全面的讨论位于第八章<a target="_blank" rel="noopener" href="https://kaisery.github.io/trpl-zh-cn/ch08-02-strings.html#%E4%BD%BF%E7%94%A8%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%82%A8%E5%AD%98-utf-8-%E7%BC%96%E7%A0%81%E7%9A%84%E6%96%87%E6%9C%AC">“使用字符串储存 UTF-8 编码的文本”</a>小节。</p>
</blockquote>
<p>让我们推敲下如何不用 slice 编写这个函数的签名，来理解 slice 能解决的问题：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">first_word</span>(s: &amp;<span class="type">String</span>) <span class="punctuation">-&gt;</span> ?</span><br></pre></td></tr></table></figure>

<p><code>first_word</code> 函数有一个参数 <code>&amp;String</code>。因为我们不需要所有权，所以这没有问题。不过应该返回什么呢？我们并没有一个真正获取<strong>部分</strong>字符串的办法。不过，我们可以返回单词结尾的索引，结尾由一个空格表示。试试如示例 4-7 中的代码。</p>
<p>文件名：src&#x2F;main.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">first_word</span>(s: &amp;<span class="type">String</span>) <span class="punctuation">-&gt;</span> <span class="type">usize</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">bytes</span> = s.<span class="title function_ invoke__">as_bytes</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i, &amp;item) <span class="keyword">in</span> bytes.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">enumerate</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> item == <span class="string">b&#x27; &#x27;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    s.<span class="title function_ invoke__">len</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例 4-7：<code>first_word</code> 函数返回 <code>String</code> 参数的一个字节索引值</p>
<p>因为需要逐个元素的检查 <code>String</code> 中的值是否为空格，需要用 <code>as_bytes</code> 方法将 <code>String</code> 转化为字节数组。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">bytes</span> = s.<span class="title function_ invoke__">as_bytes</span>();</span><br></pre></td></tr></table></figure>

<p>接下来，使用 <code>iter</code> 方法在字节数组上创建一个迭代器：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i, &amp;item) <span class="keyword">in</span> bytes.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">enumerate</span>() &#123;</span><br></pre></td></tr></table></figure>

<p>我们将在<a target="_blank" rel="noopener" href="https://kaisery.github.io/trpl-zh-cn/ch13-02-iterators.html">第十三章</a>详细讨论迭代器。现在，只需知道 <code>iter</code> 方法返回集合中的每一个元素，而 <code>enumerate</code> 包装了 <code>iter</code> 的结果，将这些元素作为元组的一部分来返回。<code>enumerate</code> 返回的元组中，第一个元素是索引，第二个元素是集合中元素的引用。这比我们自己计算索引要方便一些。</p>
<p>因为 <code>enumerate</code> 方法返回一个元组，我们可以使用模式来解构，我们将在<a target="_blank" rel="noopener" href="https://kaisery.github.io/trpl-zh-cn/ch06-02-match.html#%E7%BB%91%E5%AE%9A%E5%80%BC%E7%9A%84%E6%A8%A1%E5%BC%8F">第六章</a>中进一步讨论有关模式的问题。所以在 <code>for</code> 循环中，我们指定了一个模式，其中元组中的 <code>i</code> 是索引而元组中的 <code>&amp;item</code> 是单个字节。因为我们从 <code>.iter().enumerate()</code> 中获取了集合元素的引用，所以模式中使用了 <code>&amp;</code>。</p>
<p>在 <code>for</code> 循环中，我们通过字节的字面值语法来寻找代表空格的字节。如果找到了一个空格，返回它的位置。否则，使用 <code>s.len()</code> 返回字符串的长度。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> item == <span class="string">b&#x27; &#x27;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">s.<span class="title function_ invoke__">len</span>()</span><br></pre></td></tr></table></figure>

<p>现在有了一个找到字符串中第一个单词结尾索引的方法，不过这有一个问题。我们返回了一个独立的 <code>usize</code>，不过它只在 <code>&amp;String</code> 的上下文中才是一个有意义的数字。换句话说，因为它是一个与 <code>String</code> 相分离的值，无法保证将来它仍然有效。考虑一下示例 4-8 中使用了示例 4-7 中 <code>first_word</code> 函数的程序。</p>
<p>文件名：src&#x2F;main.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">word</span> = <span class="title function_ invoke__">first_word</span>(&amp;s); <span class="comment">// word 的值为 5</span></span><br><span class="line"></span><br><span class="line">    s.<span class="title function_ invoke__">clear</span>(); <span class="comment">// 这清空了字符串，使其等于 &quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// word 在此处的值仍然是 5，</span></span><br><span class="line">    <span class="comment">// 但是没有更多的字符串让我们可以有效地应用数值 5。word 的值现在完全无效！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例 4-8：存储 <code>first_word</code> 函数调用的返回值并接着改变 <code>String</code> 的内容</p>
<p>这个程序编译时没有任何错误，而且在调用 <code>s.clear()</code> 之后使用 <code>word</code> 也不会出错。因为 <code>word</code> 与 <code>s</code> 状态完全没有联系，所以 <code>word </code>仍然包含值 <code>5</code>。可以尝试用值 <code>5</code> 来提取变量 <code>s</code> 的第一个单词，不过这是有 bug 的，因为在我们将 <code>5</code> 保存到 <code>word</code> 之后 <code>s</code> 的内容已经改变。</p>
<p>我们不得不时刻担心 <code>word</code> 的索引与 <code>s</code> 中的数据不再同步，这既繁琐又易出错！如果编写这么一个 <code>second_word</code> 函数的话，管理索引这件事将更加容易出问题。它的签名看起来像这样：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">second_word</span>(s: &amp;<span class="type">String</span>) <span class="punctuation">-&gt;</span> (<span class="type">usize</span>, <span class="type">usize</span>) &#123;</span><br></pre></td></tr></table></figure>

<p>现在我们要跟踪一个开始索引<strong>和</strong>一个结束索引，同时有了更多从数据的某个特定状态计算而来的值，但都完全没有与这个状态相关联。现在有三个飘忽不定的不相关变量需要保持同步。</p>
<p>幸运的是，Rust 为这个问题提供了一个解决方法：字符串 slice。</p>
<h3 id="字符串-slice"><a href="#字符串-slice" class="headerlink" title="字符串 slice"></a><a target="_blank" rel="noopener" href="https://kaisery.github.io/trpl-zh-cn/ch04-03-slices.html#%E5%AD%97%E7%AC%A6%E4%B8%B2-slice">字符串 slice</a></h3><p><strong>字符串 slice</strong>（<em>string slice</em>）是 <code>String</code> 中一部分值的引用，它看起来像这样：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">hello</span> = &amp;s[<span class="number">0</span>..<span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">world</span> = &amp;s[<span class="number">6</span>..<span class="number">11</span>];</span><br></pre></td></tr></table></figure>

<p>不同于整个 <code>String</code> 的引用，<code>hello</code> 是一个部分 <code>String</code> 的引用，由一个额外的 <code>[0..5]</code> 部分指定。可以使用一个由中括号中的 <code>[starting_index..ending_index]</code> 指定的 range 创建一个 slice，其中 <code>starting_index</code> 是 slice 的第一个位置，<code>ending_index</code> 则是 slice 最后一个位置的后一个值。在其内部，slice 的数据结构存储了 slice 的开始位置和长度，长度对应于 <code>ending_index</code> 减去 <code>starting_index</code> 的值。所以对于 <code>let world = &amp;s[6..11];</code> 的情况，<code>world</code> 将是一个包含指向 <code>s</code> 索引 6 的指针和长度值 5 的 slice。</p>
<p>图 4-7 展示了一个图例。</p>
<p><img data-src="https://kaisery.github.io/trpl-zh-cn/img/trpl04-07.svg" alt="Three tables: a table representing the stack data of s, which points to the byte at index 0 in a table of the string data &quot;hello world&quot; on the heap. The third table rep-resents the stack data of the slice world, which has a length value of 5 and points to byte 6 of the heap data table."></p>
<p>图 4-7：引用了部分 <code>String</code> 的字符串 slice</p>
<p>对于 Rust 的 <code>..</code> range 语法，如果想要从索引 0 开始，可以不写两个点号之前的值。换句话说，如下两个语句是相同的：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">slice</span> = &amp;s[<span class="number">0</span>..<span class="number">2</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">slice</span> = &amp;s[..<span class="number">2</span>];</span><br></pre></td></tr></table></figure>

<p>依此类推，如果 slice 包含 <code>String</code> 的最后一个字节，也可以舍弃尾部的数字。这意味着如下也是相同的：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">len</span> = s.<span class="title function_ invoke__">len</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">slice</span> = &amp;s[<span class="number">3</span>..len];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">slice</span> = &amp;s[<span class="number">3</span>..];</span><br></pre></td></tr></table></figure>

<p>也可以同时舍弃这两个值来获取整个字符串的 slice。所以如下亦是相同的：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">len</span> = s.<span class="title function_ invoke__">len</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">slice</span> = &amp;s[<span class="number">0</span>..len];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">slice</span> = &amp;s[..];</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：字符串 slice range 的索引必须位于有效的 UTF-8 字符边界内，如果尝试从一个多字节字符的中间位置创建字符串 slice，则程序将会因错误而退出。</p>
</blockquote>
<p>在记住所有这些知识后，让我们重写 <code>first_word</code> 来返回一个 slice。“字符串 slice” 的类型声明写作 <code>&amp;str</code>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">first_word</span>(s: &amp;<span class="type">String</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">str</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">bytes</span> = s.<span class="title function_ invoke__">as_bytes</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i, &amp;item) <span class="keyword">in</span> bytes.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">enumerate</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> item == <span class="string">b&#x27; &#x27;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> &amp;s[<span class="number">0</span>..i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &amp;s[..]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们使用跟示例 4-7 相同的方式获取单词结尾的索引，通过寻找第一个出现的空格。当找到一个空格，我们返回一个字符串 slice，它使用字符串的开始和空格的索引作为开始和结束的索引。</p>
<p>现在当调用 <code>first_word</code> 时，会返回与底层数据关联的单个值。这个值由一个 slice 开始位置的引用和 slice 中元素的数量组成。</p>
<p><code>second_word</code> 函数也可以改为返回一个 slice：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">second_word</span>(s: &amp;<span class="type">String</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">str</span> &#123;</span><br></pre></td></tr></table></figure>

<p>现在我们有了一个不易混淆且直观的 API 了，因为编译器会确保指向 <code>String</code> 的引用持续有效。还记得示例 4-8 程序中，那个当我们获取第一个单词结尾的索引后，接着就清除了字符串导致索引就无效的 bug 吗？那些代码在逻辑上是不正确的，但却没有显示任何直接的错误。问题会在之后尝试对空字符串使用第一个单词的索引时出现。slice 就不可能出现这种 bug 并让我们更早的知道出问题了。使用 slice 版本的 <code>first_word</code> 会抛出一个编译时错误：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">word</span> = <span class="title function_ invoke__">first_word</span>(&amp;s);</span><br><span class="line"></span><br><span class="line">    s.<span class="title function_ invoke__">clear</span>(); <span class="comment">// 错误！</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;the first word is: &#123;word&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里是编译错误：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cargo run</span></span><br><span class="line">   Compiling ownership v0.1.0 (file:///projects/ownership)</span><br><span class="line">error[E0502]: cannot borrow `s` as mutable because it is also borrowed as immutable</span><br><span class="line"><span class="meta prompt_">  --&gt; </span><span class="language-bash">src/main.rs:18:5</span></span><br><span class="line">   |</span><br><span class="line">16 |     let word = first_word(&amp;s);</span><br><span class="line">   |                           -- immutable borrow occurs here</span><br><span class="line">17 |</span><br><span class="line">18 |     s.clear(); // error!</span><br><span class="line">   |     ^^^^^^^^^ mutable borrow occurs here</span><br><span class="line">19 |</span><br><span class="line">20 |     println!(&quot;the first word is: &#123;word&#125;&quot;);</span><br><span class="line">   |                                  ------ immutable borrow later used here</span><br><span class="line"></span><br><span class="line">For more information about this error, try `rustc --explain E0502`.</span><br><span class="line">error: could not compile `ownership` (bin &quot;ownership&quot;) due to 1 previous error</span><br></pre></td></tr></table></figure>

<p>回忆一下借用规则，当拥有某值的不可变引用时，就不能再获取一个可变引用。因为 <code>clear</code> 需要清空 <code>String</code>，它尝试获取一个可变引用。在调用 <code>clear</code> 之后的 <code>println!</code> 使用了 <code>word</code> 中的引用，所以这个不可变的引用在此时必须仍然有效。Rust 不允许 <code>clear</code> 中的可变引用和 <code>word</code> 中的不可变引用同时存在，因此编译失败。Rust 不仅使得我们的 API 简单易用，也在编译时就消除了一整类的错误！</p>
<h4 id="字符串字面值就是-slice"><a href="#字符串字面值就是-slice" class="headerlink" title="字符串字面值就是 slice"></a><a target="_blank" rel="noopener" href="https://kaisery.github.io/trpl-zh-cn/ch04-03-slices.html#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AD%97%E9%9D%A2%E5%80%BC%E5%B0%B1%E6%98%AF-slice">字符串字面值就是 slice</a></h4><p>还记得我们讲到过字符串字面值被储存在二进制文件中吗？现在知道 slice 了，我们就可以正确地理解字符串字面值了：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="string">&quot;Hello, world!&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>这里 <code>s</code> 的类型是 <code>&amp;str</code>：它是一个指向二进制程序特定位置的 slice。这也就是为什么字符串字面值是不可变的；<code>&amp;str</code> 是一个不可变引用。</p>
<h4 id="字符串-slice-作为参数"><a href="#字符串-slice-作为参数" class="headerlink" title="字符串 slice 作为参数"></a><a target="_blank" rel="noopener" href="https://kaisery.github.io/trpl-zh-cn/ch04-03-slices.html#%E5%AD%97%E7%AC%A6%E4%B8%B2-slice-%E4%BD%9C%E4%B8%BA%E5%8F%82%E6%95%B0">字符串 slice 作为参数</a></h4><p>在知道了能够获取字面值和 <code>String</code> 的 slice 后，我们对 <code>first_word</code> 做了改进，这是它的签名：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">first_word</span>(s: &amp;<span class="type">String</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">str</span> &#123;</span><br></pre></td></tr></table></figure>

<p>而更有经验的 Rustacean 会编写出示例 4-9 中的签名，因为它使得可以对 <code>&amp;String</code> 值和 <code>&amp;str</code> 值使用相同的函数：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">first_word</span>(s: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">str</span> &#123;</span><br></pre></td></tr></table></figure>

<p>示例 4-9: 通过将 <code>s</code> 参数的类型改为字符串 slice 来改进 <code>first_word</code> 函数</p>
<p>如果有一个字符串 slice，可以直接传递它。如果有一个 <code>String</code>，则可以传递整个 <code>String</code> 的 slice 或对 <code>String</code> 的引用。这种灵活性利用了 <em>deref coercions</em> 的优势，这个特性我们将在<a target="_blank" rel="noopener" href="https://kaisery.github.io/trpl-zh-cn/ch15-02-deref.html#%E5%87%BD%E6%95%B0%E5%92%8C%E6%96%B9%E6%B3%95%E7%9A%84%E9%9A%90%E5%BC%8F-deref-%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2">“函数和方法的隐式 Deref 强制转换”</a>章节中介绍。定义一个获取字符串 slice 而不是 <code>String</code> 引用的函数使得我们的 API 更加通用并且不会丢失任何功能：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">my_string</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// `first_word` 适用于 `String`（的 slice），部分或全部</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">word</span> = <span class="title function_ invoke__">first_word</span>(&amp;my_string[<span class="number">0</span>..<span class="number">6</span>]);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">word</span> = <span class="title function_ invoke__">first_word</span>(&amp;my_string[..]);</span><br><span class="line">    <span class="comment">// `first_word` 也适用于 `String` 的引用，</span></span><br><span class="line">    <span class="comment">// 这等价于整个 `String` 的 slice</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">word</span> = <span class="title function_ invoke__">first_word</span>(&amp;my_string);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">my_string_literal</span> = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// `first_word` 适用于字符串字面值，部分或全部</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">word</span> = <span class="title function_ invoke__">first_word</span>(&amp;my_string_literal[<span class="number">0</span>..<span class="number">6</span>]);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">word</span> = <span class="title function_ invoke__">first_word</span>(&amp;my_string_literal[..]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 因为字符串字面值已经 **是** 字符串 slice 了，</span></span><br><span class="line">    <span class="comment">// 这也是适用的，无需 slice 语法！</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">word</span> = <span class="title function_ invoke__">first_word</span>(my_string_literal);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="其他类型的-slice"><a href="#其他类型的-slice" class="headerlink" title="其他类型的 slice"></a><a target="_blank" rel="noopener" href="https://kaisery.github.io/trpl-zh-cn/ch04-03-slices.html#%E5%85%B6%E4%BB%96%E7%B1%BB%E5%9E%8B%E7%9A%84-slice">其他类型的 slice</a></h3><p>字符串 slice，正如你想象的那样，是针对字符串的。不过也有更通用的 slice 类型。考虑一下这个数组：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">a</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br></pre></td></tr></table></figure>

<p>就跟我们想要获取字符串的一部分那样，我们也会想要引用数组的一部分。我们可以这样做：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">a</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">slice</span> = &amp;a[<span class="number">1</span>..<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">assert_eq!</span>(slice, &amp;[<span class="number">2</span>, <span class="number">3</span>]);</span><br></pre></td></tr></table></figure>

<p>这个 slice 的类型是 <code>&amp;[i32]</code>。它跟字符串 slice 的工作方式一样，通过存储第一个集合元素的引用和一个集合总长度。你可以对其他所有集合使用这类 slice。第八章讲到 vector 时会详细讨论这些集合。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/07/17/RUST%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.png">
      <meta itemprop="name" content="Chillward">
      <meta itemprop="description" content="谁躺在漆黑的舞台上，用身体迎接着光芒">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chillward的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/07/17/RUST%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/" class="post-title-link" itemprop="url">RUST学习日记之数据类型</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-07-17 23:17:40" itemprop="dateCreated datePublished" datetime="2025-07-17T23:17:40+08:00">2025-07-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-07-20 15:56:32" itemprop="dateModified" datetime="2025-07-20T15:56:32+08:00">2025-07-20</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>12k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>23 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="变量的声明"><a href="#变量的声明" class="headerlink" title="变量的声明"></a>变量的声明</h3><p>rust的变量分为可变变量与不可变变量，声明变量使用<strong>let</strong>关键字，类型可以不显式声明，可变变量用<strong>mut</strong>关键字。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">x</span>:<span class="type">i32</span> = <span class="number">42</span>; <span class="comment">//显式告知编译器变量类型</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">guess</span> = <span class="number">42</span>; <span class="comment">// 编译器推断 guess 是 i32 类型</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">pi</span> = <span class="number">3.14</span>;   <span class="comment">// 编译器推断 pi 是 f64 类型</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">active</span> = <span class="literal">true</span>; <span class="comment">// 编译器推断 active 是 bool 类型</span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">y</span> = <span class="number">10</span>; <span class="comment">// 声明一个可变变量 y 并赋值为 10</span></span><br></pre></td></tr></table></figure>

<h3 id="变量的遮蔽"><a href="#变量的遮蔽" class="headerlink" title="变量的遮蔽"></a>变量的遮蔽</h3><p>在 Rust 中，<strong>变量遮蔽</strong>指的是你可以声明一个与之前变量同名的新变量。这个新变量会“遮盖”（或“隐藏”）之前声明的同名变量，使得在当前作用域内，对这个名字的引用会指向新的变量，而不是旧的。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>; <span class="comment">// 第一次声明 x</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The initial value of x is: &#123;&#125;&quot;</span>, x); <span class="comment">// 输出 5</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = x + <span class="number">1</span>; <span class="comment">// 第二次声明 x，它遮蔽了之前的 x</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The new value of x is: &#123;&#125;&quot;</span>, x);     <span class="comment">// 输出 6</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = x * <span class="number">2</span>; <span class="comment">// 第三次声明 x，再次遮蔽</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The final value of x is: &#123;&#125;&quot;</span>, x);   <span class="comment">// 输出 12</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>乍一看，变量遮蔽可能与使用 <code>mut</code> 关键字的可变变量（Mutable Variables）有些相似，但它们之间存在根本的区别：</p>
<ol>
<li><p><strong>内存位置</strong>：</p>
<ul>
<li><strong>可变变量 (<code>let mut</code>)</strong>：修改的是<strong>同一个内存位置</strong>的值。当你说 <code>let mut x = 5; x = 6;</code> 时，<code>x</code> 的值从 5 变成了 6，存储 <code>x</code> 的那块内存区域中的内容发生了变化。</li>
<li><strong>变量遮蔽 (<code>let</code>)</strong>：是<strong>创建了一个全新的变量</strong>。每次你使用 <code>let</code> 关键字并带上一个已有的变量名时，Rust 实际上是在内存中分配了一个新的空间来存储新变量的值，而不是修改旧变量的值。旧变量可能仍然存在于内存中，只是你无法通过它的名字访问它了。</li>
</ul>
</li>
<li><p><strong>类型改变</strong>：</p>
<ul>
<li><strong>可变变量 (<code>let mut</code>)</strong>：不能改变变量的类型。如果 <code>x</code> 最初是 <code>i32</code>，那么它永远是 <code>i32</code>。</li>
<li><strong>变量遮蔽 (<code>let</code>)</strong>：可以改变变量的类型。这是遮蔽的一个强大之处，也是它与可变变量最明显的区别之一。</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">spaces</span> = <span class="string">&quot;   &quot;</span>; <span class="comment">// spaces 是一个 &amp;str 类型</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Type of spaces (string): &#123;:?&#125;&quot;</span>, spaces);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">spaces</span> = spaces.<span class="title function_ invoke__">len</span>(); <span class="comment">// 新的 spaces 是一个 usize 类型，旧的 &amp;str 被遮蔽了</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Type of spaces (number): &#123;:?&#125;&quot;</span>, spaces);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>变量遮蔽在 Rust 中被视为一个有用的特性，主要有以下几个原因：</p>
<ol>
<li><strong>类型转换或数据转换</strong>：当你需要对一个变量进行转换操作（例如从字符串解析数字，或者进行某种计算），并希望用同一个有意义的变量名来表示转换后的结果时，遮蔽非常方便。这样可以避免创建 <code>x_str</code>、<code>x_int</code> 这样一系列冗余的变量名。</li>
<li><strong>避免意外修改</strong>：因为遮蔽是创建新变量，而不是修改旧变量，所以它强制你重新使用 <code>let</code> 关键字。这有助于避免无意中修改了某个远处的变量，因为你需要明确地重新声明它。</li>
<li><strong>提高可读性</strong>：在某些情况下，使用相同的变量名可以使代码更具可读性，因为它清楚地表明你正在处理同一个逻辑概念的不同“阶段”或“表示”。</li>
</ol>
<p>变量遮蔽只在当前作用域内有效。当代码块结束时，被遮蔽的变量（如果它仍然在作用域内）可能会重新变得可见，或者新的遮蔽变量会消失。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>); <span class="comment">// s1</span></span><br><span class="line"></span><br><span class="line">    &#123; <span class="comment">// 这是一个新的内部作用域</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;world&quot;</span>); <span class="comment">// s2，遮蔽了外部的 s1</span></span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Inside inner scope: &#123;&#125;&quot;</span>, s); <span class="comment">// 输出 &quot;world&quot;</span></span><br><span class="line">    &#125; <span class="comment">// 内部作用域结束，s2 被丢弃</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Outside inner scope: &#123;&#125;&quot;</span>, s); <span class="comment">// 输出 &quot;hello&quot; (s1 重新可见)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h1><p>rust中基本数据类型包括以下几种</p>
<ol>
<li>整形(u32、i32)</li>
<li>浮点型(f32,f64)</li>
<li>布尔型(bool)</li>
<li>字符型(char)</li>
</ol>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span>:<span class="type">i32</span> = <span class="number">42</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span>:<span class="type">u64</span> = <span class="number">200</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">pi</span>:<span class="type">f64</span> = <span class="number">3.14159</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">is_snowing</span>: <span class="type">bool</span> = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>跟C语言没什么大区别，就不详细说了</p>
<hr>
<h1 id="复合数据类型"><a href="#复合数据类型" class="headerlink" title="复合数据类型"></a>复合数据类型</h1><p><strong>复合类型</strong>（<em>Compound types</em>）可以将多个值组合成一个类型。Rust 有两个原生的复合类型：元组（tuple）和数组（array）。</p>
<h4 id="元组-tuple"><a href="#元组-tuple" class="headerlink" title="元组(tuple):"></a>元组(tuple):</h4><p>元组是一个将多个不同类型的值组合进一个复合类型的主要方式。元组长度固定：一旦声明，其长度不会增大或缩小。</p>
<p>我们使用包含在圆括号中的逗号分隔的值列表来创建一个元组。元组中的每一个位置都有一个类型，而且这些不同值的类型也不必是相同的。这个例子中使用了<strong>可选</strong>的类型注解：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">tup</span>: (<span class="type">i32</span>, <span class="type">f64</span>, <span class="type">u8</span>) = (<span class="number">500</span>, <span class="number">6.4</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>tup</code> 变量绑定到整个元组上，因为元组是一个单独的复合元素。为了从元组中获取单个值，可以使用模式匹配（pattern matching）来解构（destructure）元组值，像这样：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">tup</span> = (<span class="number">500</span>, <span class="number">6.4</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> (x, y, z) = tup;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The value of y is: &#123;y&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序首先创建了一个元组并绑定到 <code>tup</code> 变量上。接着使用了 <code>let</code> 和一个模式将 <code>tup</code> 分成了三个不同的变量，<code>x</code>、<code>y</code> 和 <code>z</code>。这叫做 <strong>解构</strong>（<em>destructuring</em>），因为它将一个元组拆成了三个部分。最后，程序打印出了 <code>y</code> 的值，也就是 <code>6.4</code>。</p>
<p>我们也可以使用点号（<code>.</code>）后跟值的索引来直接访问所需的元组元素。例如：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span>: (<span class="type">i32</span>, <span class="type">f64</span>, <span class="type">u8</span>) = (<span class="number">500</span>, <span class="number">6.4</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">five_hundred</span> = x.<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">six_point_four</span> = x.<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">one</span> = x.<span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个程序创建了一个元组，<code>x</code>，然后使用其各自的索引访问元组中的每个元素。跟大多数编程语言一样，元组的第一个索引值是 0。</p>
<p>不带任何值的元组有个特殊的名称，叫做 <strong>单元（unit）</strong> 元组。这种值以及对应的类型都写作 <code>()</code>，表示空值或空的返回类型。如果表达式不返回任何其他值，则会隐式返回单元值。</p>
<h4 id="数组-array"><a href="#数组-array" class="headerlink" title="数组(array):"></a>数组(array):</h4><p>另一个包含多个值的方式是 <strong>数组</strong>（<em>array</em>）。与元组不同，数组中的每个元素的类型必须相同。Rust 中的数组与一些其他语言中的数组不同，Rust 中的数组长度是固定的。</p>
<p>我们将数组的值写成在方括号内，用逗号分隔的列表：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">numbers</span>:[<span class="type">i32</span>;<span class="number">5</span>] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当你想要在栈（stack）而不是在堆（heap）上为数据分配空间，或者是想要确保总是有固定数量的元素时，数组非常有用。但是数组并不如 vector 类型灵活。vector 类型是标准库提供的一个 <strong>允许</strong> 增长和缩小长度的类似数组的集合类型。当不确定是应该使用数组还是 vector 的时候，那么很可能应该使用 vector。</p>
<p>然而，当你确定元素个数不会改变时，数组会更有用。例如，当你在一个程序中使用月份名字时，你更应趋向于使用数组而不是 vector，因为你确定只会有 12 个元素。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">months</span> = [<span class="string">&quot;January&quot;</span>, <span class="string">&quot;February&quot;</span>, <span class="string">&quot;March&quot;</span>, <span class="string">&quot;April&quot;</span>, <span class="string">&quot;May&quot;</span>, <span class="string">&quot;June&quot;</span>, <span class="string">&quot;July&quot;</span>,</span><br><span class="line">              <span class="string">&quot;August&quot;</span>, <span class="string">&quot;September&quot;</span>, <span class="string">&quot;October&quot;</span>, <span class="string">&quot;November&quot;</span>, <span class="string">&quot;December&quot;</span>];</span><br></pre></td></tr></table></figure>

<p>可以像这样编写数组的类型：在方括号中包含每个元素的类型，后跟分号，再后跟数组元素的数量。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">a</span>: [<span class="type">i32</span>; <span class="number">5</span>] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br></pre></td></tr></table></figure>

<p>这里，<code>i32</code> 是每个元素的类型。分号之后，数字 <code>5</code> 表明该数组包含五个元素。</p>
<p>你还可以通过在方括号中指定初始值加分号再加元素个数的方式来创建一个每个元素都为相同值的数组：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">a</span> = [<span class="number">3</span>; <span class="number">5</span>];</span><br></pre></td></tr></table></figure>

<p>变量名为 <code>a</code> 的数组将包含 <code>5</code> 个元素，这些元素的值最初都将被设置为 <code>3</code>。这种写法与 <code>let a = [3, 3, 3, 3, 3];</code> 效果相同，但更简洁。</p>
<p>数组是可以在栈 (stack) 上分配的已知固定大小的单个内存块。可以使用索引来访问数组的元素，像这样：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">first</span> = a[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">second</span> = a[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，叫做 <code>first</code> 的变量的值是 <code>1</code>，因为它是数组索引 <code>[0]</code> 的值。变量 <code>second</code> 将会是数组索引 <code>[1]</code> 的值 <code>2</code>。</p>
<hr>
<h3 id="引用类型与切片-slices"><a href="#引用类型与切片-slices" class="headerlink" title="引用类型与切片(slices)"></a>引用类型与切片(slices)</h3><p>引用类型分为可变引用以及不可变引用。</p>
<p>可变引用可以理解为一种更加安全的指针。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>); <span class="comment">// 原始变量必须是可变的</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// s 的可变引用被传递给 change 函数</span></span><br><span class="line">    <span class="title function_ invoke__">change</span>(&amp;<span class="keyword">mut</span> s);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, s); <span class="comment">// 输出 &quot;hello, world&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个函数接收一个 String 的可变引用</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">change</span>(some_string: &amp;<span class="keyword">mut</span> <span class="type">String</span>) &#123;</span><br><span class="line">    some_string.<span class="title function_ invoke__">push_str</span>(<span class="string">&quot;, world&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>不可变引用可以理解为类似于C语言中<code>const int *</code> 的类型，可以通过指针访问引用的值，但是不能修改。注意引用的对象是可以发生改变的</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span> = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">r</span> = &amp;a; <span class="comment">// r 引用 a</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;r points to a: &#123;&#125;&quot;</span>, r); <span class="comment">// 输出 10</span></span><br><span class="line"></span><br><span class="line">    r = &amp;b; <span class="comment">// 重新绑定 r，让它引用 b</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;r now points to b: &#123;&#125;&quot;</span>, r); <span class="comment">// 输出 20</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Rust 的<strong>借用检查器（borrow checker）</strong> 是一个在编译时运行的工具，它会严格执行以下引用规则，确保内存安全：</p>
<ol>
<li><strong>没有空引用：</strong> Rust 的引用保证总是指向有效的数据。你无法创建空引用，这避免了其他语言中常见的空指针解引用错误。</li>
<li><strong>没有悬垂引用：</strong> 引用指向的数据在其生命周期内必须始终有效。借用检查器会确保你不会引用一块已经被释放的内存。</li>
<li><strong>读写互斥规则：</strong> 这是最关键的规则，它防止了数据竞争（data races）：<ul>
<li>在任何给定时间，你只能拥有<strong>一个可变引用</strong> (<code>&amp;mut T</code>)。这意味着当数据被修改时，不能有其他任何引用（无论是可变还是不可变）指向它。</li>
<li>你可以拥有<strong>任意数量的不可变引用</strong> (<code>&amp;T</code>)。这意味着数据可以被多次同时读取。</li>
<li>但是，当存在不可变引用时，就不能有任何可变引用。</li>
</ul>
</li>
</ol>
<p><strong>切片</strong>是 Rust 中一种特殊的引用类型，它允许你引用集合（如数组、<code>Vec</code> 或 <code>String</code>）中<strong>连续、特定范围的元素序列</strong>。切片本身也是一种引用，不拥有数据。可以类比为指向数组的更安全的指针。</p>
<ul>
<li><p><strong>泛型切片</strong> (<code>&amp;[T]</code>)：用于引用数组或 <code>Vec</code> 的部分或全部。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">numbers</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">middle</span> = &amp;numbers[<span class="number">1</span>..<span class="number">4</span>]; <span class="comment">// middle 是 &amp;[i32]，引用 [2, 3, 4]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>字符串切片</strong> (<code>&amp;str</code>)：用于引用 <code>String</code> 的部分或全部，或直接表示字符串字面量。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">word</span> = &amp;s[<span class="number">0</span>..<span class="number">5</span>]; <span class="comment">// word 是 &amp;str，引用 &quot;hello&quot;</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">literal</span> = <span class="string">&quot;Rust is great&quot;</span>; <span class="comment">// 字符串字面量本身就是 &amp;str</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h1 id="String与String-slices"><a href="#String与String-slices" class="headerlink" title="String与String slices"></a>String与String slices</h1><p>在rust中 String是一个结构体，是封装好的可进行修改的字符串。</p>
<p>String slices是字符串切片，无法修改，即不可变引用。</p>
<p><code>&amp;mut String</code> 和字符串切片 (<code>&amp;str</code>) 之间存在一种非常重要的关系，但它们是两个截然不同且用途互补的概念。</p>
<h2 id="1-mut-String：可变且拥有数据的引用"><a href="#1-mut-String：可变且拥有数据的引用" class="headerlink" title="1. &amp;mut String：可变且拥有数据的引用"></a>1. <code>&amp;mut String</code>：可变且拥有数据的引用</h2><p><code>&amp;mut String</code> 是对一个 <strong><code>String</code> 类型变量的可变引用</strong>。</p>
<ul>
<li><strong>所有权和可变性：</strong><ul>
<li><code>String</code> 类型本身是<strong>拥有数据</strong>的，并且其内容是<strong>可变</strong>的（存储在堆上，可以增长、收缩和修改）。</li>
<li><code>&amp;mut String</code> 允许你通过这个引用来<strong>修改原始的 <code>String</code> 数据</strong>。</li>
</ul>
</li>
<li><strong>用途：</strong> 当你需要在函数内部改变一个 <code>String</code> 变量的内容，但又不希望函数获取这个 <code>String</code> 的所有权时，你会传递 <code>&amp;mut String</code>。</li>
<li><strong>独占性：</strong> 遵循 Rust 的借用规则，当一个 <code>&amp;mut String</code> 存在时，不能有其他任何引用（无论是 <code>&amp;mut String</code> 还是 <code>&amp;String</code>）指向同一个 <code>String</code> 实例。这保证了数据在修改时的唯一访问，从而防止了数据竞争。</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">modify_my_string</span>(s: &amp;<span class="keyword">mut</span> <span class="type">String</span>) &#123;</span><br><span class="line">    s.<span class="title function_ invoke__">push_str</span>(<span class="string">&quot; world!&quot;</span>); <span class="comment">// 通过可变引用修改原始 String</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">my_string</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"><span class="title function_ invoke__">modify_my_string</span>(&amp;<span class="keyword">mut</span> my_string); <span class="comment">// 传递可变引用</span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, my_string); <span class="comment">// Output: Hello world!</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="2-字符串切片-str-：不可变且不拥有数据的引用"><a href="#2-字符串切片-str-：不可变且不拥有数据的引用" class="headerlink" title="2. 字符串切片 (&amp;str)：不可变且不拥有数据的引用"></a>2. 字符串切片 (<code>&amp;str</code>)：不可变且不拥有数据的引用</h2><p><code>&amp;str</code>（字符串切片）是对一个 <strong>UTF-8 编码的字符串数据段的不可变引用</strong>。</p>
<ul>
<li><strong>所有权和不可变性：</strong><ul>
<li><code>&amp;str</code> <strong>不拥有数据</strong>；它只是“借用”了另一段内存中的字符串数据。</li>
<li><code>&amp;str</code> 自身是<strong>不可变</strong>的。你不能通过 <code>&amp;str</code> 来修改它所引用的字符串内容。</li>
</ul>
</li>
<li><strong>来源：</strong> <code>&amp;str</code> 可以来自多种地方：<ul>
<li>字符串字面量（<code>&quot;hello&quot;</code>）本身就是 <code>&amp;&#39;static str</code> 类型。</li>
<li><code>String</code> 类型可以通过 <code>&amp;my_string[..]</code> 或 <code>&amp;my_string</code> 自动强制转换（deref coercion）为 <code>&amp;str</code>。</li>
</ul>
</li>
<li><strong>用途：</strong> 当你只需要读取字符串内容，或函数需要接受任何形式的字符串（无论是 <code>String</code> 还是字符串字面量）作为参数时，通常会使用 <code>&amp;str</code>。</li>
<li><strong>共享性：</strong> 由于是不可变的，你可以创建多个 <code>&amp;str</code> 引用指向同一段数据。</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">print_my_string</span>(s: &amp;<span class="type">str</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, s); <span class="comment">// 只能读取，不能修改</span></span><br><span class="line">    <span class="comment">// s.push_str(&quot;!&quot;); // 错误！&amp;str 是不可变的</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">my_string</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Rust&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">literal_string</span>: &amp;<span class="type">str</span> = <span class="string">&quot;Programming&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">print_my_string</span>(&amp;my_string);       <span class="comment">// 将 String 借用为 &amp;str</span></span><br><span class="line"><span class="title function_ invoke__">print_my_string</span>(literal_string);   <span class="comment">// 直接使用字符串字面量</span></span><br><span class="line"><span class="title function_ invoke__">print_my_string</span>(&amp;my_string[<span class="number">0</span>..<span class="number">2</span>]); <span class="comment">// 借用 String 的一部分作为 &amp;str</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="它们之间的关系和区别总结"><a href="#它们之间的关系和区别总结" class="headerlink" title="它们之间的关系和区别总结"></a>它们之间的关系和区别总结</h2><table>
<thead>
<tr>
<th>特性</th>
<th><code>&amp;mut String</code></th>
<th><code>&amp;str</code></th>
</tr>
</thead>
<tbody><tr>
<td><strong>所有权</strong></td>
<td>不拥有数据，是对 <strong><code>String</code></strong> 的<strong>借用</strong></td>
<td>不拥有数据，是对 <strong>UTF-8 字符串数据</strong> 的<strong>借用</strong></td>
</tr>
<tr>
<td><strong>可变性</strong></td>
<td><strong>可变</strong>：允许通过引用修改原始 <code>String</code> 的内容</td>
<td><strong>不可变</strong>：不允许通过引用修改所引用的字符串内容</td>
</tr>
<tr>
<td><strong>指向目标</strong></td>
<td>总是指向一个完整的 <code>String</code> 实例</td>
<td>可以指向 <code>String</code> 的一部分，也可以是整个 <code>String</code>，或者是字符串字面量</td>
</tr>
<tr>
<td><strong>独占性</strong></td>
<td><strong>独占</strong>：同一时间只能有一个 <code>&amp;mut String</code> 存在</td>
<td><strong>共享</strong>：可以同时存在多个 <code>&amp;str</code> 引用</td>
</tr>
<tr>
<td><strong>用途</strong></td>
<td>需要在函数中修改 <code>String</code> 的场景</td>
<td>需要读取字符串数据，或作为通用字符串参数的场景</td>
</tr>
</tbody></table>
<hr>
<p>简而言之：</p>
<ul>
<li><code>&amp;mut String</code> 是你想要<strong>修改</strong>一个<strong>堆上可变字符串</strong>时用的。它就像给函数一个“写权限”去操作原始的 <code>String</code>。</li>
<li><code>&amp;str</code> 是你想要<strong>读取</strong>一个**字符串（无论来自哪里）**时用的。它就像给函数一个“只读视图”。</li>
</ul>
<p><code>&amp;str</code> 是更通用的字符串视图类型，因为它既可以引用 <code>String</code> 的内容，也可以引用字符串字面量。而 <code>&amp;mut String</code> 明确表示你正在操作一个底层的 <code>String</code> 对象，并且你有权修改它。</p>
<hr>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">book_slices</span>:&amp;[&amp;<span class="type">String</span>] = &amp;[&amp;<span class="string">&quot;JVAV&quot;</span>.<span class="title function_ invoke__">to_string</span>(),&amp;<span class="string">&quot;IT&quot;</span>.<span class="title function_ invoke__">to_string</span>(),&amp;<span class="string">&quot;ZEN&quot;</span>.<span class="title function_ invoke__">to_string</span>()];</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;Book_Slices:&#123;:?&#125;&quot;</span>,book_slices);</span><br><span class="line"></span><br><span class="line"><span class="comment">//String Vs String Slices(&amp;str)</span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">stone_cold</span>:<span class="type">String</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hell,&quot;</span>);</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;Stone Cold Says:&#123;&#125;&quot;</span>,stone_cold);</span><br><span class="line">stone_cold.<span class="title function_ invoke__">push_str</span>(<span class="string">&quot;Yeah!&quot;</span>);</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;Stone Cold Says:&#123;&#125;&quot;</span>,stone_cold);</span><br><span class="line"></span><br><span class="line"><span class="comment">//B- &amp;str(String Slice)</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">string</span>: <span class="type">String</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello,World&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">slice</span>: &amp;<span class="type">str</span> = &amp;string[<span class="number">0</span>..<span class="number">5</span>];</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;Slice Value:&#123;&#125;&quot;</span>,slice);</span><br></pre></td></tr></table></figure>

<p><code>let book_slices:&amp;[&amp;String] = &amp;[&amp;&quot;JVAV&quot;.to_string(),&amp;&quot;IT&quot;.to_string(),&amp;&quot;ZEN&quot;.to_string()];</code></p>
<p>是一个是一个指向 <code>&amp;String</code> 类型数组的切片</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">book_slices</span>: &amp;[&amp;<span class="type">String</span>] = &amp;[&amp;<span class="string">&quot;JVAV&quot;</span>.<span class="title function_ invoke__">to_string</span>(),&amp;<span class="string">&quot;IT&quot;</span>.<span class="title function_ invoke__">to_string</span>(),&amp;<span class="string">&quot;ZEN&quot;</span>.<span class="title function_ invoke__">to_string</span>()];</span><br></pre></td></tr></table></figure>

<ol>
<li><strong><code>&quot;JVAV&quot;.to_string()</code></strong><ul>
<li>这一步创建了一个<strong>拥有所有权</strong>的 <strong><code>String</code></strong> 类型实例，存储在堆上。</li>
</ul>
</li>
<li><strong><code>&amp;&quot;JVAV&quot;.to_string()</code></strong><ul>
<li>这一步从上面创建的 <code>String</code> 实例中，获取了一个<strong>不可变引用</strong>。这个引用的类型是 <strong><code>&amp;String</code></strong>。</li>
</ul>
</li>
<li><strong><code>[&amp; ... , &amp; ... , &amp; ...]</code></strong><ul>
<li>这是一个<strong>数组字面量</strong>，它在编译时被创建。这个数组的元素类型，就是它里面包含的那些引用的类型，即 <strong><code>&amp;String</code></strong>。所以，这是一个 <code>[&amp;String; 3]</code> 类型的数组。</li>
</ul>
</li>
<li><strong><code>&amp;[&amp;String; 3]</code></strong><ul>
<li>最外层的 <code>&amp;</code> 运算符，是获取这个<strong>数组的引用</strong>。</li>
<li>这个引用（<code>&amp;</code> 后面的部分）的类型就是 <code>[&amp;String; 3]</code>。</li>
</ul>
</li>
<li><strong><code>let book_slices: &amp;[&amp;String]</code></strong><ul>
<li>最后，<code>book_slices</code> 被明确地类型标注为 <strong><code>&amp;[&amp;String]</code></strong>。这是一个<strong>切片</strong>，它指向的底层数组的元素类型是 <code>&amp;String</code>。</li>
</ul>
</li>
</ol>
<hr>
<h2 id="关键点：没有发生-Deref-Coercion"><a href="#关键点：没有发生-Deref-Coercion" class="headerlink" title="关键点：没有发生 Deref Coercion"></a>关键点：没有发生 Deref Coercion</h2><p>虽然 Rust 有 <strong>Deref Coercion（解引用强制转换）</strong> 的机制，允许 <code>&amp;String</code> 在需要 <code>&amp;str</code> 的地方自动转换。但是，这种转换发生在<strong>单个引用层面</strong>，而不会改变<strong>数组或切片中元素的实际类型</strong>。</p>
<p>在这个特定的例子中：</p>
<ul>
<li>你明确地构建了一个包含 <code>&amp;String</code> 引用的数组：<code>[&amp;some_string_ref_1, &amp;some_string_ref_2]</code>。</li>
<li>这个数组的类型就是 <code>[&amp;String; N]</code>。</li>
<li>你从这个数组创建的切片，其类型也必须与其元素的实际类型匹配，即 <code>&amp;[&amp;String]</code>。</li>
</ul>
<p>如果 Rust 允许 <code>&amp;[&amp;String]</code> 自动强制转换为 <code>&amp;[&amp;str]</code>，那将意味着它需要修改切片中<strong>每个元素的类型</strong>，这是 Deref Coercion 不会做的事情。Deref Coercion 是一个<strong>单个引用到单个引用</strong>的转换，而不是一个集合到另一个集合的转换。</p>
<hr>
<h2 id="例子：当你确实想要-str-时"><a href="#例子：当你确实想要-str-时" class="headerlink" title="例子：当你确实想要 &amp;[&amp;str] 时"></a>例子：当你确实想要 <code>&amp;[&amp;str]</code> 时</h2><p>如果你真的想拥有一个 <code>&amp;str</code> 切片（即 <code>&amp;[&amp;str]</code>），你需要这样构建它：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// 方式一：直接使用字符串字面量（它们本身就是 &amp;str）</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">book_str_slices_1</span>: &amp;[&amp;<span class="type">str</span>] = &amp;[<span class="string">&quot;JVAV&quot;</span>, <span class="string">&quot;IT&quot;</span>, <span class="string">&quot;ZEN&quot;</span>];</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Book Str Slices 1: &#123;:?&#125;&quot;</span>, book_str_slices_1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方式二：从 String 创建 &amp;str，然后将 &amp;str 放入数组</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s1</span> = <span class="string">&quot;JVAV&quot;</span>.<span class="title function_ invoke__">to_string</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s2</span> = <span class="string">&quot;IT&quot;</span>.<span class="title function_ invoke__">to_string</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s3</span> = <span class="string">&quot;ZEN&quot;</span>.<span class="title function_ invoke__">to_string</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意这里我们是将 &amp;String 显式地转换（通过 Deref Coercion）为 &amp;str 放入数组</span></span><br><span class="line">    <span class="comment">// 但更常见的是直接从 String 创建 &amp;str</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">book_str_slices_2</span>: &amp;[&amp;<span class="type">str</span>] = &amp;[&amp;s1, &amp;s2, &amp;s3]; <span class="comment">// &amp;s1 (type &amp;String) automatically derefs to &amp;str here</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Book Str Slices 2: &#123;:?&#125;&quot;</span>, book_str_slices_2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <code>book_str_slices_2</code> 的例子中，当你把 <code>&amp;s1</code>（类型是 <code>&amp;String</code>）放入一个期望 <code>&amp;str</code> 元素的数组时，Deref Coercion 就会发生，将每个 <code>&amp;String</code> 自动转换为 <code>&amp;str</code>。</p>
<hr>
<h3 id="String与-str"><a href="#String与-str" class="headerlink" title="&amp;String与&amp;str"></a>&amp;String与&amp;str</h3><p><strong><code>&amp;[&amp;String]</code> 和 <code>&amp;[&amp;str]</code> 都不能直接修改它们所指向的字符串内容</strong>，但它们之间存在重要的区别，尤其是在<strong>所有权</strong>、<strong>生命周期</strong>和<strong>底层内存布局</strong>方面。</p>
<h2 id="核心区别概览"><a href="#核心区别概览" class="headerlink" title="核心区别概览"></a>核心区别概览</h2><table>
<thead>
<tr>
<th>特性 &#x2F; 类型</th>
<th><code>&amp;[&amp;String]</code> (指向 <code>&amp;String</code> 数组的切片)</th>
<th><code>&amp;[&amp;str]</code> (指向 <code>&amp;str</code> 数组的切片)</th>
</tr>
</thead>
<tbody><tr>
<td><strong>切片元素类型</strong></td>
<td><code>&amp;String</code> (指向 <code>String</code> 的不可变引用)</td>
<td><code>&amp;str</code> (字符串切片，指向 <code>str</code> 的不可变引用)</td>
</tr>
<tr>
<td><strong>被引用数据的</strong></td>
<td><strong><code>String</code></strong> 类型（拥有数据，在堆上）</td>
<td><strong><code>str</code></strong> 类型（通常在数据段或来自 <code>String</code> 的部分）</td>
</tr>
<tr>
<td><strong>内存位置</strong></td>
<td>引用指向堆上的 <code>String</code> 对象</td>
<td>引用可以直接指向字符串字面量（静态区）或 <code>String</code> 的堆数据</td>
</tr>
<tr>
<td><strong>底层数据所有权</strong></td>
<td>切片本身不拥有数据，但它引用的 <code>String</code> <strong>拥有</strong>数据</td>
<td>切片本身不拥有数据，它引用的 <code>str</code> 也<strong>不拥有</strong>数据</td>
</tr>
<tr>
<td><strong>生命周期管理</strong></td>
<td><strong><code>String</code> 实例的生命周期</strong>必须比 <code>&amp;String</code> 引用长</td>
<td><strong><code>str</code> 数据源的生命周期</strong>必须比 <code>&amp;str</code> 引用长</td>
</tr>
<tr>
<td><strong>创建成本</strong></td>
<td>通常涉及 <code>String::from()</code>，堆分配成本</td>
<td>直接使用字面量，无运行时成本；从 <code>String</code> 借用也无额外成本</td>
</tr>
<tr>
<td><strong>灵活性</strong></td>
<td>间接引用堆数据，多了一层封装</td>
<td>直接引用字符串数据，更灵活，可接受多种来源</td>
</tr>
</tbody></table>
<h3 id="1-String-：指向-String-引用的切片"><a href="#1-String-：指向-String-引用的切片" class="headerlink" title="1. &amp;[&amp;String]：指向 String 引用的切片"></a>1. <code>&amp;[&amp;String]</code>：指向 <code>String</code> 引用的切片</h3><p>当你有 <code>let book_slices: &amp;[&amp;String]</code> 时：</p>
<ul>
<li><strong>内部元素是 <code>&amp;String</code></strong>：这意味着切片中的每个元素都是一个<strong>指向 <code>String</code> 类型数据的引用</strong>。</li>
<li><strong><code>String</code> 拥有数据</strong>：这些 <code>String</code> 对象本身是独立的，它们各自在**堆（heap）**上分配了内存来存储字符串数据。</li>
<li><strong>多层引用</strong>：你可以将其想象为“一个数组的切片，这个数组里的每个元素都是一个指针，而这些指针又指向堆上的字符串对象”。</li>
<li><strong>生命周期</strong>：这个 <code>&amp;[&amp;String]</code> 切片的有效性，取决于它所引用的那个数组（它是一个临时数组字面量），以及数组里面所有 <code>&amp;String</code> 引用所指向的<strong>原始 <code>String</code> 实例的生命周期</strong>。这些 <code>String</code> 实例必须在 <code>&amp;[&amp;String]</code> 切片被使用期间保持有效。<ul>
<li>在你的例子中 <code>&amp;&quot;JVAV&quot;.to_string()</code>，这些 <code>String</code> 实例是<strong>匿名</strong>的。它们在切片被创建的那一行被创建，它们的生命周期被 Rust 自动管理。由于它们在表达式中创建并立即被引用，Rust 编译器会确保它们存活足够长的时间，以供 <code>book_slices</code> 使用。</li>
</ul>
</li>
<li><strong>修改</strong>：你不能通过 <code>&amp;[&amp;String]</code> 切片修改原始的 <code>String</code> 内容，也不能修改切片本身（例如增加或删除元素）。</li>
</ul>
<h3 id="2-str-：指向字符串切片的切片"><a href="#2-str-：指向字符串切片的切片" class="headerlink" title="2. &amp;[&amp;str]：指向字符串切片的切片"></a>2. <code>&amp;[&amp;str]</code>：指向字符串切片的切片</h3><p>当你有 <code>let book_str_slices: &amp;[&amp;str]</code> 时：</p>
<ul>
<li><strong>内部元素是 <code>&amp;str</code></strong>：这意味着切片中的每个元素都是一个<strong>字符串切片</strong>，直接指向 UTF-8 编码的字符串数据。</li>
<li><strong><code>&amp;str</code> 不拥有数据</strong>：这些 <code>&amp;str</code> 只是视图，它们不负责内存管理。它们可以指向：<ul>
<li><strong>静态字符串字面量</strong>（存储在程序的二进制文件中，生命周期是 <code>&#39;static&#39;</code>，贯穿整个程序）。</li>
<li><strong>堆上 <code>String</code> 的一部分或全部</strong>（如果 <code>&amp;str</code> 是从 <code>String</code> 借用而来）。</li>
</ul>
</li>
<li><strong>单层引用</strong>：这可以看作是“一个数组的切片，这个数组里的每个元素都是一个字符串指针（胖指针），直接指向字符串数据”。</li>
<li><strong>生命周期</strong>：这个 <code>&amp;[&amp;str]</code> 切片的有效性，取决于它所引用的数组，以及数组里面所有 <code>&amp;str</code> 引用所指向的<strong>原始字符串数据源的生命周期</strong>。这些数据源必须在 <code>&amp;[&amp;str]</code> 切片被使用期间保持有效。</li>
<li><strong>修改</strong>：你不能通过 <code>&amp;[&amp;str]</code> 切片修改原始的字符串内容，也不能修改切片本身。</li>
</ul>
<h2 id="为什么这种区别很重要？"><a href="#为什么这种区别很重要？" class="headerlink" title="为什么这种区别很重要？"></a>为什么这种区别很重要？</h2><ol>
<li><strong>性能与内存开销</strong>：<ul>
<li><code>&amp;[&amp;String]</code>：创建时需要先创建 <code>String</code> 对象（堆分配），再获取引用。这会带来额外的内存分配和解分配开销。</li>
<li><code>&amp;[&amp;str]</code>：如果元素是字符串字面量，就没有堆分配开销。如果元素是从 <code>String</code> 借用的 <code>&amp;str</code>，那么也没有额外的堆分配。通常更轻量级。</li>
</ul>
</li>
<li><strong>生命周期复杂性</strong>：<ul>
<li><code>&amp;[&amp;String]</code>：你引用的 <code>String</code> 实例必须在切片的整个生命周期内都存在。如果这些 <code>String</code> 是匿名临时创建的，Rust 编译器会尽力延长它们的生命周期，但这并非总是能成功。</li>
<li><code>&amp;[&amp;str]</code>：其生命周期取决于它所引用的实际 <code>str</code> 数据。<code>&amp;&#39;static str</code> 最简单，可以无限制地使用。从 <code>String</code> 借用的 <code>&amp;str</code> 则受限于 <code>String</code> 的生命周期。</li>
</ul>
</li>
<li><strong>函数通用性</strong>：<ul>
<li>通常情况下，函数参数更倾向于使用 <code>&amp;str</code> 而不是 <code>&amp;String</code>，因为 <code>&amp;str</code> 更通用，可以接受各种来源的字符串数据。</li>
<li><code>&amp;[&amp;str]</code> 这样的类型在处理一组通用字符串视图时更为常见。</li>
</ul>
</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>虽然 <code>&amp;[&amp;String]</code> 和 <code>&amp;[&amp;str]</code> 都表示不可修改的字符串序列，但它们在<strong>底层数据类型、所有权链、内存分配和生命周期管理</strong>上存在根本区别。</p>
<ul>
<li><code>&amp;[&amp;String]</code> 是一个切片，它的元素是<strong>指向堆上 <code>String</code> 对象的引用</strong>。</li>
<li><code>&amp;[&amp;str]</code> 是一个切片，它的元素是<strong>直接指向 <code>str</code> 数据的引用</strong>（可以是静态区或堆上 <code>String</code> 的一部分）。</li>
</ul>
<p>理解这些细微差别对于编写高效、安全且符合 Rust 习惯的代码至关重要。</p>
<p>但是&amp;[&amp;mut String]是可以对包含的字符串内容进行修改的，可以类比C语言中的字符数组数组。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Chillward"
      src="/uploads/avatar.png">
  <p class="site-author-name" itemprop="name">Chillward</p>
  <div class="site-description" itemprop="description">谁躺在漆黑的舞台上，用身体迎接着光芒</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">11</span>
          <span class="site-state-item-name">博客</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/zh-CN" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Chillward</span>
</div>
  <div class="powered-by">
    <!--由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动 -->
  </div>

<!-- 网站运行时间的设置 -->
<span id="timeDate">载入天数...</span>
<span id="times">载入时分秒...</span>
<script>
    var now = new Date();
    function createtime() {
        var grt= new Date("07/16/2025 10:00:00"); //此处修改你的建站时间或者网站上线时间
        now.setTime(now.getTime()+250);
        days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days);
        hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours);
        if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);
        mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;}
        seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
        snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;}
        document.getElementById("timeDate").innerHTML = "本站已安全运行 "+dnum+" 天 ";
        document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒.";
    }
setInterval("createtime()",250);
</script>
        








	 </div>
    </footer>
  </div>

  
  <script size="300" alpha="0.6" zIndex="-1" src="/lib/canvas-ribbon/canvas-ribbon.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/pjax/pjax.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/lozad@1/dist/lozad.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/pangu@4/dist/browser/pangu.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  




  
<script src="/js/local-search.js"></script>











<script data-pjax>
if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.initialize({
      theme    : 'dark',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    });
  }, window.mermaid);
}
</script>


    <div id="pjax">
  

  

    </div>
</body>
</html>
