<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":true,"pangu":true,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="谁躺在漆黑的舞台上，用身体迎接着光芒">
<meta property="og:type" content="website">
<meta property="og:title" content="Chillward的博客">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Chillward的博客">
<meta property="og:description" content="谁躺在漆黑的舞台上，用身体迎接着光芒">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Chillward">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Chillward的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Chillward的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/08/01/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E7%9A%84%E7%9A%84%E5%8C%BA%E5%88%AB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.png">
      <meta itemprop="name" content="Chillward">
      <meta itemprop="description" content="谁躺在漆黑的舞台上，用身体迎接着光芒">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chillward的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/08/01/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E7%9A%84%E7%9A%84%E5%8C%BA%E5%88%AB/" class="post-title-link" itemprop="url">面向对象和面向过程的的区别</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-08-01 11:15:43 / 修改时间：15:50:56" itemprop="dateCreated datePublished" datetime="2025-08-01T11:15:43+08:00">2025-08-01</time>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>0</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/07/30/RUST%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0%E4%B9%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.png">
      <meta itemprop="name" content="Chillward">
      <meta itemprop="description" content="谁躺在漆黑的舞台上，用身体迎接着光芒">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chillward的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/07/30/RUST%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0%E4%B9%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/" class="post-title-link" itemprop="url">RUST学习日记之生命周期</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-07-30 18:01:54 / 修改时间：22:19:22" itemprop="dateCreated datePublished" datetime="2025-07-30T18:01:54+08:00">2025-07-30</time>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>15k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>28 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>首先我们明确一个概念，生命周期也是一种泛型，生命周期是Rust中很特别的一个特性，它的存在直接从语言层面避免了很多可能出现的问题。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line">        r = &amp;x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;r: &#123;&#125;&quot;</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这段代码不能编译因为 <code>r</code> 引用的值在尝试使用之前就离开了作用域</p>
<p>这种悬垂引用在C语言中是可以编译成功的，但是在运行时会出现不可预知的结果，Rust直接在编译阶段就会报错，无法编译，因为借用检查器会阻止这种行为。</p>
<p>Rust 编译器有一个 <strong>借用检查器</strong>（<em>borrow checker</em>），它比较作用域来确保所有的借用都是有效的。示例 10-18 展示了与示例 10-17 相同的例子，不过带有变量生命周期的注释：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r</span>;                <span class="comment">// ---------+-- &#x27;a</span></span><br><span class="line">                          <span class="comment">//          |</span></span><br><span class="line">    &#123;                     <span class="comment">//          |</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;        <span class="comment">// -+-- &#x27;b  |</span></span><br><span class="line">        r = &amp;x;           <span class="comment">//  |       |</span></span><br><span class="line">    &#125;                     <span class="comment">// -+       |</span></span><br><span class="line">                          <span class="comment">//          |</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;r: &#123;&#125;&quot;</span>, r); <span class="comment">//          |</span></span><br><span class="line">&#125;                         <span class="comment">// ---------+</span></span><br></pre></td></tr></table></figure>

<p>示例 10-18：<code>r</code> 和 <code>x</code> 的生命周期标注，分别叫做 <code>&#39;a</code> 和 <code>&#39;b</code></p>
<p>这里将 <code>r</code> 的生命周期标记为 <code>&#39;a</code> 并将 <code>x</code> 的生命周期标记为 <code>&#39;b</code>。如你所见，内部的 <code>&#39;b</code> 块要比外部的生命周期 <code>&#39;a</code> 小得多。在编译时，Rust 比较这两个生命周期的大小，并发现 <code>r</code> 拥有生命周期 <code>&#39;a</code>，不过它引用了一个拥有生命周期 <code>&#39;b</code> 的对象。程序被拒绝编译，因为生命周期 <code>&#39;b</code> 比生命周期 <code>&#39;a</code> 要小：被引用的对象比它的引用者存在的时间更短。</p>
<p>让我们看看示例 10-19 中这个并没有产生悬垂引用且可以正确编译的例子：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;            <span class="comment">// ----------+-- &#x27;b</span></span><br><span class="line">                          <span class="comment">//           |</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r</span> = &amp;x;           <span class="comment">// --+-- &#x27;a  |</span></span><br><span class="line">                          <span class="comment">//   |       |</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;r: &#123;&#125;&quot;</span>, r); <span class="comment">//   |       |</span></span><br><span class="line">                          <span class="comment">// --+       |</span></span><br><span class="line">&#125;                         <span class="comment">// ----------+</span></span><br></pre></td></tr></table></figure>

<p>示例 10-19：一个有效的引用，因为数据比引用有着更长的生命周期</p>
<p>这里 <code>x</code> 拥有生命周期 <code>&#39;b</code>，比 <code>&#39;a</code> 要大。这就意味着 <code>r</code> 可以引用 <code>x</code>：Rust 知道 <code>r</code> 中的引用在 <code>x</code> 有效的时候也总是有效的。</p>
<p>现在我们已经在一个具体的例子中展示了什么是引用的生命周期，并讨论了 Rust 如何分析生命周期来保证引用总是有效的，接下来让我们聊聊在函数的上下文中参数和返回值的泛型生命周期。</p>
<h3 id="函数中的泛型生命周期"><a href="#函数中的泛型生命周期" class="headerlink" title="函数中的泛型生命周期"></a><a target="_blank" rel="noopener" href="https://rustwiki.org/zh-CN/book/ch10-03-lifetime-syntax.html#%E5%87%BD%E6%95%B0%E4%B8%AD%E7%9A%84%E6%B3%9B%E5%9E%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F">函数中的泛型生命周期</a></h3><p>让我们来编写一个函数，返回两个字符串 slice 中较长的那一个。这个函数获取两个字符串 slice 并返回一个字符串 slice。一旦我们实现了 <code>longest</code> 函数，示例 10-20 中的代码应该会打印出 <code>The longest string is abcd</code>：</p>
<p>文件名: src&#x2F;main.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">string1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;abcd&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">string2</span> = <span class="string">&quot;xyz&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span> = <span class="title function_ invoke__">longest</span>(string1.<span class="title function_ invoke__">as_str</span>(), string2);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The longest string is &#123;&#125;&quot;</span>, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例 10-20：<code>main</code> 函数调用 <code>longest</code> 函数来寻找两个字符串 slice 中较长的一个</p>
<p>请注意，这个函数获取作为引用的字符串 slice，因为我们不希望 <code>longest</code> 函数获取参数的所有权。我们期望该函数接受 <code>String</code> 的 slice（参数 <code>string1</code> 的类型）和字符串字面量（包含于参数 <code>string2</code>）</p>
<p>参考第 4 章中的 <a target="_blank" rel="noopener" href="https://rustwiki.org/zh-CN/book/ch04-03-slices.html#string-slices-as-parameters">“字符串 slice 作为参数”</a> 部分中更多关于为什么示例 10-20 的参数正符合我们期望的讨论。</p>
<p>如果尝试像示例 10-21 中那样实现 <code>longest</code> 函数，它并不能编译：</p>
<p>文件名: src&#x2F;main.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">longest</span>(x: &amp;<span class="type">str</span>, y: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">str</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x.<span class="title function_ invoke__">len</span>() &gt; y.<span class="title function_ invoke__">len</span>() &#123;</span><br><span class="line">        x</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例 10-21：一个 <code>longest</code> 函数的实现，它返回两个字符串 slice 中较长者，现在还不能编译</p>
<p>相应地会出现如下有关生命周期的错误：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">error[E0106]: missing lifetime specifier</span><br><span class="line"> --&gt; src/main.rs:1:33</span><br><span class="line">  |</span><br><span class="line">1 | fn longest(x: &amp;str, y: &amp;str) -&gt; &amp;str &#123;</span><br><span class="line">  |                                 ^ expected lifetime parameter</span><br><span class="line">  |</span><br><span class="line">  = help: this function&#x27;s return type contains a borrowed value, but the</span><br><span class="line">signature does not say whether it is borrowed from `x` or `y`</span><br></pre></td></tr></table></figure>

<p>提示文本揭示了返回值需要一个泛型生命周期参数，因为 Rust 并不知道将要返回的引用是指向 <code>x</code> 或 <code>y</code>。事实上我们也不知道，因为函数体中 <code>if</code> 块返回一个 <code>x</code> 的引用而 <code>else</code> 块返回一个 <code>y</code> 的引用！</p>
<p>当我们定义这个函数的时候，并不知道传递给函数的具体值，所以也不知道到底是 <code>if</code> 还是 <code>else</code> 会被执行。我们也不知道传入的引用的具体生命周期，所以也就不能像示例 10-18 和 10-19 那样通过观察作用域来确定返回的引用是否总是有效。借用检查器自身同样也无法确定，因为它不知道 <code>x</code> 和 <code>y</code> 的生命周期是如何与返回值的生命周期相关联的。为了修复这个错误，我们将增加泛型生命周期参数来定义引用间的关系以便借用检查器可以进行分析。</p>
<h3 id="生命周期标注语法"><a href="#生命周期标注语法" class="headerlink" title="生命周期标注语法"></a><a target="_blank" rel="noopener" href="https://rustwiki.org/zh-CN/book/ch10-03-lifetime-syntax.html#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%A0%87%E6%B3%A8%E8%AF%AD%E6%B3%95">生命周期标注语法</a></h3><p>生命周期标注并不改变任何引用的生命周期的长短。与当函数签名中指定了泛型类型参数后就可以接受任何类型一样，当指定了泛型生命周期后函数也能接受任何生命周期的引用。生命周期标注描述了多个引用生命周期相互的关系，而不影响其生命周期。</p>
<p>生命周期标注有着一个不太常见的语法：生命周期参数名称必须以撇号（<code>&#39;</code>）开头，其名称通常全是小写，类似于泛型其名称非常短。<code>&#39;a</code> 是大多数人默认使用的名称。生命周期参数标注位于引用的 <code>&amp;</code> 之后，并有一个空格来将引用类型与生命周期标注分隔开。</p>
<p>这里有一些例子：我们有一个没有生命周期参数的 <code>i32</code> 的引用，一个有叫做 <code>&#39;a</code> 的生命周期参数的 <code>i32</code> 的引用，和一个生命周期也是 <code>&#39;a</code> 的 <code>i32</code> 的可变引用：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&amp;<span class="type">i32</span>        <span class="comment">// 引用</span></span><br><span class="line">&amp;<span class="symbol">&#x27;a</span> <span class="type">i32</span>     <span class="comment">// 带有显式生命周期的引用</span></span><br><span class="line">&amp;<span class="symbol">&#x27;a</span> <span class="keyword">mut</span> <span class="type">i32</span> <span class="comment">// 带有显式生命周期的可变引用</span></span><br></pre></td></tr></table></figure>

<p>单个生命周期标注本身没有多少意义，因为生命周期标注告诉 Rust 多个引用的泛型生命周期参数如何相互联系的。例如如果函数有一个生命周期 <code>&#39;a</code> 的 <code>i32</code> 的引用的参数 <code>first</code>。还有另一个同样是生命周期 <code>&#39;a</code> 的 <code>i32</code> 的引用的参数 <code>second</code>。这两个生命周期标注意味着引用 <code>first</code> 和 <code>second</code> 必须与这泛型生命周期存在得一样久。</p>
<h3 id="函数签名中的生命周期标注"><a href="#函数签名中的生命周期标注" class="headerlink" title="函数签名中的生命周期标注"></a><a target="_blank" rel="noopener" href="https://rustwiki.org/zh-CN/book/ch10-03-lifetime-syntax.html#%E5%87%BD%E6%95%B0%E7%AD%BE%E5%90%8D%E4%B8%AD%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%A0%87%E6%B3%A8">函数签名中的生命周期标注</a></h3><p>现在来看看 <code>longest</code> 函数的上下文中的生命周期。就像泛型类型参数，泛型生命周期参数需要声明在函数名和参数列表间的尖括号中。这里我们想要告诉 Rust 关于参数中的引用和返回值之间的限制是他们都必须拥有相同的生命周期，就像示例 10-22 中在每个引用中都加上了 <code>&#39;a</code> 那样：</p>
<p>文件名: src&#x2F;main.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">longest</span>&lt;<span class="symbol">&#x27;a</span>&gt;(x: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>, y: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x.<span class="title function_ invoke__">len</span>() &gt; y.<span class="title function_ invoke__">len</span>() &#123;</span><br><span class="line">        x</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例 10-22：<code>longest</code> 函数定义指定了签名中所有的引用必须有相同的生命周期 <code>&#39;a</code></p>
<p>这段代码能够编译并会产生我们希望得到的示例 10-20 中的 <code>main</code> 函数的结果。</p>
<p>现在函数签名表明对于某些生命周期 <code>&#39;a</code>，函数会获取两个参数，他们都是与生命周期 <code>&#39;a</code> 存在的一样长的字符串 slice。函数会返回一个同样也与生命周期 <code>&#39;a</code> 存在的一样长的字符串 slice。它的实际含义是 <code>longest</code> 函数返回的引用的生命周期与传入该函数的引用的生命周期的较小者一致。这就是我们告诉 Rust 需要其保证的约束条件。记住通过在函数签名中指定生命周期参数时，我们并没有改变任何传入值或返回值的生命周期，而是指出任何不满足这个约束条件的值都将被借用检查器拒绝。注意 <code>longest</code> 函数并不需要知道 <code>x</code> 和 <code>y</code> 具体会存在多久，而只需要知道有某个可以被 <code>&#39;a</code> 替代的作用域将会满足这个签名。</p>
<p>当在函数中使用生命周期标注时，这些标注出现在函数签名中，而不存在于函数体中的任何代码中。这是因为 Rust 能够分析函数中代码而不需要任何协助，不过当函数引用或被函数之外的代码引用时，让 Rust 自身分析出参数或返回值的生命周期几乎是不可能的。这些生命周期在每次函数被调用时都可能不同。这也就是为什么我们需要手动标记生命周期。</p>
<p>当具体的引用被传递给 <code>longest</code> 时，被 <code>&#39;a</code> 所替代的具体生命周期是 <code>x</code> 的作用域与 <code>y</code> 的作用域相重叠的那一部分。换一种说法就是泛型生命周期 <code>&#39;a</code> 的具体生命周期等同于 <code>x</code> 和 <code>y</code> 的生命周期中较小的那一个。因为我们用相同的生命周期参数 <code>&#39;a</code> 标注了返回的引用值，所以返回的引用值就能保证在 <code>x</code> 和 <code>y</code> 中较短的那个生命周期结束之前保持有效。</p>
<p>让我们看看如何通过传递拥有不同具体生命周期的引用来限制 <code>longest</code> 函数的使用。示例 10-23 是一个很直观的例子。</p>
<p>文件名: src&#x2F;main.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">string1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;long string is long&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">string2</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;xyz&quot;</span>);</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">result</span> = <span class="title function_ invoke__">longest</span>(string1.<span class="title function_ invoke__">as_str</span>(), string2.<span class="title function_ invoke__">as_str</span>());</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;The longest string is &#123;&#125;&quot;</span>, result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例 10-23：通过拥有不同的具体生命周期的 <code>String</code> 值调用 <code>longest</code> 函数</p>
<p>在这个例子中，<code>string1</code> 直到外部作用域结束都是有效的，<code>string2</code> 则在内部作用域中是有效的，而 <code>result</code> 则引用了一些直到内部作用域结束都是有效的值。借用检查器认可这些代码；它能够编译和运行，并打印出 <code>The longest string is long string is long</code>。</p>
<p>接下来，让我们尝试另外一个例子，该例子揭示了 <code>result</code> 的引用的生命周期必须是两个参数中较短的那个。以下代码将 <code>result</code> 变量的声明移动出内部作用域，但是将 <code>result</code> 和 <code>string2</code> 变量的赋值语句一同留在内部作用域中。接着，使用了变量 <code>result</code> 的 <code>println!</code> 也被移动到内部作用域之外。注意示例 10-24 中的代码不能通过编译：</p>
<p>文件名: src&#x2F;main.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">string1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;long string is long&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">string2</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;xyz&quot;</span>);</span><br><span class="line">        result = <span class="title function_ invoke__">longest</span>(string1.<span class="title function_ invoke__">as_str</span>(), string2.<span class="title function_ invoke__">as_str</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The longest string is &#123;&#125;&quot;</span>, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例 10-24：尝试在 <code>string2</code> 离开作用域之后使用 <code>result</code></p>
<p>如果尝试编译会出现如下错误：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">error[E0597]: `string2` does not live long enough</span><br><span class="line"> --&gt; src/main.rs:6:44</span><br><span class="line">  |</span><br><span class="line">6 |         result = longest(string1.as_str(), string2.as_str());</span><br><span class="line">  |                                            ^^^^^^^ borrowed value does not live long enough</span><br><span class="line">7 |     &#125;</span><br><span class="line">  |     - `string2` dropped here while still borrowed</span><br><span class="line">8 |     println!(&quot;The longest string is &#123;&#125;&quot;, result);</span><br><span class="line">  |                                          ------ borrow later used here</span><br></pre></td></tr></table></figure>

<p>错误表明为了保证 <code>println!</code> 中的 <code>result</code> 是有效的，<code>string2</code> 需要直到外部作用域结束都是有效的。Rust 知道这些是因为（<code>longest</code>）函数的参数和返回值都使用了相同的生命周期参数 <code>&#39;a</code>。</p>
<p>如果从人的角度读上述代码，我们可能会觉得这个代码是正确的。 <code>string1</code> 更长，因此 <code>result</code> 会包含指向 <code>string1</code> 的引用。因为 <code>string1</code> 尚未离开作用域，对于 <code>println!</code> 来说 <code>string1</code> 的引用仍然是有效的。然而，我们通过生命周期参数告诉 Rust 的是： <code>longest</code> 函数返回的引用的生命周期应该与传入参数的生命周期中较短那个保持一致。因此，借用检查器不允许示例 10-24 中的代码，因为它可能会存在无效的引用。</p>
<p>请尝试更多采用不同的值和不同生命周期的引用作为 <code>longest</code> 函数的参数和返回值的实验。并在开始编译前猜想你的实验能否通过借用检查器，接着编译一下看看你的理解是否正确！</p>
<h3 id="深入理解生命周期"><a href="#深入理解生命周期" class="headerlink" title="深入理解生命周期"></a><a target="_blank" rel="noopener" href="https://rustwiki.org/zh-CN/book/ch10-03-lifetime-syntax.html#%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F">深入理解生命周期</a></h3><p>指定生命周期参数的正确方式依赖函数实现的具体功能。例如，如果将 <code>longest</code> 函数的实现修改为总是返回第一个参数而不是最长的字符串 slice，就不需要为参数 <code>y</code> 指定一个生命周期。如下代码将能够编译：</p>
<p>文件名: src&#x2F;main.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">longest</span>&lt;<span class="symbol">&#x27;a</span>&gt;(x: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>, y: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span> &#123;</span><br><span class="line">    x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，我们为参数 <code>x</code> 和返回值指定了生命周期参数 <code>&#39;a</code>，不过没有为参数 <code>y</code> 指定，因为 <code>y</code> 的生命周期与参数 <code>x</code> 和返回值的生命周期没有任何关系。</p>
<p>当从函数返回一个引用，返回值的生命周期参数需要与一个参数的生命周期参数相匹配。如果返回的引用 <strong>没有</strong> 指向任何一个参数，那么唯一的可能就是它指向一个函数内部创建的值，它将会是一个悬垂引用，因为它将会在函数结束时离开作用域。尝试考虑这个并不能编译的 <code>longest</code> 函数实现：</p>
<p>文件名: src&#x2F;main.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">longest</span>&lt;<span class="symbol">&#x27;a</span>&gt;(x: &amp;<span class="type">str</span>, y: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;really long string&quot;</span>);</span><br><span class="line">    result.<span class="title function_ invoke__">as_str</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>即便我们为返回值指定了生命周期参数 <code>&#39;a</code>，这个实现却编译失败了，因为返回值的生命周期与参数完全没有关联。这里是会出现的错误信息：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">error[E0597]: `result` does not live long enough</span><br><span class="line"> --&gt; src/main.rs:3:5</span><br><span class="line">  |</span><br><span class="line">3 |     result.as_str()</span><br><span class="line">  |     ^^^^^^ does not live long enough</span><br><span class="line">4 | &#125;</span><br><span class="line">  | - borrowed value only lives until here</span><br><span class="line">  |</span><br><span class="line">note: borrowed value must be valid for the lifetime &#x27;a as defined on the</span><br><span class="line">function body at 1:1...</span><br><span class="line"> --&gt; src/main.rs:1:1</span><br><span class="line">  |</span><br><span class="line">1 | / fn longest&lt;&#x27;a&gt;(x: &amp;str, y: &amp;str) -&gt; &amp;&#x27;a str &#123;</span><br><span class="line">2 | |     let result = String::from(&quot;really long string&quot;);</span><br><span class="line">3 | |     result.as_str()</span><br><span class="line">4 | | &#125;</span><br><span class="line">  | |_^</span><br></pre></td></tr></table></figure>

<p>出现的问题是 <code>result</code> 在 <code>longest</code> 函数的结尾将离开作用域并被清理，而我们尝试从函数返回一个 <code>result</code> 的引用。无法指定生命周期参数来改变悬垂引用，而且 Rust 也不允许我们创建一个悬垂引用。在这种情况，最好的解决方案是返回一个有所有权的数据类型而不是一个引用，这样函数调用者就需要负责清理这个值了。</p>
<blockquote>
<p>类似于C语言中不能返回一个局部变量的值，二者是比较类似的</p>
</blockquote>
<p>综上，生命周期语法是用于将函数的多个参数与其返回值的生命周期进行关联的。一旦他们形成了某种关联，Rust 就有了足够的信息来允许内存安全的操作并阻止会产生悬垂指针亦或是违反内存安全的行为。</p>
<h3 id="结构体定义中的生命周期标注"><a href="#结构体定义中的生命周期标注" class="headerlink" title="结构体定义中的生命周期标注"></a><a target="_blank" rel="noopener" href="https://rustwiki.org/zh-CN/book/ch10-03-lifetime-syntax.html#%E7%BB%93%E6%9E%84%E4%BD%93%E5%AE%9A%E4%B9%89%E4%B8%AD%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%A0%87%E6%B3%A8">结构体定义中的生命周期标注</a></h3><p>目前为止，我们只定义过有所有权类型的结构体。接下来，我们将定义包含引用的结构体，不过这需要为结构体定义中的每一个引用添加生命周期标注。示例 10-25 中有一个存放了一个字符串 slice 的结构体 <code>ImportantExcerpt</code>：</p>
<p>文件名: src&#x2F;main.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ImportantExcerpt</span>&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    part: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">novel</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Call me Ishmael. Some years ago...&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">first_sentence</span> = novel.<span class="title function_ invoke__">split</span>(<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">        .<span class="title function_ invoke__">next</span>()</span><br><span class="line">        .<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Could not find a &#x27;.&#x27;&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">i</span> = ImportantExcerpt &#123; part: first_sentence &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例 10-25：一个存放引用的结构体，所以其定义需要生命周期标注</p>
<p>这个结构体有一个字段，<code>part</code>，它存放了一个字符串 slice，这是一个引用。类似于泛型参数类型，必须在结构体名称后面的尖括号中声明泛型生命周期参数，以便在结构体定义中使用生命周期参数。这个标注意味着 <code>ImportantExcerpt</code> 的实例不能比其 <code>part</code> 字段中的引用存在的更久。</p>
<p>这里的 <code>main</code> 函数创建了一个 <code>ImportantExcerpt</code> 的实例，它存放了变量 <code>novel</code> 所拥有的 <code>String</code> 的第一个句子的引用。<code>novel</code> 的数据在 <code>ImportantExcerpt</code> 实例创建之前就存在。另外，直到 <code>ImportantExcerpt</code> 离开作用域之后 <code>novel</code> 都不会离开作用域，所以 <code>ImportantExcerpt</code> 实例中的引用是有效的。</p>
<h3 id="生命周期省略（Lifetime-Elision）"><a href="#生命周期省略（Lifetime-Elision）" class="headerlink" title="生命周期省略（Lifetime Elision）"></a><a target="_blank" rel="noopener" href="https://rustwiki.org/zh-CN/book/ch10-03-lifetime-syntax.html#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%9C%81%E7%95%A5lifetime-elision">生命周期省略（Lifetime Elision）</a></h3><p>现在我们已经知道了每一个引用都有一个生命周期，而且我们需要为那些使用了引用的函数或结构体指定生命周期。然而，第 4 章的示例 4-9 中有一个函数，如示例 10-26 所示，它没有生命周期标注却能编译成功：</p>
<p>文件名: src&#x2F;lib.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">first_word</span>(s: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">str</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">bytes</span> = s.<span class="title function_ invoke__">as_bytes</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i, &amp;item) <span class="keyword">in</span> bytes.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">enumerate</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> item == <span class="string">b&#x27; &#x27;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> &amp;s[<span class="number">0</span>..i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &amp;s[..]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例 10-26：示例 4-9 定义了一个没有使用生命周期标注的函数，即便其参数和返回值都是引用</p>
<p>这个函数没有生命周期标注却能编译是由于一些历史原因：在早期版本（pre-1.0）的 Rust 中，这的确是不能编译的。每一个引用都必须有明确的生命周期。那时的函数签名将会写成这样：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">first_word</span>&lt;<span class="symbol">&#x27;a</span>&gt;(s: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span> &#123;</span><br></pre></td></tr></table></figure>

<p>在编写了很多 Rust 代码后，Rust 团队发现在特定情况下 Rust 开发者们总是重复地编写一模一样的生命周期标注。这些场景是可预测的并且遵循几个明确的模式。接着 Rust 团队就把这些模式编码进了 Rust 编译器中，如此借用检查器在这些情况下就能推断出生命周期而不再强制开发者显式的增加标注。</p>
<p>这里我们提到一些 Rust 的历史是因为更多的明确的模式被合并和添加到编译器中是完全可能的。未来只会需要更少的生命周期标注。</p>
<p>被编码进 Rust 引用分析的模式被称为 <strong>生命周期省略规则</strong>（<em>lifetime elision rules</em>）。这并不是需要开发者遵守的规则；这些规则是一系列特定的场景，此时编译器会考虑，如果代码符合这些场景，就无需明确指定生命周期。</p>
<p>省略规则并不提供完整的推断：如果 Rust 在明确遵守这些规则的前提下变量的生命周期仍然是模棱两可的话，它不会猜测剩余引用的生命周期应该是什么。在这种情况，编译器会给出一个错误，这可以通过增加对应引用之间相联系的生命周期标注来解决。</p>
<p>函数或方法的参数的生命周期被称为 <strong>输入生命周期</strong>（<em>input lifetimes</em>），而返回值的生命周期被称为 <strong>输出生命周期</strong>（<em>output lifetimes</em>）。</p>
<p>编译器采用三条规则来判断引用何时不需要明确的标注。第一条规则适用于输入生命周期，后两条规则适用于输出生命周期。如果编译器检查完这三条规则后仍然存在没有计算出生命周期的引用，编译器将会停止并生成错误。这些规则适用于 <code>fn</code> 定义，以及 <code>impl</code> 块。</p>
<p>第一条规则是每一个是引用的参数都有它自己的生命周期参数。换句话说就是，有一个引用参数的函数有一个生命周期参数：<code>fn foo&lt;&#39;a&gt;(x: &amp;&#39;a i32)</code>，有两个引用参数的函数有两个不同的生命周期参数，<code>fn foo&lt;&#39;a, &#39;b&gt;(x: &amp;&#39;a i32, y: &amp;&#39;b i32)</code>，依此类推。</p>
<p>第二条规则是如果只有一个输入生命周期参数，那么它被赋予所有输出生命周期参数：<code>fn foo&lt;&#39;a&gt;(x: &amp;&#39;a i32) -&gt; &amp;&#39;a i32</code>。</p>
<p>第三条规则是如果方法有多个输入生命周期参数并且其中一个参数是 <code>&amp;self</code> 或 <code>&amp;mut self</code>，说明是个对象的方法(method)(译者注： 这里涉及 Rust 的面向对象，参见第 17 章), 那么所有输出生命周期参数被赋予 <code>self</code> 的生命周期。第三条规则使得方法更容易读写，因为只需更少的符号。</p>
<p>假设我们自己就是编译器。并应用这些规则来计算示例 10-26 中 <code>first_word</code> 函数签名中的引用的生命周期。开始时签名中的引用并没有关联任何生命周期：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">first_word</span>(s: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">str</span> &#123;</span><br></pre></td></tr></table></figure>

<p>接着编译器应用第一条规则，也就是每个引用参数都有其自己的生命周期。我们像往常一样称之为 <code>&#39;a</code>，所以现在签名看起来像这样：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">first_word</span>&lt;<span class="symbol">&#x27;a</span>&gt;(s: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">str</span> &#123;</span><br></pre></td></tr></table></figure>

<p>对于第二条规则，因为这里正好只有一个输入生命周期参数所以是适用的。第二条规则表明输入参数的生命周期将被赋予输出生命周期参数，所以现在签名看起来像这样：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">first_word</span>&lt;<span class="symbol">&#x27;a</span>&gt;(s: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span> &#123;</span><br></pre></td></tr></table></figure>

<p>现在这个函数签名中的所有引用都有了生命周期，如此编译器可以继续它的分析而无须开发者标记这个函数签名中的生命周期。</p>
<p>让我们再看看另一个例子，这次我们从示例 10-21 中没有生命周期参数的 <code>longest</code> 函数开始：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">longest</span>(x: &amp;<span class="type">str</span>, y: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">str</span> &#123;</span><br></pre></td></tr></table></figure>

<p>再次假设我们自己就是编译器并应用第一条规则：每个引用参数都有其自己的生命周期。这次有两个参数，所以就有两个（不同的）生命周期：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">longest</span>&lt;<span class="symbol">&#x27;a</span>, <span class="symbol">&#x27;b</span>&gt;(x: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>, y: &amp;<span class="symbol">&#x27;b</span> <span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">str</span> &#123;</span><br></pre></td></tr></table></figure>

<p>再来应用第二条规则，因为函数存在多个输入生命周期，它并不适用于这种情况。再来看第三条规则，它同样也不适用，这是因为没有 <code>self</code> 参数。应用了三个规则之后编译器还没有计算出返回值类型的生命周期。这就是我们在尝试编译示例 10-21 中的代码时出现错误的原因：编译器使用所有已知的生命周期省略规则，仍不能计算出签名中所有引用的生命周期。</p>
<p>因为第三条规则真正能够适用的就只有方法签名，现在就让我们看看那种情况中的生命周期，并看看为什么这条规则意味着我们经常不需要在方法签名中标注生命周期。</p>
<blockquote>
<p>关于这几条规则，AI是这么说的</p>
</blockquote>
<p>你描述的“生命周期省略规则”（Lifetime Elision Rules）是 Rust 编译器的一项便利功能，它旨在减少你在编写 Rust 代码时手动添加生命周期注解的次数。简单来说，这些规则是编译器内置的一些<strong>模式识别能力</strong>，当你的代码符合这些模式时，编译器就能<strong>自动推断</strong>引用的生命周期，而不需要你显式地写出来。</p>
<h3 id="生命周期的核心问题回顾"><a href="#生命周期的核心问题回顾" class="headerlink" title="生命周期的核心问题回顾"></a>生命周期的核心问题回顾</h3><p>在深入规则之前，我们先快速回顾一下为什么需要生命周期：</p>
<ul>
<li><strong>安全保证：</strong> Rust 的核心优势之一是内存安全，没有垃圾回收器。它通过所有权系统和借用检查器来实现这一点。</li>
<li><strong>引用的有效性：</strong> 当你创建一个引用（例如 <code>&amp;str</code>），这个引用不能比它所指向的数据“活”得更久。如果引用比数据活得久，就会变成<strong>悬垂引用</strong>，指向一片无效的内存。</li>
<li><strong>生命周期注解：</strong> 为了确保引用的有效性，Rust 引入了<strong>生命周期注解</strong>（如 <code>&#39;a</code>），它们不是改变引用的生命周期，而是告诉借用检查器：这个引用需要和它所指的数据一样长寿，或者更短寿。当函数接收引用参数并返回引用时，编译器需要知道输入引用和输出引用之间的生命周期关系，以确保返回的引用是有效的。</li>
</ul>
<h3 id="生命周期省略规则的由来"><a href="#生命周期省略规则的由来" class="headerlink" title="生命周期省略规则的由来"></a>生命周期省略规则的由来</h3><p>在 Rust 的早期版本中，每个引用都必须有明确的生命周期注解，这导致代码中充斥着大量的 <code>&#39;a</code>、<code>&#39;b</code> 等，使得代码显得冗长且难以阅读。Rust 团队发现，在大多数常见场景下，开发者总是以相同的方式标注生命周期。于是，他们将这些常见的、可预测的模式“硬编码”到编译器中，让编译器在这些情况下<strong>自动推断</strong>。这些模式就是“生命周期省略规则”。</p>
<p><strong>注意：</strong></p>
<ul>
<li>这些规则是<strong>编译器内部的逻辑</strong>，而不是你需要遵循的编码规范。你不需要刻意去记住它们并应用到你的代码中。</li>
<li>它们<strong>不提供完整的推断</strong>。如果根据这些规则，引用的生命周期仍然模棱两可，编译器会报错，要求你手动添加注解。</li>
</ul>
<h3 id="三条生命周期省略规则详解"><a href="#三条生命周期省略规则详解" class="headerlink" title="三条生命周期省略规则详解"></a>三条生命周期省略规则详解</h3><p>编译器在判断何时可以省略生命周期注解时，会按照以下三条规则顺序检查。如果所有规则都应用完了，仍然有不明确的生命周期，编译器就会报错。</p>
<h4 id="1-输入生命周期规则-针对函数或方法的参数"><a href="#1-输入生命周期规则-针对函数或方法的参数" class="headerlink" title="1. 输入生命周期规则 (针对函数或方法的参数)"></a>1. 输入生命周期规则 (针对函数或方法的参数)</h4><p><strong>规则：</strong> 函数或方法中，每个是<strong>引用类型</strong>的参数都拥有自己独立的生命周期参数。</p>
<p><strong>例子：</strong></p>
<ul>
<li><p>如果函数有一个引用参数 s: &amp;str，它会变成 s: &amp;’a str。</p>
<p>fn first_word(s: &amp;str) → fn first_word&lt;’a&gt;(s: &amp;’a str)</p>
</li>
<li><p>如果函数有两个引用参数 x: &amp;str, y: &amp;str，它们会分别获得不同的生命周期。</p>
<p>fn longest(x: &amp;str, y: &amp;str) → fn longest&lt;’a, ‘b&gt;(x: &amp;’a str, y: &amp;’b str)</p>
</li>
<li><p>如果有一个引用参数和一个非引用参数，只有引用参数会获得生命周期。</p>
<p>fn foo(x: &amp;’a i32, y: i32) → fn foo&lt;’a&gt;(x: &amp;’a i32, y: i32)</p>
</li>
</ul>
<h4 id="2-输出生命周期规则-针对函数或方法的返回值"><a href="#2-输出生命周期规则-针对函数或方法的返回值" class="headerlink" title="2. 输出生命周期规则 (针对函数或方法的返回值)"></a>2. 输出生命周期规则 (针对函数或方法的返回值)</h4><p><strong>规则：</strong> 如果函数或方只有一个输入生命周期参数**，那么这个唯一的输入生命周期参数会被赋给<strong>所有</strong>输出生命周期参数。</p>
<p><strong>例子：</strong></p>
<ul>
<li><p>考虑 first_word 函数：fn first_word&lt;’a&gt;(s: &amp;’a str) -&gt; &amp;str。</p>
<p>因为只有一个输入生命周期 ‘a，根据这条规则，返回值 &amp;str 也会被赋予 ‘a。</p>
<p>最终签名变为：fn first_word&lt;’a&gt;(s: &amp;’a str) -&gt; &amp;’a str。</p>
<p>这意味着 first_word 返回的引用和输入引用 s 具有相同的生命周期。</p>
</li>
</ul>
<h4 id="3-方法的输出生命周期规则-针对带有-self-或-mut-self-的方法"><a href="#3-方法的输出生命周期规则-针对带有-self-或-mut-self-的方法" class="headerlink" title="3. 方法的输出生命周期规则 (针对带有 &amp;self 或 &amp;mut self 的方法)"></a>3. 方法的输出生命周期规则 (针对带有 <code>&amp;self</code> 或 <code>&amp;mut self</code> 的方法)</h4><p><strong>规则：</strong> 如果方法有<strong>多个输入生命周期参数</strong>，并且其中一个参数是 <code>&amp;self</code> 或 <code>&amp;mut self</code>（即这是一个方法，而不是普通的函数），那么所有输出生命周期参数都被赋予 <code>self</code> 的生命周期。</p>
<p>例子：</p>
<p>假设有一个结构体 struct MyStruct&lt;’a&gt; { data: &amp;’a str }，以及它的一个方法：</p>
<p>impl&lt;’a&gt; MyStruct&lt;’a&gt; { fn get_data(&amp;self) -&gt; &amp;str { self.data } }</p>
<ul>
<li><p>应用第一条规则：fn get_data&lt;’b&gt;(&amp;’b self) -&gt; &amp;str</p>
<p>（注意，MyStruct 可能已经有自己的生命周期 ‘a，但 &amp;self 自身作为参数会获得一个新的生命周期 ‘b。实际上，Rust 会聪明地把 &amp;self 的生命周期和结构体本身的生命周期关联起来。）</p>
</li>
<li><p>由于有 &amp;self 参数，并且可能有其他输入生命周期（尽管在这个简单例子中没有），第三条规则适用。它会将 self 的生命周期赋给返回值。</p>
<p>最终签名（实际上是编译器推断出的）：fn get_data(&amp;’a self) -&gt; &amp;’a str</p>
<p>这意味着方法返回的引用和 self 实例的生命周期相同。 这对于对象方法来说非常方便，因为它们通常返回对自身数据的引用。</p>
</li>
</ul>
<h3 id="first-word-和-longest-函数的推断过程："><a href="#first-word-和-longest-函数的推断过程：" class="headerlink" title="first_word 和 longest 函数的推断过程："></a><code>first_word</code> 和 <code>longest</code> 函数的推断过程：</h3><h4 id="first-word-函数-示例-10-26"><a href="#first-word-函数-示例-10-26" class="headerlink" title="first_word 函数 (示例 10-26):"></a><code>first_word</code> 函数 (示例 10-26):</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fn first_word(s: &amp;str) -&gt; &amp;str</span><br></pre></td></tr></table></figure>

<ol>
<li><p>应用第一条规则： s: &amp;str 是一个引用参数，所以它获得自己的生命周期。</p>
<p>fn first_word&lt;’a&gt;(s: &amp;’a str) -&gt; &amp;str</p>
</li>
<li><p>应用第二条规则： 只有一个输入生命周期参数 (‘a)，所以它被赋给输出生命周期。</p>
<p>fn first_word&lt;’a&gt;(s: &amp;’a str) -&gt; &amp;’a str</p>
</li>
<li><p><strong>结果：</strong> 所有引用都有了明确的生命周期，编译器可以成功编译。</p>
</li>
</ol>
<h4 id="longest-函数-示例-10-21"><a href="#longest-函数-示例-10-21" class="headerlink" title="longest 函数 (示例 10-21):"></a><code>longest</code> 函数 (示例 10-21):</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fn longest(x: &amp;str, y: &amp;str) -&gt; &amp;str</span><br></pre></td></tr></table></figure>

<ol>
<li><p>应用第一条规则： x: &amp;str 和 y: &amp;str 都是引用参数，所以它们分别获得自己的生命周期。</p>
<p>fn longest&lt;’a, ‘b&gt;(x: &amp;’a str, y: &amp;’b str) -&gt; &amp;str</p>
</li>
<li><p><strong>应用第二条规则：</strong> 无法适用，因为有<strong>多个</strong>输入生命周期 (<code>&#39;a</code> 和 <code>&#39;b&#39;</code>)。</p>
</li>
<li><p><strong>应用第三条规则：</strong> 无法适用，因为这不是一个方法（没有 <code>&amp;self</code> 或 <code>&amp;mut self</code> 参数）。</p>
</li>
<li><p>结果： 编译器无法推断出返回值 &amp;str 的生命周期。它不知道返回的引用是和 ‘a 一样长寿，还是和 ‘b 一样长寿。这会导致一个编译错误，要求你手动添加生命周期注解，比如：</p>
<p>fn longest&lt;’a&gt;(x: &amp;’a str, y: &amp;’a str) -&gt; &amp;’a str （这表示返回的引用和 x、y 中生命周期较短的那个一样长）</p>
</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>生命周期省略规则极大地简化了 Rust 代码的编写，减少了不必要的生命周期注解，使得代码更加清晰易读。它们是编译器为了方便开发者而提供的“智能推断”，而非必须手动遵守的规则。当你遇到编译器报错提示生命周期不明确时，通常就是因为你的代码不符合这三条省略规则，你需要手动添加相应的生命周期注解来帮助编译器理解引用之间的关系。</p>
<h3 id="方法定义中的生命周期标注"><a href="#方法定义中的生命周期标注" class="headerlink" title="方法定义中的生命周期标注"></a><a target="_blank" rel="noopener" href="https://rustwiki.org/zh-CN/book/ch10-03-lifetime-syntax.html#%E6%96%B9%E6%B3%95%E5%AE%9A%E4%B9%89%E4%B8%AD%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%A0%87%E6%B3%A8">方法定义中的生命周期标注</a></h3><p>当为带有生命周期的结构体实现方法时，其语法依然类似示例 10-11 中展示的泛型类型参数的语法。声明和使用生命周期参数的位置依赖于生命周期参数是否同结构体字段或方法参数和返回值相关。</p>
<p>（实现方法时）结构体字段的生命周期必须总是在 <code>impl</code> 关键字之后声明并在结构体名称之后被使用，因为这些生命周期是结构体类型的一部分。</p>
<p><code>impl</code> 块里的方法签名中，引用可能与结构体字段中的引用相关联，也可能是独立的。另外，生命周期省略规则也经常让我们无需在方法签名中使用生命周期标注。让我们看看一些使用示例 10-25 中定义的结构体 <code>ImportantExcerpt</code> 的例子。</p>
<p>首先，这里有一个方法 <code>level</code>。其唯一的参数是 <code>self</code> 的引用，而且返回值只是一个 <code>i32</code>，并不引用任何值：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;<span class="symbol">&#x27;a</span>&gt; ImportantExcerpt&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">level</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">        <span class="number">3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>impl</code> 之后和类型名称之后的生命周期参数是必要的，不过因为第一条生命周期规则我们并不必须标注 <code>self</code> 引用的生命周期。</p>
<p>这里是一个适用于第三条生命周期省略规则的例子：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;<span class="symbol">&#x27;a</span>&gt; ImportantExcerpt&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">announce_and_return_part</span>(&amp;<span class="keyword">self</span>, announcement: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">str</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Attention please: &#123;&#125;&quot;</span>, announcement);</span><br><span class="line">        <span class="keyword">self</span>.part</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里有两个输入生命周期，所以 Rust 应用第一条生命周期省略规则并给予 <code>&amp;self</code> 和 <code>announcement</code> 他们各自的生命周期。接着，因为其中一个参数是 <code>&amp;self</code>，返回值类型被赋予了 <code>&amp;self</code> 的生命周期，这样所有的生命周期都被计算出来了。</p>
<h3 id="静态生命周期"><a href="#静态生命周期" class="headerlink" title="静态生命周期"></a><a target="_blank" rel="noopener" href="https://rustwiki.org/zh-CN/book/ch10-03-lifetime-syntax.html#%E9%9D%99%E6%80%81%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F">静态生命周期</a></h3><p>这里有一种特殊的生命周期值得讨论：<code>&#39;static</code>，其生命周期<strong>能够</strong>存活于整个程序期间。所有的字符串字面量都拥有 <code>&#39;static</code> 生命周期，我们也可以选择像下面这样标注出来：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span>: &amp;<span class="symbol">&#x27;static</span> <span class="type">str</span> = <span class="string">&quot;I have a static lifetime.&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>这个字符串的文本被直接储存在程序的二进制文件中而这个文件总是可用的。因此所有的字符串字面量都是 <code>&#39;static</code> 的。</p>
<p>你可能在错误信息的帮助文本中见过使用 <code>&#39;static</code> 生命周期的建议，不过将引用指定为 <code>&#39;static</code> 之前，思考一下这个引用是否真的在整个程序的生命周期里都有效。你也许要考虑是否希望它存在得这么久，即使这是可能的。大部分情况，代码中的问题是尝试创建一个悬垂引用或者可用的生命周期不匹配，请解决这些问题而不是指定一个 <code>&#39;static</code> 的生命周期。</p>
<h3 id="结合泛型类型参数、trait-bounds-和生命周期"><a href="#结合泛型类型参数、trait-bounds-和生命周期" class="headerlink" title="结合泛型类型参数、trait bounds 和生命周期"></a><a target="_blank" rel="noopener" href="https://rustwiki.org/zh-CN/book/ch10-03-lifetime-syntax.html#%E7%BB%93%E5%90%88%E6%B3%9B%E5%9E%8B%E7%B1%BB%E5%9E%8B%E5%8F%82%E6%95%B0trait-bounds-%E5%92%8C%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F">结合泛型类型参数、trait bounds 和生命周期</a></h3><p>让我们简要的看一下在同一函数中指定泛型类型参数、trait bounds 和生命周期的语法！</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fmt::Display;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">longest_with_an_announcement</span>&lt;<span class="symbol">&#x27;a</span>, T&gt;(x: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>, y: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>, ann: T) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span></span><br><span class="line">    <span class="keyword">where</span> T: Display</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Announcement! &#123;&#125;&quot;</span>, ann);</span><br><span class="line">    <span class="keyword">if</span> x.<span class="title function_ invoke__">len</span>() &gt; y.<span class="title function_ invoke__">len</span>() &#123;</span><br><span class="line">        x</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个是示例 10-22 中那个返回两个字符串 slice 中较长者的 <code>longest</code> 函数，不过带有一个额外的参数 <code>ann</code>。<code>ann</code> 的类型是泛型 <code>T</code>，它可以被放入任何实现了 <code>where</code> 从句中指定的 <code>Display</code> trait 的类型。这个额外的参数会在函数比较字符串 slice 的长度之前被打印出来，这也就是为什么 <code>Display</code> trait bound 是必须的。因为生命周期也是泛型，所以生命周期参数 <code>&#39;a</code> 和泛型类型参数 <code>T</code> 都位于函数名后的同一尖括号列表中。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/07/30/RT-Rhread%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0%E4%B9%8B%E7%BA%BF%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.png">
      <meta itemprop="name" content="Chillward">
      <meta itemprop="description" content="谁躺在漆黑的舞台上，用身体迎接着光芒">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chillward的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/07/30/RT-Rhread%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0%E4%B9%8B%E7%BA%BF%E7%A8%8B/" class="post-title-link" itemprop="url">RT-Rhread学习日记之线程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-07-30 09:34:10" itemprop="dateCreated datePublished" datetime="2025-07-30T09:34:10+08:00">2025-07-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-08-01 16:58:42" itemprop="dateModified" datetime="2025-08-01T16:58:42+08:00">2025-08-01</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>16k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>29 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>在之前的STM32开发过程中，我一直是使用裸机开发，裸机开发对MCU性能占用低，但是不够灵活，没法真正意义上实现并行，就算实现了简单的调度器，也是非阻塞式的，不够好用。</p>
</blockquote>
<h2 id="线程管理的功能特点"><a href="#线程管理的功能特点" class="headerlink" title="线程管理的功能特点"></a>线程管理的功能特点</h2><p>RT-Thread 线程管理的主要功能是对线程进行管理和调度，系统中总共存在两类线程，分别是系统线程和用户线程，系统线程是由 RT-Thread 内核创建的线程，用户线程是由应用程序创建的线程，这两类线程都会从内核对象容器中分配线程对象，当线程被删除时，也会被从对象容器中删除，如下图所示，每个线程都有重要的属性，如线程控制块、线程栈、入口函数等。</p>
<p><img data-src="C:\Users\WSXd_s\AppData\Roaming\Typora\typora-user-images\image-20250730222612572.png" alt="image-20250730222612572"></p>
<p>RT-Thread 的线程调度器是抢占式的，主要的工作就是从就绪线程列表中查找最高优先级线程，保证最高优先级的线程能够被运行，最高优先级的任务一旦就绪，总能得到 CPU 的使用权。</p>
<p>当一个运行着的线程使一个比它优先级高的线程满足运行条件，当前线程的 CPU 使用权就被剥夺了，或者说被让出了，高优先级的线程立刻得到了 CPU 的使用权。</p>
<p>如果是中断服务程序使一个高优先级的线程满足运行条件，中断完成时，被中断的线程挂起，优先级高的线程开始运行。</p>
<p>当调度器调度线程切换时，先将当前线程上下文保存起来，当再切回到这个线程时，线程调度器将该线程的上下文信息恢复。</p>
<h2 id="线程的工作机制"><a href="#线程的工作机制" class="headerlink" title="线程的工作机制"></a><a target="_blank" rel="noopener" href="https://www.rt-thread.org/document/site/#/rt-thread-version/rt-thread-standard/programming-manual/thread/thread?id=%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6">线程的工作机制</a></h2><h3 id="线程控制块"><a href="#线程控制块" class="headerlink" title="线程控制块"></a><a target="_blank" rel="noopener" href="https://www.rt-thread.org/document/site/#/rt-thread-version/rt-thread-standard/programming-manual/thread/thread?id=%E7%BA%BF%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%9D%97">线程控制块</a></h3><p>在 RT-Thread 中，线程控制块由结构体 struct rt_thread 表示，线程控制块是操作系统用于管理线程的一个数据结构，它会存放线程的一些信息，例如优先级、线程名称、线程状态等，也包含线程与线程之间连接用的链表结构，线程等待事件集合等，详细定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 线程控制块 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rt_thread</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">/* rt 对象 */</span></span><br><span class="line">    <span class="type">char</span>        name[RT_NAME_MAX];     <span class="comment">/* 线程名称 */</span></span><br><span class="line">    <span class="type">rt_uint8_t</span>  type;                   <span class="comment">/* 对象类型 */</span></span><br><span class="line">    <span class="type">rt_uint8_t</span>  flags;                  <span class="comment">/* 标志位 */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">rt_list_t</span>   <span class="built_in">list</span>;                   <span class="comment">/* 对象列表 */</span></span><br><span class="line">    <span class="type">rt_list_t</span>   tlist;                  <span class="comment">/* 线程列表 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 栈指针与入口指针 */</span></span><br><span class="line">    <span class="type">void</span>       *sp;                      <span class="comment">/* 栈指针 */</span></span><br><span class="line">    <span class="type">void</span>       *entry;                   <span class="comment">/* 入口函数指针 */</span></span><br><span class="line">    <span class="type">void</span>       *parameter;              <span class="comment">/* 参数 */</span></span><br><span class="line">    <span class="type">void</span>       *stack_addr;             <span class="comment">/* 栈地址指针 */</span></span><br><span class="line">    <span class="type">rt_uint32_t</span> stack_size;            <span class="comment">/* 栈大小 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 错误代码 */</span></span><br><span class="line">    <span class="type">rt_err_t</span>    error;                  <span class="comment">/* 线程错误代码 */</span></span><br><span class="line">    <span class="type">rt_uint8_t</span>  stat;                   <span class="comment">/* 线程状态 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 优先级 */</span></span><br><span class="line">    <span class="type">rt_uint8_t</span>  current_priority;    <span class="comment">/* 当前优先级 */</span></span><br><span class="line">    <span class="type">rt_uint8_t</span>  init_priority;        <span class="comment">/* 初始优先级 */</span></span><br><span class="line">    <span class="type">rt_uint32_t</span> number_mask;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="type">rt_ubase_t</span>  init_tick;               <span class="comment">/* 线程初始化计数值 */</span></span><br><span class="line">    <span class="type">rt_ubase_t</span>  remaining_tick;         <span class="comment">/* 线程剩余计数值 */</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_timer</span> <span class="title">thread_timer</span>;</span>      <span class="comment">/* 内置线程定时器 */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> (*cleanup)(<span class="keyword">struct</span> rt_thread *tid);  <span class="comment">/* 线程退出清除函数 */</span></span><br><span class="line">    <span class="type">rt_uint32_t</span> user_data;                      <span class="comment">/* 用户数据 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中 init_priority 是线程创建时指定的线程优先级，在线程运行过程当中是不会被改变的（除非用户执行线程控制函数进行手动调整线程优先级）。cleanup 会在线程退出时，被空闲线程回调一次以执行用户设置的清理现场等工作。最后的一个成员 user_data 可由用户挂接一些数据信息到线程控制块中，以提供一种类似线程私有数据的实现方式。</p>
<h3 id="线程重要属性"><a href="#线程重要属性" class="headerlink" title="线程重要属性"></a><a target="_blank" rel="noopener" href="https://www.rt-thread.org/document/site/#/rt-thread-version/rt-thread-standard/programming-manual/thread/thread?id=%E7%BA%BF%E7%A8%8B%E9%87%8D%E8%A6%81%E5%B1%9E%E6%80%A7">线程重要属性</a></h3><h4 id="线程栈"><a href="#线程栈" class="headerlink" title="线程栈"></a><a target="_blank" rel="noopener" href="https://www.rt-thread.org/document/site/#/rt-thread-version/rt-thread-standard/programming-manual/thread/thread?id=%E7%BA%BF%E7%A8%8B%E6%A0%88">线程栈</a></h4><p>RT-Thread 线程具有独立的栈，当进行线程切换时，会将当前线程的上下文存在栈中，当线程要恢复运行时，再从栈中读取上下文信息，进行恢复。</p>
<p>线程栈还用来存放函数中的局部变量：函数中的局部变量从线程栈空间中申请；函数中局部变量初始时从寄存器中分配（ARM 架构），当这个函数再调用另一个函数时，这些局部变量将放入栈中。</p>
<p>对于线程第一次运行，可以以手工的方式构造这个上下文来设置一些初始的环境：入口函数（PC 寄存器）、入口参数（R0 寄存器）、返回位置（LR 寄存器）、当前机器运行状态（CPSR 寄存器）。</p>
<p>线程栈的增长方向是芯片构架密切相关的，RT-Thread 3.1.0 以前的版本，均只支持栈由高地址向低地址增长的方式，对于 ARM Cortex-M 架构，线程栈可构造如下图所示。</p>
<p><img data-src="C:\Users\WSXd_s\AppData\Roaming\Typora\typora-user-images\image-20250730223159009.png" alt="image-20250730223159009"></p>
<p>线程栈大小可以这样设定，对于资源相对较大的 MCU，可以适当设计较大的线程栈；也可以在初始时设置较大的栈，例如指定大小为 1K 或 2K 字节，然后在 FinSH 中用 list_thread 命令查看线程运行的过程中线程所使用的栈的大小，通过此命令，能够看到从线程启动运行时，到当前时刻点，线程使用的最大栈深度，而后加上适当的余量形成最终的线程栈大小，最后对栈空间大小加以修改。</p>
<blockquote>
<p>关于FinSH，ai给了以下解释</p>
</blockquote>
<hr>
<p>FinSH 是 RT-Thread 实时操作系统中一个非常有用的<strong>命令行调试组件</strong>。你可以把它想象成嵌入式设备上的一个<strong>交互式命令行终端</strong>。</p>
<h3 id="FinSH-是什么？"><a href="#FinSH-是什么？" class="headerlink" title="FinSH 是什么？"></a>FinSH 是什么？</h3><p>在 RT-Thread 中，FinSH（或者更常被称为 <strong>FinSH 控制台</strong>或 <strong>FinSH Shell</strong>）提供了一个与运行在微控制器上的 RT-Thread 系统进行交互的接口。通过这个接口，开发者可以在运行时执行各种命令，查询系统状态，调试程序，甚至调用应用程序中的函数。</p>
<p>就像你在电脑上使用命令提示符（Windows 的 CMD 或 PowerShell）或终端（Linux&#x2F;macOS 的 Bash）一样，FinSH 让你能够通过串口（通常是 UART）或其他通信接口，向运行在 MCU 上的 RT-Thread 系统发送命令并接收输出。</p>
<h3 id="FinSH-的主要功能和作用"><a href="#FinSH-的主要功能和作用" class="headerlink" title="FinSH 的主要功能和作用"></a>FinSH 的主要功能和作用</h3><ol>
<li><strong>系统信息查询：</strong><ul>
<li><strong><code>list_thread</code></strong>: 正如你提到的，这是 FinSH 最常用的命令之一。它可以列出系统中所有线程的信息，包括线程名、状态、优先级、<strong>当前已使用的栈大小</strong>以及<strong>历史最大栈深度</strong>等。这对于调试线程栈溢出问题和优化栈空间非常关键。</li>
<li><code>list_mem</code>: 查看内存使用情况。</li>
<li><code>list_sem</code>: 查看信号量信息。</li>
<li><code>list_mq</code>: 查看消息队列信息。</li>
<li><code>version</code>: 查看 RT-Thread 版本信息。</li>
</ul>
</li>
<li><strong>动态调试：</strong><ul>
<li><strong>线程管理：</strong> 可以暂停、恢复、启动或停止线程。</li>
<li><strong>变量&#x2F;内存查看：</strong> 某些 FinSH 配置允许你查看或修改内存地址上的值。</li>
</ul>
</li>
<li><strong>函数调用：</strong><ul>
<li>FinSH 支持注册 C&#x2F;C++ 函数，然后可以直接在命令行中调用这些函数。这对于测试特定的功能模块或者改变程序运行时的一些参数非常方便，无需重新编译和烧录固件。</li>
</ul>
</li>
<li><strong>文件系统操作：</strong><ul>
<li>如果 RT-Thread 配置了文件系统（如 DFS），FinSH 可以用来执行文件操作命令，比如 <code>ls</code> (列出文件)、<code>cd</code> (切换目录)、<code>mkdir</code> (创建目录)、<code>rm</code> (删除文件) 等。</li>
</ul>
</li>
<li><strong>设备操作：</strong><ul>
<li>可以查看或控制通过 RT-Thread 设备框架注册的设备。</li>
</ul>
</li>
</ol>
<h3 id="为什么-FinSH-对线程栈大小设定很重要？"><a href="#为什么-FinSH-对线程栈大小设定很重要？" class="headerlink" title="为什么 FinSH 对线程栈大小设定很重要？"></a>为什么 FinSH 对线程栈大小设定很重要？</h3><p>你引用的这段话，恰恰说明了 FinSH 在<strong>线程栈大小优化</strong>中的关键作用：</p>
<ol>
<li><strong>初始设定：</strong> 在开发初期，你可能对每个线程需要多少栈空间没有准确概念，所以会设置一个相对宽松（大一些）的值，例如 1KB 或 2KB。</li>
<li><strong>运行时监测：</strong> 当程序在实际环境中运行一段时间后，通过 FinSH 的 <code>list_thread</code> 命令，你可以精确地看到每个线程在运行过程中<strong>实际使用过的最大栈深度</strong>。这个值非常重要，因为它反映了线程在最“忙碌”或调用链最深时的栈使用情况。</li>
<li><strong>优化与调整：</strong> 根据 <code>list_thread</code> 报告的最大栈深度，你可以为线程栈添加一个适当的余量（通常是 10%~20% 或一个固定大小），然后将线程栈大小调整为这个更精确的值。这样既可以避免栈溢出（如果初始值太小），又能节省宝贵的 RAM 资源（如果初始值太大）。</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>所以，FinSH 就是 RT-Thread 的一个<strong>交互式控制台工具</strong>，它让你能够在不重新烧录固件的情况下，深入了解和控制运行中的嵌入式系统。对于<strong>调试线程栈大小</strong>这样的内存优化任务，<code>list_thread</code> 命令通过提供线程的历史最大栈深度，成为了不可或缺的利器。</p>
<h4 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a><a target="_blank" rel="noopener" href="https://www.rt-thread.org/document/site/#/rt-thread-version/rt-thread-standard/programming-manual/thread/thread?id=%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81">线程状态</a></h4><p>线程运行的过程中，同一时间内只允许一个线程在处理器中运行，从运行的过程上划分，线程有多种不同的运行状态，如初始状态、挂起状态、就绪状态等。在 RT-Thread 中，线程包含五种状态，操作系统会自动根据它运行的情况来动态调整它的状态。 RT-Thread 中线程的五种状态，如下表所示：</p>
<table>
<thead>
<tr>
<th>状态</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>初始状态</td>
<td>当线程刚开始创建还没开始运行时就处于初始状态；在初始状态下，线程不参与调度。此状态在 RT-Thread 中的宏定义为 RT_THREAD_INIT</td>
</tr>
<tr>
<td>就绪状态</td>
<td>在就绪状态下，线程按照优先级排队，等待被执行；一旦当前线程运行完毕让出处理器，操作系统会马上寻找最高优先级的就绪态线程运行。此状态在 RT-Thread 中的宏定义为 RT_THREAD_READY</td>
</tr>
<tr>
<td>运行状态</td>
<td>线程当前正在运行。在单核系统中，只有 rt_thread_self() 函数返回的线程处于运行状态；在多核系统中，可能就不止这一个线程处于运行状态。此状态在 RT-Thread 中的宏定义为 RT_THREAD_RUNNING</td>
</tr>
<tr>
<td>挂起状态</td>
<td>也称阻塞态。它可能因为资源不可用而挂起等待，或线程主动延时一段时间而挂起。在挂起状态下，线程不参与调度。此状态在 RT-Thread 中的宏定义为 RT_THREAD_SUSPEND</td>
</tr>
<tr>
<td>关闭状态</td>
<td>当线程运行结束时将处于关闭状态。关闭状态的线程不参与线程的调度。此状态在 RT-Thread 中的宏定义为 RT_THREAD_CLOSE</td>
</tr>
</tbody></table>
<h4 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a><a target="_blank" rel="noopener" href="https://www.rt-thread.org/document/site/#/rt-thread-version/rt-thread-standard/programming-manual/thread/thread?id=%E7%BA%BF%E7%A8%8B%E4%BC%98%E5%85%88%E7%BA%A7">线程优先级</a></h4><p>RT-Thread 线程的优先级是表示线程被调度的优先程度。每个线程都具有优先级，线程越重要，赋予的优先级就应越高，线程被调度的可能才会越大。</p>
<p>RT-Thread 最大支持 256 个线程优先级 (0~255)，数值越小的优先级越高，0 为最高优先级。在一些资源比较紧张的系统中，可以根据实际情况选择只支持 8 个或 32 个优先级的系统配置；对于 ARM Cortex-M 系列，普遍采用 32 个优先级。最低优先级默认分配给空闲线程使用，用户一般不使用。在系统中，当有比当前线程优先级更高的线程就绪时，当前线程将立刻被换出，高优先级线程抢占处理器运行。</p>
<h4 id="时间片"><a href="#时间片" class="headerlink" title="时间片"></a><a target="_blank" rel="noopener" href="https://www.rt-thread.org/document/site/#/rt-thread-version/rt-thread-standard/programming-manual/thread/thread?id=%E6%97%B6%E9%97%B4%E7%89%87">时间片</a></h4><p>每个线程都有时间片这个参数，但时间片仅对优先级相同的就绪态线程有效。系统对优先级相同的就绪态线程采用时间片轮转的调度方式进行调度时，时间片起到约束线程单次运行时长的作用，其单位是一个系统节拍（OS Tick），详见《时钟管理》章节。假设有 2 个优先级相同的就绪态线程 A 与 B，A 线程的时间片设置为 10，B 线程的时间片设置为 5，那么当系统中不存在比 A 优先级高的就绪态线程时，系统会在 A、B 线程间来回切换执行，并且每次对 A 线程执行 10 个节拍的时长，对 B 线程执行 5 个节拍的时长。</p>
<blockquote>
<p>这个时间节拍应该是来自于SysTick这个外设</p>
</blockquote>
<h4 id="线程的入口函数"><a href="#线程的入口函数" class="headerlink" title="线程的入口函数"></a><a target="_blank" rel="noopener" href="https://www.rt-thread.org/document/site/#/rt-thread-version/rt-thread-standard/programming-manual/thread/thread?id=%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%85%A5%E5%8F%A3%E5%87%BD%E6%95%B0">线程的入口函数</a></h4><p>线程控制块中的 entry 是线程的入口函数，它是线程实现预期功能的函数。线程的入口函数由用户设计实现，一般有以下两种代码形式：</p>
<p>-<strong>无限循环模式：</strong></p>
<p>在实时系统中，线程通常是被动式的：这个是由实时系统的特性所决定的，实时系统通常总是等待外界事件的发生，而后进行相应的服务：</p>
<blockquote>
<p>大概就是你这个函数的执行完全是由操作系统来决定的，所以内部的while(1)循环并不会真的一直执行下去</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">thread_entry</span><span class="params">(<span class="type">void</span>* paramenter)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="comment">/* 等待事件的发生 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 对事件进行服务、进行处理 */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;复制错误复制成功</span><br></pre></td></tr></table></figure>

<p>线程看似没有什么限制程序执行的因素，似乎所有的操作都可以执行。但是作为一个实时系统，一个优先级明确的实时系统，如果一个线程中的程序陷入了死循环操作，那么比它优先级低的线程都将不能够得到执行。所以在实时操作系统中必须注意的一点就是：线程中不能陷入死循环操作，**必须要有让出 CPU 使用权的动作，如循环中调用延时函数或者主动挂起。**用户设计这种无限循环的线程的目的，就是为了让这个线程一直被系统循环调度运行，永不删除。</p>
<p>-<strong>顺序执行或有限次循环模式：</strong></p>
<p>如简单的顺序语句、do while() 或 for()循环等，此类线程不会循环或不会永久循环，可谓是 “一次性” 线程，一定会被执行完毕。在执行完毕后，线程将被系统自动删除。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">thread_entry</span><span class="params">(<span class="type">void</span>* parameter)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 处理事务 #1 */</span></span><br><span class="line">    …</span><br><span class="line">    <span class="comment">/* 处理事务 #2 */</span></span><br><span class="line">    …</span><br><span class="line">    <span class="comment">/* 处理事务 #3 */</span></span><br><span class="line">&#125;复制错误复制成功</span><br></pre></td></tr></table></figure>

<h4 id="线程错误码"><a href="#线程错误码" class="headerlink" title="线程错误码"></a><a target="_blank" rel="noopener" href="https://www.rt-thread.org/document/site/#/rt-thread-version/rt-thread-standard/programming-manual/thread/thread?id=%E7%BA%BF%E7%A8%8B%E9%94%99%E8%AF%AF%E7%A0%81">线程错误码</a></h4><p>一个线程就是一个执行场景，错误码是与执行环境密切相关的，所以每个线程配备了一个变量用于保存错误码，线程的错误码有以下几种：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> RT_EOK           0 <span class="comment">/* 无错误     */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RT_ERROR         1 <span class="comment">/* 普通错误     */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RT_ETIMEOUT      2 <span class="comment">/* 超时错误     */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RT_EFULL         3 <span class="comment">/* 资源已满     */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RT_EEMPTY        4 <span class="comment">/* 无资源     */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RT_ENOMEM        5 <span class="comment">/* 无内存     */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RT_ENOSYS        6 <span class="comment">/* 系统不支持     */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RT_EBUSY         7 <span class="comment">/* 系统忙     */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RT_EIO           8 <span class="comment">/* IO 错误       */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RT_EINTR         9 <span class="comment">/* 中断系统调用   */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RT_EINVAL       10 <span class="comment">/* 非法参数      */</span></span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>C语言的错误处理还是相对原始，也没有Rust那种传递错误之类的特性，目前来看Rt-Thread也是通过返回错误码来解决错误处理的</p>
</blockquote>
<h2 id="线程状态切换"><a href="#线程状态切换" class="headerlink" title="线程状态切换"></a>线程状态切换</h2><p><img data-src="C:\Users\WSXd_s\AppData\Roaming\Typora\typora-user-images\image-20250730224231420.png" alt="image-20250730224231420"></p>
<p>Rt-Thread提供了一系列函数供线程使用</p>
<p>线程通过调用函数 rt_thread_create&#x2F;init() 进入到初始状态（RT_THREAD_INIT）；初始状态的线程通过调用函数 rt_thread_startup() 进入到就绪状态（RT_THREAD_READY）；就绪状态的线程被调度器调度后进入运行状态（RT_THREAD_RUNNING）；当处于运行状态的线程调用 rt_thread_delay()，rt_sem_take()，rt_mutex_take()，rt_mb_recv() 等函数或者获取不到资源时，将进入到挂起状态（RT_THREAD_SUSPEND）；处于挂起状态的线程，如果等待超时依然未能获得资源或由于其他线程释放了资源，那么它将返回到就绪状态。挂起状态的线程，如果调用 rt_thread_delete&#x2F;detach() 函数，将更改为关闭状态（RT_THREAD_CLOSE）；而运行状态的线程，如果运行结束，就会在线程的最后部分执行 rt_thread_exit() 函数，将状态更改为关闭状态。</p>
<h3 id="系统线程"><a href="#系统线程" class="headerlink" title="系统线程"></a><a target="_blank" rel="noopener" href="https://www.rt-thread.org/document/site/#/rt-thread-version/rt-thread-standard/programming-manual/thread/thread?id=%E7%B3%BB%E7%BB%9F%E7%BA%BF%E7%A8%8B">系统线程</a></h3><p>前文中已提到，系统线程是指由系统创建的线程，用户线程是由用户程序调用线程管理接口创建的线程，在 RT-Thread 内核中的系统线程有空闲线程和主线程。</p>
<h4 id="空闲线程"><a href="#空闲线程" class="headerlink" title="空闲线程"></a><a target="_blank" rel="noopener" href="https://www.rt-thread.org/document/site/#/rt-thread-version/rt-thread-standard/programming-manual/thread/thread?id=%E7%A9%BA%E9%97%B2%E7%BA%BF%E7%A8%8B">空闲线程</a></h4><p>空闲线程（idle）是系统创建的最低优先级的线程，线程状态永远为就绪态。当系统中无其他就绪线程存在时，调度器将调度到空闲线程，它通常是一个死循环，且永远不能被挂起。另外，空闲线程在 RT-Thread 也有着它的特殊用途：</p>
<p>若某线程运行完毕，系统将自动删除线程：自动执行 rt_thread_exit() 函数，先将该线程从系统就绪队列中删除，再将该线程的状态更改为关闭状态，不再参与系统调度，然后挂入 rt_thread_defunct 僵尸队列（资源未回收、处于关闭状态的线程队列）中，最后空闲线程会回收被删除线程的资源。</p>
<p>空闲线程也提供了接口来运行用户设置的钩子函数，在空闲线程运行时会调用该钩子函数，适合处理功耗管理、看门狗喂狗等工作。空闲线程必须有得到执行的机会，即其他线程不允许一直while(1)死卡，必须调用具有阻塞性质的函数；否则例如线程删除、回收等操作将无法得到正确执行。</p>
<h4 id="主线程"><a href="#主线程" class="headerlink" title="主线程"></a><a target="_blank" rel="noopener" href="https://www.rt-thread.org/document/site/#/rt-thread-version/rt-thread-standard/programming-manual/thread/thread?id=%E4%B8%BB%E7%BA%BF%E7%A8%8B">主线程</a></h4><p>在系统启动时，系统会创建 main 线程，它的入口函数为 main_thread_entry()，用户的应用入口函数 main() 就是从这里真正开始的，系统调度器启动后，main 线程就开始运行，过程如下图，用户可以在 main() 函数里添加自己的应用程序初始化代码。</p>
<p><img data-src="C:\Users\WSXd_s\AppData\Roaming\Typora\typora-user-images\image-20250730225228737.png" alt="image-20250730225228737"></p>
<h2 id="线程的管理方式"><a href="#线程的管理方式" class="headerlink" title="线程的管理方式"></a><a target="_blank" rel="noopener" href="https://www.rt-thread.org/document/site/#/rt-thread-version/rt-thread-standard/programming-manual/thread/thread?id=%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F">线程的管理方式</a></h2><p>本章前面 2 节对线程的功能与工作机制进行了概念上的讲解，相信大家对线程已经不再陌生。本节将深入到 RT-Thread 线程的各个接口，并给出部分源码，帮助读者在代码层次上理解线程。</p>
<p>下图描述了线程的相关操作，包含：创建 &#x2F; 初始化线程、启动线程、运行线程、删除 &#x2F; 脱离线程。可以使用 rt_thread_create() 创建一个动态线程，使用 rt_thread_init() 初始化一个静态线程，动态线程与静态线程的区别是：动态线程是系统自动从动态内存堆上分配栈空间与线程句柄（初始化 heap 之后才能使用 create 创建动态线程），静态线程是由用户分配栈空间与线程句柄。</p>
<blockquote>
<p>类似于在普通windows上拿C语言写东西时，直接声明使用的变量在栈上，通过malloc申请出来的内存空间在堆上</p>
</blockquote>
<p><img data-src="https://www.rt-thread.org/document/site/rt-thread-version/rt-thread-standard/programming-manual/thread/figures/04thread_ops.png" alt="线程相关操作"></p>
<h3 id="创建和删除线程"><a href="#创建和删除线程" class="headerlink" title="创建和删除线程"></a><a target="_blank" rel="noopener" href="https://www.rt-thread.org/document/site/#/rt-thread-version/rt-thread-standard/programming-manual/thread/thread?id=%E5%88%9B%E5%BB%BA%E5%92%8C%E5%88%A0%E9%99%A4%E7%BA%BF%E7%A8%8B">创建和删除线程</a></h3><p>一个线程要成为可执行的对象，就必须由操作系统的内核来为它创建一个线程。可以通过如下的接口创建一个动态线程：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">rt_thread_t</span> <span class="title function_">rt_thread_create</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* name,</span></span><br><span class="line"><span class="params">                            <span class="type">void</span> (*entry)(<span class="type">void</span>* parameter),</span></span><br><span class="line"><span class="params">                            <span class="type">void</span>* parameter,</span></span><br><span class="line"><span class="params">                            <span class="type">rt_uint32_t</span> stack_size,</span></span><br><span class="line"><span class="params">                            <span class="type">rt_uint8_t</span> priority,</span></span><br><span class="line"><span class="params">                            <span class="type">rt_uint32_t</span> tick)</span>;</span><br></pre></td></tr></table></figure>

<p>调用这个函数时，系统会从动态堆内存中分配一个线程句柄以及按照参数中指定的栈大小从动态堆内存中分配相应的空间。分配出来的栈空间是按照 rtconfig.h 中配置的 RT_ALIGN_SIZE 方式对齐。线程创建 rt_thread_create() 的参数和返回值见下表：</p>
<table>
<thead>
<tr>
<th><strong>参数</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>name</td>
<td>线程的名称；线程名称的最大长度由 rtconfig.h 中的宏 RT_NAME_MAX 指定，多余部分会被自动截掉</td>
</tr>
<tr>
<td>entry</td>
<td>线程入口函数</td>
</tr>
<tr>
<td>parameter</td>
<td>线程入口函数参数</td>
</tr>
<tr>
<td>stack_size</td>
<td>线程栈大小，单位是字节</td>
</tr>
<tr>
<td>priority</td>
<td>线程的优先级。优先级范围根据系统配置情况（rtconfig.h 中的 RT_THREAD_PRIORITY_MAX 宏定义），如果支持的是 256 级优先级，那么范围是从 0~255，数值越小优先级越高，0 代表最高优先级</td>
</tr>
<tr>
<td>tick</td>
<td>线程的时间片大小。时间片（tick）的单位是操作系统的时钟节拍。当系统中存在相同优先级线程时，这个参数指定线程一次调度能够运行的最大时间长度。这个时间片运行结束时，调度器自动选择下一个就绪态的同优先级线程进行运行</td>
</tr>
<tr>
<td><strong>返回</strong></td>
<td>——</td>
</tr>
<tr>
<td>thread</td>
<td>线程创建成功，返回线程句柄</td>
</tr>
<tr>
<td>RT_NULL</td>
<td>线程创建失败</td>
</tr>
</tbody></table>
<blockquote>
<p>对于栈空间，Ai给了我如下解释</p>
</blockquote>
<p>虽然动态线程的内存（包括栈空间）是由系统从<strong>动态内存堆</strong>中分配的，但系统在分配时<strong>依然需要知道具体分配多大</strong>的栈空间。这个“多大”就是由 <code>stack_size</code> 参数来决定的。</p>
<p>可以这样理解：</p>
<ul>
<li><strong>动态线程：</strong> 你告诉系统“我需要创建一个线程，它的栈要这么大（<code>stack_size</code>）”。系统就会去动态内存堆上找一块足够大的内存来作为这个线程的栈。</li>
<li><strong>静态线程：</strong> 你自己预先准备好一块内存，然后告诉系统“这是我的线程，它的栈就在这里，大小是这么多（<code>stack_size</code>）”。</li>
</ul>
<p>所以，无论是动态线程还是静态线程，<strong><code>stack_size</code> 都是一个必不可少的参数</strong>，因为它定义了线程运行时的栈空间上限，以防止栈溢出并帮助系统进行资源管理。两者的区别仅在于这块栈内存是<strong>由谁来分配和管理</strong>：动态线程由系统动态分配，静态线程由用户静态分配。</p>
<p>对于一些使用 rt_thread_create() 创建出来的线程，当不需要使用，或者运行出错时，我们可以使用下面的函数接口来从系统中把线程完全删除掉：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">rt_err_t</span> <span class="title function_">rt_thread_delete</span><span class="params">(<span class="type">rt_thread_t</span> thread)</span>;复制错误复制成功</span><br></pre></td></tr></table></figure>

<p>调用该函数后，线程对象将会被移出线程队列并且从内核对象管理器中删除，线程占用的堆栈空间也会被释放，收回的空间将重新用于其他的内存分配。实际上，用 rt_thread_delete() 函数删除线程接口，仅仅是把相应的线程状态更改为 RT_THREAD_CLOSE 状态，然后放入到 rt_thread_defunct 队列中；而真正的删除动作（释放线程控制块和释放线程栈）需要到下一次执行空闲线程时，由空闲线程完成最后的线程删除动作。线程删除 rt_thread_delete() 接口的参数和返回值见下表：</p>
<table>
<thead>
<tr>
<th><strong>参数</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>thread</td>
<td>要删除的线程句柄</td>
</tr>
<tr>
<td><strong>返回</strong></td>
<td>——</td>
</tr>
<tr>
<td>RT_EOK</td>
<td>删除线程成功</td>
</tr>
<tr>
<td>-RT_ERROR</td>
<td>删除线程失败</td>
</tr>
</tbody></table>
<p>Note</p>
<blockquote>
<p> 注：rt_thread_create() 和 rt_thread_delete() 函数仅在使能了系统动态堆时才有效（即 RT_USING_HEAP 宏定义已经定义了）。</p>
</blockquote>
<h3 id="初始化和脱离线程"><a href="#初始化和脱离线程" class="headerlink" title="初始化和脱离线程"></a><a target="_blank" rel="noopener" href="https://www.rt-thread.org/document/site/#/rt-thread-version/rt-thread-standard/programming-manual/thread/thread?id=%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E8%84%B1%E7%A6%BB%E7%BA%BF%E7%A8%8B">初始化和脱离线程</a></h3><p>线程的初始化可以使用下面的函数接口完成，来初始化静态线程对象：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">rt_err_t</span> <span class="title function_">rt_thread_init</span><span class="params">(<span class="keyword">struct</span> rt_thread* thread,</span></span><br><span class="line"><span class="params">                        <span class="type">const</span> <span class="type">char</span>* name,</span></span><br><span class="line"><span class="params">                        <span class="type">void</span> (*entry)(<span class="type">void</span>* parameter), <span class="type">void</span>* parameter,</span></span><br><span class="line"><span class="params">                        <span class="type">void</span>* stack_start, <span class="type">rt_uint32_t</span> stack_size,</span></span><br><span class="line"><span class="params">                        <span class="type">rt_uint8_t</span> priority, <span class="type">rt_uint32_t</span> tick)</span>;复制错误复制成功</span><br></pre></td></tr></table></figure>

<p>静态线程的线程句柄（或者说线程控制块指针）、线程栈由用户提供。静态线程是指线程控制块、线程运行栈一般都设置为全局变量，在编译时就被确定、被分配处理，内核不负责动态分配内存空间。需要注意的是，用户提供的栈首地址需做系统对齐（例如 ARM 上需要做 4 字节对齐）。线程初始化接口 rt_thread_init() 的参数和返回值见下表：</p>
<table>
<thead>
<tr>
<th><strong>参数</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>thread</td>
<td>线程句柄。线程句柄由用户提供出来，并指向对应的线程控制块内存地址</td>
</tr>
<tr>
<td>name</td>
<td>线程的名称；线程名称的最大长度由 rtconfig.h 中定义的 RT_NAME_MAX 宏指定，多余部分会被自动截掉</td>
</tr>
<tr>
<td>entry</td>
<td>线程入口函数</td>
</tr>
<tr>
<td>parameter</td>
<td>线程入口函数参数</td>
</tr>
<tr>
<td>stack_start</td>
<td>线程栈起始地址</td>
</tr>
<tr>
<td>stack_size</td>
<td>线程栈大小，单位是字节。在大多数系统中需要做栈空间地址对齐（例如 ARM 体系结构中需要向 4 字节地址对齐）</td>
</tr>
<tr>
<td>priority</td>
<td>线程的优先级。优先级范围根据系统配置情况（rtconfig.h 中的 RT_THREAD_PRIORITY_MAX 宏定义），如果支持的是 256 级优先级，那么范围是从 0 ～ 255，数值越小优先级越高，0 代表最高优先级</td>
</tr>
<tr>
<td>tick</td>
<td>线程的时间片大小。时间片（tick）的单位是操作系统的时钟节拍。当系统中存在相同优先级线程时，这个参数指定线程一次调度能够运行的最大时间长度。这个时间片运行结束时，调度器自动选择下一个就绪态的同优先级线程进行运行</td>
</tr>
<tr>
<td><strong>返回</strong></td>
<td>——</td>
</tr>
<tr>
<td>RT_EOK</td>
<td>线程创建成功</td>
</tr>
<tr>
<td>-RT_ERROR</td>
<td>线程创建失败</td>
</tr>
</tbody></table>
<p>对于用 rt_thread_init() 初始化的线程，使用 rt_thread_detach() 将使线程对象在线程队列和内核对象管理器中被脱离。线程脱离函数如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">rt_err_t</span> <span class="title function_">rt_thread_detach</span> <span class="params">(<span class="type">rt_thread_t</span> thread)</span>;</span><br></pre></td></tr></table></figure>

<p>线程脱离接口 rt_thread_detach() 的参数和返回值见下表：</p>
<table>
<thead>
<tr>
<th><strong>参数</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>thread</td>
<td>线程句柄，它应该是由 rt_thread_init 进行初始化的线程句柄。</td>
</tr>
<tr>
<td><strong>返回</strong></td>
<td>——</td>
</tr>
<tr>
<td>RT_EOK</td>
<td>线程脱离成功</td>
</tr>
<tr>
<td>-RT_ERROR</td>
<td>线程脱离失败</td>
</tr>
</tbody></table>
<p>这个函数接口是和 rt_thread_delete() 函数相对应的， rt_thread_delete() 函数操作的对象是 rt_thread_create() 创建的句柄，而 rt_thread_detach() 函数操作的对象是使用 rt_thread_init() 函数初始化的线程控制块。同样，线程本身不应调用这个接口脱离线程本身。</p>
<blockquote>
<p>就是不能自己删自己的意思,剩下的明天再看吧，看不懂了</p>
</blockquote>
<h3 id="启动线程"><a href="#启动线程" class="headerlink" title="启动线程"></a><a target="_blank" rel="noopener" href="https://www.rt-thread.org/document/site/#/rt-thread-version/rt-thread-standard/programming-manual/thread/thread?id=%E5%90%AF%E5%8A%A8%E7%BA%BF%E7%A8%8B">启动线程</a></h3><p>创建（初始化）的线程状态处于初始状态，并未进入就绪线程的调度队列，我们可以在线程初始化 &#x2F; 创建成功后调用下面的函数接口让该线程进入就绪态：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">rt_err_t</span> <span class="title function_">rt_thread_startup</span><span class="params">(<span class="type">rt_thread_t</span> thread)</span>;复制错误复制成功</span><br></pre></td></tr></table></figure>

<p>当调用这个函数时，将把线程的状态更改为就绪状态，并放到相应优先级队列中等待调度。如果新启动的线程优先级比当前线程优先级高，将立刻切换到这个线程。线程启动接口 rt_thread_startup() 的参数和返回值见下表：</p>
<table>
<thead>
<tr>
<th><strong>参数</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>thread</td>
<td>线程句柄</td>
</tr>
<tr>
<td><strong>返回</strong></td>
<td>——</td>
</tr>
<tr>
<td>RT_EOK</td>
<td>线程启动成功</td>
</tr>
<tr>
<td>-RT_ERROR</td>
<td>线程启动失败</td>
</tr>
</tbody></table>
<h3 id="获得当前线程"><a href="#获得当前线程" class="headerlink" title="获得当前线程"></a><a target="_blank" rel="noopener" href="https://www.rt-thread.org/document/site/#/rt-thread-version/rt-thread-standard/programming-manual/thread/thread?id=%E8%8E%B7%E5%BE%97%E5%BD%93%E5%89%8D%E7%BA%BF%E7%A8%8B">获得当前线程</a></h3><p>在程序的运行过程中，相同的一段代码可能会被多个线程执行，在执行的时候可以通过下面的函数接口获得当前执行的线程句柄：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">rt_thread_t</span> <span class="title function_">rt_thread_self</span><span class="params">(<span class="type">void</span>)</span>;复制错误复制成功</span><br></pre></td></tr></table></figure>

<p>该接口的返回值见下表：</p>
<table>
<thead>
<tr>
<th><strong>返回</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>thread</td>
<td>当前运行的线程句柄</td>
</tr>
<tr>
<td>RT_NULL</td>
<td>失败，调度器还未启动</td>
</tr>
</tbody></table>
<h3 id="使线程让出处理器资源"><a href="#使线程让出处理器资源" class="headerlink" title="使线程让出处理器资源"></a><a target="_blank" rel="noopener" href="https://www.rt-thread.org/document/site/#/rt-thread-version/rt-thread-standard/programming-manual/thread/thread?id=%E4%BD%BF%E7%BA%BF%E7%A8%8B%E8%AE%A9%E5%87%BA%E5%A4%84%E7%90%86%E5%99%A8%E8%B5%84%E6%BA%90">使线程让出处理器资源</a></h3><p>当前线程的时间片用完或者该线程主动要求让出处理器资源时，它将不再占有处理器，调度器会选择相同优先级的下一个线程执行。线程调用这个接口后，这个线程仍然在就绪队列中。线程让出处理器使用下面的函数接口：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">rt_err_t</span> <span class="title function_">rt_thread_yield</span><span class="params">(<span class="type">void</span>)</span>;复制错误复制成功</span><br></pre></td></tr></table></figure>

<p>调用该函数后，当前线程会把自己挂到这个优先级队列链表的尾部，然后激活调度器进行线程上下文切换（如果当前优先级只有这一个线程，则这个线程继续执行，不进行上下文切换动作）。</p>
<p>rt_thread_yield() 函数和 rt_schedule() 函数比较相像，但有相同优先级的其他就绪态线程存在且没有更高优先级的线程存在时，系统的行为却完全不一样。执行 rt_thread_yield() 函数后，当前线程肯定会被换出，相同优先级的下一个就绪线程将被执行。而执行 rt_schedule() 函数后，当前线程并不一定被换出，即使被换出，也不会被放到就绪线程链表的尾部。</p>
<p>Note</p>
<p>注：rt_thread_yield()还做了上锁，修改当前线程状态的工作，最后调用了rt_schedule() 。rt_thread_yield()是面向用户的接口，rt_schedule()是内核实现调度的内部接口。一般情况下应调用rt_thread_yield()。</p>
<h3 id="使线程睡眠"><a href="#使线程睡眠" class="headerlink" title="使线程睡眠"></a><a target="_blank" rel="noopener" href="https://www.rt-thread.org/document/site/#/rt-thread-version/rt-thread-standard/programming-manual/thread/thread?id=%E4%BD%BF%E7%BA%BF%E7%A8%8B%E7%9D%A1%E7%9C%A0">使线程睡眠</a></h3><p>在实际应用中，我们有时需要让运行的当前线程延迟一段时间，在指定的时间到达后重新运行，这就叫做 “线程睡眠”。线程睡眠可使用以下三个函数接口：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">rt_err_t</span> <span class="title function_">rt_thread_sleep</span><span class="params">(<span class="type">rt_tick_t</span> tick)</span>;</span><br><span class="line"><span class="type">rt_err_t</span> <span class="title function_">rt_thread_delay</span><span class="params">(<span class="type">rt_tick_t</span> tick)</span>;</span><br><span class="line"><span class="type">rt_err_t</span> <span class="title function_">rt_thread_mdelay</span><span class="params">(<span class="type">rt_int32_t</span> ms)</span>;复制错误复制成功</span><br></pre></td></tr></table></figure>

<p>这三个函数接口的作用相同，调用它们可以使当前线程挂起一段指定的时间，当这个时间过后，线程会被唤醒并再次进入就绪状态。这个函数接受一个参数，该参数指定了线程的休眠时间。线程睡眠接口 rt_thread_sleep&#x2F;delay&#x2F;mdelay() 的参数和返回值见下表：</p>
<table>
<thead>
<tr>
<th><strong>参数</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>tick&#x2F;ms</td>
<td>线程睡眠的时间： sleep&#x2F;delay 的传入参数 tick 以 1 个 OS Tick 为单位 ； mdelay 的传入参数 ms 以 1ms 为单位；</td>
</tr>
<tr>
<td><strong>返回</strong></td>
<td>——</td>
</tr>
<tr>
<td>RT_EOK</td>
<td>操作成功</td>
</tr>
</tbody></table>
<h3 id="挂起和恢复线程"><a href="#挂起和恢复线程" class="headerlink" title="挂起和恢复线程"></a><a target="_blank" rel="noopener" href="https://www.rt-thread.org/document/site/#/rt-thread-version/rt-thread-standard/programming-manual/thread/thread?id=%E6%8C%82%E8%B5%B7%E5%92%8C%E6%81%A2%E5%A4%8D%E7%BA%BF%E7%A8%8B">挂起和恢复线程</a></h3><p>当线程调用 rt_thread_delay() 时，线程将主动挂起；当调用 rt_sem_take()，rt_mb_recv() 等函数时，资源不可使用也将导致线程挂起。处于挂起状态的线程，如果其等待的资源超时（超过其设定的等待时间），那么该线程将不再等待这些资源，并返回到就绪状态；或者，当其他线程释放掉该线程所等待的资源时，该线程也会返回到就绪状态。</p>
<p>线程挂起使用下面的函数接口：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">rt_err_t</span> <span class="title function_">rt_thread_suspend</span> <span class="params">(<span class="type">rt_thread_t</span> thread)</span>;复制错误复制成功</span><br></pre></td></tr></table></figure>

<p>线程挂起接口 rt_thread_suspend() 的参数和返回值见下表：</p>
<table>
<thead>
<tr>
<th><strong>参数</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>thread</td>
<td>线程句柄</td>
</tr>
<tr>
<td><strong>返回</strong></td>
<td>——</td>
</tr>
<tr>
<td>RT_EOK</td>
<td>线程挂起成功</td>
</tr>
<tr>
<td>-RT_ERROR</td>
<td>线程挂起失败，因为该线程的状态并不是就绪状态</td>
</tr>
</tbody></table>
<p>Note</p>
<p>注：一个线程尝试挂起另一个线程是一个非常危险的行为，因此RT-Thread对此函数有严格的使用限制：该函数只能使用来挂起当前线程（即自己挂起自己），不可以在线程A中尝试挂起线程B。而且在挂起线程自己后，需要立刻调用 <code>rt_schedule()</code> 函数进行手动的线程上下文切换。这是因为A线程在尝试挂起B线程时，A线程并不清楚B线程正在运行什么程序，一旦B线程正在使用例如互斥量、信号量等影响、阻塞其他线程（如C线程）的内核对象，如果此时其他线程也在等待这个内核对象，那么A线程尝试挂起B线程的操作将会引发其他线程（如C线程）的饥饿，严重危及系统的实时性。</p>
<p>恢复线程就是让挂起的线程重新进入就绪状态，并将线程放入系统的就绪队列中；如果被恢复线程在所有就绪态线程中，位于最高优先级链表的第一位，那么系统将进行线程上下文的切换。线程恢复使用下面的函数接口：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">rt_err_t</span> <span class="title function_">rt_thread_resume</span> <span class="params">(<span class="type">rt_thread_t</span> thread)</span>;复制错误复制成功</span><br></pre></td></tr></table></figure>

<p>线程恢复接口 rt_thread_resume() 的参数和返回值见下表：</p>
<table>
<thead>
<tr>
<th><strong>参数</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>thread</td>
<td>线程句柄</td>
</tr>
<tr>
<td><strong>返回</strong></td>
<td>——</td>
</tr>
<tr>
<td>RT_EOK</td>
<td>线程恢复成功</td>
</tr>
<tr>
<td>-RT_ERROR</td>
<td>线程恢复失败，因为该个线程的状态并不是 RT_THREAD_SUSPEND 状态</td>
</tr>
</tbody></table>
<h3 id="控制线程"><a href="#控制线程" class="headerlink" title="控制线程"></a><a target="_blank" rel="noopener" href="https://www.rt-thread.org/document/site/#/rt-thread-version/rt-thread-standard/programming-manual/thread/thread?id=%E6%8E%A7%E5%88%B6%E7%BA%BF%E7%A8%8B">控制线程</a></h3><p>当需要对线程进行一些其他控制时，例如动态更改线程的优先级，可以调用如下函数接口：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">rt_err_t</span> <span class="title function_">rt_thread_control</span><span class="params">(<span class="type">rt_thread_t</span> thread, <span class="type">rt_uint8_t</span> cmd, <span class="type">void</span>* arg)</span>;复制错误复制成功</span><br></pre></td></tr></table></figure>

<p>线程控制接口 rt_thread_control() 的参数和返回值见下表：</p>
<table>
<thead>
<tr>
<th><strong>函数参数</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>thread</td>
<td>线程句柄</td>
</tr>
<tr>
<td>cmd</td>
<td>指示控制命令</td>
</tr>
<tr>
<td>arg</td>
<td>控制参数</td>
</tr>
<tr>
<td><strong>返回</strong></td>
<td>——</td>
</tr>
<tr>
<td>RT_EOK</td>
<td>控制执行正确</td>
</tr>
<tr>
<td>-RT_ERROR</td>
<td>失败</td>
</tr>
</tbody></table>
<p>指示控制命令 cmd 当前支持的命令包括：</p>
<ul>
<li>RT_THREAD_CTRL_CHANGE_PRIORITY：动态更改线程的优先级；</li>
<li>RT_THREAD_CTRL_STARTUP：开始运行一个线程，等同于 rt_thread_startup() 函数调用；</li>
<li>RT_THREAD_CTRL_CLOSE：关闭一个线程，等同于 rt_thread_delete() 或 rt_thread_detach() 函数调用。</li>
</ul>
<h3 id="设置和删除空闲钩子"><a href="#设置和删除空闲钩子" class="headerlink" title="设置和删除空闲钩子"></a><a target="_blank" rel="noopener" href="https://www.rt-thread.org/document/site/#/rt-thread-version/rt-thread-standard/programming-manual/thread/thread?id=%E8%AE%BE%E7%BD%AE%E5%92%8C%E5%88%A0%E9%99%A4%E7%A9%BA%E9%97%B2%E9%92%A9%E5%AD%90">设置和删除空闲钩子</a></h3><p>空闲钩子函数是空闲线程的钩子函数，如果设置了空闲钩子函数，就可以在系统执行空闲线程时，自动执行空闲钩子函数来做一些其他事情，比如系统指示灯。设置 &#x2F; 删除空闲钩子的接口如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">rt_err_t</span> <span class="title function_">rt_thread_idle_sethook</span><span class="params">(<span class="type">void</span> (*hook)(<span class="type">void</span>))</span>;</span><br><span class="line"><span class="type">rt_err_t</span> <span class="title function_">rt_thread_idle_delhook</span><span class="params">(<span class="type">void</span> (*hook)(<span class="type">void</span>))</span>;复制错误复制成功</span><br></pre></td></tr></table></figure>

<p>设置空闲钩子函数 rt_thread_idle_sethook() 的输入参数和返回值如下表所示：</p>
<table>
<thead>
<tr>
<th><strong>函数参数</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>hook</td>
<td>设置的钩子函数</td>
</tr>
<tr>
<td><strong>返回</strong></td>
<td>——</td>
</tr>
<tr>
<td>RT_EOK</td>
<td>设置成功</td>
</tr>
<tr>
<td>-RT_EFULL</td>
<td>设置失败</td>
</tr>
</tbody></table>
<p>删除空闲钩子函数 rt_thread_idle_delhook() 的输入参数和返回值如下表所示：</p>
<table>
<thead>
<tr>
<th><strong>函数参数</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>hook</td>
<td>删除的钩子函数</td>
</tr>
<tr>
<td><strong>返回</strong></td>
<td>——</td>
</tr>
<tr>
<td>RT_EOK</td>
<td>删除成功</td>
</tr>
<tr>
<td>-RT_ENOSYS</td>
<td>删除失败</td>
</tr>
</tbody></table>
<p>Note</p>
<p>注：空闲线程是一个线程状态永远为就绪态的线程，因此设置的钩子函数必须保证空闲线程在任何时刻都不会处于挂起状态，例如 rt_thread_delay()，rt_sem_take() 等可能会导致线程挂起的函数都不能使用。并且，由于 malloc、free 等内存相关的函数内部使用了信号量作为临界区保护，因此在钩子函数内部也不允许调用此类函数！</p>
<h3 id="设置调度器钩子"><a href="#设置调度器钩子" class="headerlink" title="设置调度器钩子"></a><a target="_blank" rel="noopener" href="https://www.rt-thread.org/document/site/#/rt-thread-version/rt-thread-standard/programming-manual/thread/thread?id=%E8%AE%BE%E7%BD%AE%E8%B0%83%E5%BA%A6%E5%99%A8%E9%92%A9%E5%AD%90">设置调度器钩子</a></h3><p>在整个系统的运行时，系统都处于线程运行、中断触发 - 响应中断、切换到其他线程，甚至是线程间的切换过程中，或者说系统的上下文切换是系统中最普遍的事件。有时用户可能会想知道在一个时刻发生了什么样的线程切换，可以通过调用下面的函数接口设置一个相应的钩子函数。在系统线程切换时，这个钩子函数将被调用：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">rt_scheduler_sethook</span><span class="params">(<span class="type">void</span> (*hook)(<span class="keyword">struct</span> rt_thread* from, <span class="keyword">struct</span> rt_thread* to))</span>;复制错误复制成功</span><br></pre></td></tr></table></figure>

<p>设置调度器钩子函数的输入参数如下表所示：</p>
<table>
<thead>
<tr>
<th><strong>函数参数</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>hook</td>
<td>表示用户定义的钩子函数指针</td>
</tr>
</tbody></table>
<p>钩子函数 hook() 的声明如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">hook</span><span class="params">(<span class="keyword">struct</span> rt_thread* from, <span class="keyword">struct</span> rt_thread* to)</span>;复制错误复制成功</span><br></pre></td></tr></table></figure>

<p>调度器钩子函数 hook() 的输入参数如下表所示：</p>
<table>
<thead>
<tr>
<th><strong>函数参数</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>from</td>
<td>表示系统所要切换出的线程控制块指针</td>
</tr>
<tr>
<td>to</td>
<td>表示系统所要切换到的线程控制块指针</td>
</tr>
</tbody></table>
<p>Note</p>
<p>注：请仔细编写你的钩子函数，稍有不慎将很可能导致整个系统运行不正常（在这个钩子函数中，基本上不允许调用系统 API，更不应该导致当前运行的上下文挂起）。</p>
<h2 id="线程应用示例"><a href="#线程应用示例" class="headerlink" title="线程应用示例"></a><a target="_blank" rel="noopener" href="https://www.rt-thread.org/document/site/#/rt-thread-version/rt-thread-standard/programming-manual/thread/thread?id=%E7%BA%BF%E7%A8%8B%E5%BA%94%E7%94%A8%E7%A4%BA%E4%BE%8B">线程应用示例</a></h2><p>下面给出在 Keil 模拟器环境下的应用示例。</p>
<h3 id="创建线程示例"><a href="#创建线程示例" class="headerlink" title="创建线程示例"></a><a target="_blank" rel="noopener" href="https://www.rt-thread.org/document/site/#/rt-thread-version/rt-thread-standard/programming-manual/thread/thread?id=%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%A4%BA%E4%BE%8B">创建线程示例</a></h3><p>这个例子会创建一个动态线程和一个静态线程，当这个静态线程完成其任务并被系统自动回收后，具有较低优先级的动态线程才能开始运行并打印信息。</p>
<blockquote>
<p>注意：RT-Thread 5.0 及更高的版本将 <code>ALIGN</code> 关键字改成了 <code>rt_align</code>，使用时注意。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;rtthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> THREAD_PRIORITY         25</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> THREAD_STACK_SIZE       512</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> THREAD_TIMESLICE        5</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">rt_thread_t</span> tid1 = RT_NULL;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 线程 1 的入口函数 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">thread1_entry</span><span class="params">(<span class="type">void</span> *parameter)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">rt_uint32_t</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (count = <span class="number">0</span>; count &lt; <span class="number">10</span> ; count++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 线程 1 采用低优先级运行 */</span></span><br><span class="line">        rt_kprintf(<span class="string">&quot;thread1 count: %d\n&quot;</span>, count);</span><br><span class="line">        rt_thread_mdelay(<span class="number">500</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    rt_kprintf(<span class="string">&quot;thread1 exit\n&quot;</span>);</span><br><span class="line">    <span class="comment">/* 线程 1 运行结束后也将自动被系统脱离 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(RT_VERSION_CHECK) &amp;&amp; (RTTHREAD_VERSION &gt;= RT_VERSION_CHECK(5, 0, 1))</span></span><br><span class="line">    rt_align(RT_ALIGN_SIZE)</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    ALIGN(RT_ALIGN_SIZE)</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> thread2_stack[<span class="number">1024</span>];</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">rt_thread</span> <span class="title">thread2</span>;</span></span><br><span class="line"><span class="comment">/* 线程 2 入口 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">thread2_entry</span><span class="params">(<span class="type">void</span> *param)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">rt_uint32_t</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 线程 2 拥有较高的优先级，以抢占线程 1 而获得执行 */</span></span><br><span class="line">    <span class="keyword">for</span> (count = <span class="number">0</span>; count &lt; <span class="number">10</span> ; count++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 线程 2 打印计数值 */</span></span><br><span class="line">        rt_kprintf(<span class="string">&quot;thread2 count: %d\n&quot;</span>, count);</span><br><span class="line">    &#125;</span><br><span class="line">    rt_kprintf(<span class="string">&quot;thread2 exit\n&quot;</span>);</span><br><span class="line">    <span class="comment">/* 线程 2 运行结束后也将自动被系统脱离 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 线程示例 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">thread_sample</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 创建线程 1，名称是 thread1，入口是 thread1_entry*/</span></span><br><span class="line">    tid1 = rt_thread_create(<span class="string">&quot;thread1&quot;</span>,</span><br><span class="line">                            thread1_entry, RT_NULL,</span><br><span class="line">                            THREAD_STACK_SIZE,</span><br><span class="line">                            THREAD_PRIORITY, THREAD_TIMESLICE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果获得线程控制块，启动这个线程 */</span></span><br><span class="line">    <span class="keyword">if</span> (tid1 != RT_NULL)</span><br><span class="line">        rt_thread_startup(tid1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 初始化线程 2，名称是 thread2，入口是 thread2_entry */</span></span><br><span class="line">    rt_thread_init(&amp;thread2,</span><br><span class="line">                   <span class="string">&quot;thread2&quot;</span>,</span><br><span class="line">                   thread2_entry,</span><br><span class="line">                   RT_NULL,</span><br><span class="line">                   &amp;thread2_stack[<span class="number">0</span>],</span><br><span class="line">                   <span class="keyword">sizeof</span>(thread2_stack),</span><br><span class="line">                   THREAD_PRIORITY - <span class="number">1</span>, THREAD_TIMESLICE);</span><br><span class="line">    rt_thread_startup(&amp;thread2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 导出到 msh 命令列表中 */</span></span><br><span class="line">MSH_CMD_EXPORT(thread_sample, thread sample);复制错误复制成功</span><br></pre></td></tr></table></figure>

<p>仿真运行结果如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> \ | /</span><br><span class="line">- RT -     Thread Operating System</span><br><span class="line"> / | \     3.1.0 build Aug 24 2018</span><br><span class="line"> 2006 - 2018 Copyright by rt-thread team</span><br><span class="line">msh &gt;thread_sample</span><br><span class="line">msh &gt;thread2 count: 0</span><br><span class="line">thread2 count: 1</span><br><span class="line">thread2 count: 2</span><br><span class="line">thread2 count: 3</span><br><span class="line">thread2 count: 4</span><br><span class="line">thread2 count: 5</span><br><span class="line">thread2 count: 6</span><br><span class="line">thread2 count: 7</span><br><span class="line">thread2 count: 8</span><br><span class="line">thread2 count: 9</span><br><span class="line">thread2 exit</span><br><span class="line">thread1 count: 0</span><br><span class="line">thread1 count: 1</span><br><span class="line">thread1 count: 2</span><br><span class="line">thread1 count: 3</span><br><span class="line">…复制错误复制成功</span><br></pre></td></tr></table></figure>

<p>线程 2 计数到一定值会执行完毕，线程 2 被系统自动删除，计数停止。线程 1 才会打印计数。</p>
<p>Note</p>
<p>注：关于删除线程：大多数线程是循环执行的，无需删除；而能运行完毕的线程，RT-Thread 在线程运行完毕后，自动删除线程，在 rt_thread_exit() 里完成删除动作。用户只需要了解该接口的作用，不推荐使用该接口（可以由其他线程调用此接口或在定时器超时函数中调用此接口删除一个线程，但是这种使用非常少）。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/07/30/RUST%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0%E4%B9%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E4%B8%8E%E5%BC%95%E7%94%A8%E6%9C%89%E6%95%88%E6%80%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.png">
      <meta itemprop="name" content="Chillward">
      <meta itemprop="description" content="谁躺在漆黑的舞台上，用身体迎接着光芒">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chillward的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/07/30/RUST%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0%E4%B9%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E4%B8%8E%E5%BC%95%E7%94%A8%E6%9C%89%E6%95%88%E6%80%A7/" class="post-title-link" itemprop="url">RUST学习日记之生命周期与引用有效性</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-07-30 07:24:12" itemprop="dateCreated datePublished" datetime="2025-07-30T07:24:12+08:00">2025-07-30</time>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>0</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/07/28/RUST%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0%E4%B9%8Btrait/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.png">
      <meta itemprop="name" content="Chillward">
      <meta itemprop="description" content="谁躺在漆黑的舞台上，用身体迎接着光芒">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chillward的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/07/28/RUST%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0%E4%B9%8Btrait/" class="post-title-link" itemprop="url">RUST学习日记之trait</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-07-28 16:46:13" itemprop="dateCreated datePublished" datetime="2025-07-28T16:46:13+08:00">2025-07-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-07-30 07:21:52" itemprop="dateModified" datetime="2025-07-30T07:21:52+08:00">2025-07-30</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>9.5k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>17 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Trait类似于java语言中的接口</p>
<h3 id="定义-trait"><a href="#定义-trait" class="headerlink" title="定义 trait"></a>定义 trait</h3><p>一个类型的行为由其可供调用的方法构成。如果可以对不同类型调用相同的方法的话，这些类型就可以共享相同的行为了。trait 定义是一种将方法签名组合起来的方法，目的是定义一个实现某些目的所必需的行为的集合。</p>
<p>例如，这里有多个存放了不同类型和属性文本的结构体：结构体 <code>NewsArticle</code> 用于存放发生于世界各地的新闻故事，而结构体 <code>Tweet</code> 最多只能存放 280 个字符的内容，以及像是否转推或是否是对推友的回复这样的元数据。</p>
<p>我们想要创建一个多媒体聚合库用来显示可能储存在 <code>NewsArticle</code> 或 <code>Tweet</code> 实例中的数据的总结。每一个结构体都需要的行为是他们是能够被总结的，这样的话就可以调用实例的 <code>summarize</code> 方法来请求总结。示例 10-12 中展示了一个表现这个概念的 <code>Summary</code> trait 的定义：</p>
<p>文件名: src&#x2F;lib.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Summary</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例 10-12：<code>Summary</code> trait 定义，它包含由 <code>summarize</code> 方法提供的行为</p>
<p>这里使用 <code>trait</code> 关键字来声明一个 trait，后面是 trait 的名字，在这个例子中是 <code>Summary</code>。在大括号中声明描述实现这个 trait 的类型所需要的行为的方法签名，在这个例子中是 <code>fn summarize(&amp;self) -&gt; String</code>。</p>
<p>在方法签名后跟分号，而不是在大括号中提供其实现。接着每一个实现这个 trait 的类型都需要提供其自定义行为的方法体，编译器也会确保任何实现 <code>Summary</code> trait 的类型都拥有与这个签名的定义完全一致的 <code>summarize</code> 方法。</p>
<p>trait 体中可以有多个方法：一行一个方法签名且都以分号结尾。</p>
<h3 id="为类型实现-trait"><a href="#为类型实现-trait" class="headerlink" title="为类型实现 trait"></a>为类型实现 trait</h3><p>现在我们定义了 <code>Summary</code> trait，接着就可以在多媒体聚合库中需要拥有这个行为的类型上实现它了。示例 10-13 中展示了 <code>NewsArticle</code> 结构体上 <code>Summary</code> trait 的一个实现，它使用标题、作者和创建的位置作为 <code>summarize</code> 的返回值。对于 <code>Tweet</code> 结构体，我们选择将 <code>summarize</code> 定义为用户名后跟推文的全部文本作为返回值，并假设推文内容已经被限制为 280 字符以内。</p>
<p>文件名: src&#x2F;lib.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">NewsArticle</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> headline: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> location: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> author: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> content: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Summary</span> <span class="keyword">for</span> <span class="title class_">NewsArticle</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">        <span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125;, by &#123;&#125; (&#123;&#125;)&quot;</span>, <span class="keyword">self</span>.headline, <span class="keyword">self</span>.author, <span class="keyword">self</span>.location)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Tweet</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> username: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> content: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> reply: <span class="type">bool</span>,</span><br><span class="line">    <span class="keyword">pub</span> retweet: <span class="type">bool</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Summary</span> <span class="keyword">for</span> <span class="title class_">Tweet</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">        <span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125;: &#123;&#125;&quot;</span>, <span class="keyword">self</span>.username, <span class="keyword">self</span>.content)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例 10-13：在 <code>NewsArticle</code> 和 <code>Tweet</code> 类型上实现 <code>Summary</code> trait</p>
<p>在类型上实现 trait 类似于实现与 trait 无关的方法。区别在于 <code>impl</code> 关键字之后，我们提供需要实现 trait 的名称，接着是 <code>for</code> 和需要实现 trait 的类型的名称。在 <code>impl</code> 块中，使用 trait 定义中的方法签名，不过不再后跟分号，而是需要在大括号中编写函数体来为特定类型实现 trait 方法所拥有的行为。</p>
<p>一旦实现了 trait，我们就可以用与 <code>NewsArticle</code> 和 <code>Tweet</code> 实例的非 trait 方法一样的方式调用 trait 方法了：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">tweet</span> = Tweet &#123;</span><br><span class="line">    username: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;horse_ebooks&quot;</span>),</span><br><span class="line">    content: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;of course, as you probably already know, people&quot;</span>),</span><br><span class="line">    reply: <span class="literal">false</span>,</span><br><span class="line">    retweet: <span class="literal">false</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;1 new tweet: &#123;&#125;&quot;</span>, tweet.<span class="title function_ invoke__">summarize</span>());</span><br></pre></td></tr></table></figure>

<p>这会打印出 <code>1 new tweet: horse_ebooks: of course, as you probably already know, people</code>。</p>
<p>注意因为示例 10-13 中我们在相同的 <em>lib.rs</em> 里定义了 <code>Summary</code> trait 和 <code>NewsArticle</code> 与 <code>Tweet</code> 类型，所以他们是位于同一作用域的。如果这个 <em>lib.rs</em> 是对应 <code>aggregator</code> crate 的，而别人想要利用我们 crate 的功能为其自己的库作用域中的结构体实现 <code>Summary</code> trait。首先他们需要将 trait 引入作用域。这可以通过指定 <code>use aggregator::Summary;</code> 实现，这样就可以为其类型实现 <code>Summary</code> trait 了。<code>Summary</code> 还必须是公有 trait 使得其他 crate 可以实现它，这也是为什么示例 10-12 中将 <code>pub</code> 置于 <code>trait</code> 之前。</p>
<h3 id="Trait-的可见性"><a href="#Trait-的可见性" class="headerlink" title="Trait 的可见性"></a>Trait 的可见性</h3><p>当你定义一个 <code>trait</code> 时，你需要考虑它是否应该对其他 <code>crate</code> 可用。</p>
<ul>
<li>如果一个 <code>trait</code> 只是在你自己的 <code>crate</code> 内部使用，那么它不需要是公共的。</li>
<li>但如果你希望其他 <code>crate</code> 能够为它们自己的类型实现你定义的 <code>trait</code>，那么这个 <code>trait</code> 必须是 <strong><code>pub</code>（公共的）</strong>。这就是为什么在示例 10-12 中，<code>Summary</code> trait 前面有 <code>pub</code> 关键字，表示它是公共的，其他 <code>crate</code> 才能看到并实现它。</li>
</ul>
<h3 id="实现-Trait-的作用域规则"><a href="#实现-Trait-的作用域规则" class="headerlink" title="实现 Trait 的作用域规则"></a>实现 Trait 的作用域规则</h3><p>当你想要为一个类型实现某个 <code>trait</code> 时，有一个重要的限制：<strong>你只能为你自己的 <code>crate</code> 本地定义的类型实现 <code>trait</code>，或者为你自己的 <code>crate</code> 本地定义的 <code>trait</code> 实现类型。</strong></p>
<p>让我们用例子来说明：</p>
<ul>
<li><strong>可以实现的情况：</strong><ul>
<li><strong>为你自己的类型实现标准库中的 <code>trait</code>：</strong> 比如，你在 <code>aggregator</code> 这个 <code>crate</code> 中定义了一个自定义类型 <code>Tweet</code>。你可以为这个 <code>Tweet</code> 类型实现标准库中的 <code>Display</code> trait（这个 <code>trait</code> 用于控制类型如何打印输出）。这是因为 <code>Tweet</code> 是你 <code>aggregator</code> <code>crate</code> 本地定义的类型。</li>
<li><strong>为标准库类型实现你自己的 <code>trait</code>：</strong> 同样地，你可以在 <code>aggregator</code> <code>crate</code> 中为标准库类型 <code>Vec&lt;T&gt;</code>（一个向量类型）实现你自定义的 <code>Summary</code> trait。这是因为 <code>Summary</code> <code>trait</code> 是你 <code>aggregator</code> <code>crate</code> 本地定义的 <code>trait</code>。</li>
</ul>
</li>
<li><strong>不能实现的情况（外部类型实现外部 trait）：</strong><ul>
<li>你<strong>不能</strong>在 <code>aggregator</code> <code>crate</code> 中为标准库类型 <code>Vec&lt;T&gt;</code> 实现标准库中的 <code>Display</code> trait。为什么呢？因为 <code>Display</code> 和 <code>Vec&lt;T&gt;</code> 这两个东西都<strong>不是</strong>你 <code>aggregator</code> <code>crate</code> 本地定义的。它们都来自标准库，对于你的 <code>aggregator</code> <code>crate</code> 来说，它们都是“外部”的。</li>
</ul>
</li>
</ul>
<h3 id="孤儿规则（Orphan-Rule）的意义"><a href="#孤儿规则（Orphan-Rule）的意义" class="headerlink" title="孤儿规则（Orphan Rule）的意义"></a>孤儿规则（Orphan Rule）的意义</h3><p>这个限制被称为<strong>相干性（coherence）</strong>，更具体地说是<strong>孤儿规则（orphan rule）</strong>。这条规则是为了避免潜在的冲突和混乱：</p>
<ul>
<li><strong>避免冲突：</strong> 如果没有这条规则，想象一下：<code>crate A</code> 为 <code>Vec&lt;T&gt;</code> 实现了 <code>Display</code>，而 <code>crate B</code> 也为 <code>Vec&lt;T&gt;</code> 实现了 <code>Display</code>。当你的代码同时依赖 <code>crate A</code> 和 <code>crate B</code> 时，Rust 就会感到困惑，不知道当你想打印 <code>Vec&lt;T&gt;</code> 时，到底应该使用 <code>crate A</code> 的 <code>Display</code> 实现还是 <code>crate B</code> 的 <code>Display</code> 实现。</li>
<li><strong>保证代码稳定性：</strong> 孤儿规则确保了“别人编写的代码不会破坏你的代码，反之亦然”。它防止了不同 <code>crate</code> 对同一外部类型实现相同外部 <code>trait</code> 导致的行为不确定性。</li>
</ul>
<p>简而言之，孤儿规则保证了每个 <code>trait</code> 实现都必须至少有一个“亲属”在当前 <code>crate</code> 中，要么是你实现了这个 <code>trait</code> 的类型是你自己定义的，要么是你实现的这个 <code>trait</code> 是你自己定义的。</p>
<h3 id="默认实现"><a href="#默认实现" class="headerlink" title="默认实现"></a>默认实现</h3><p>有时为 trait 中的某些或全部方法提供默认的行为，而不是在每个类型的每个实现中都定义自己的行为是很有用的。这样当为某个特定类型实现 trait 时，可以选择保留或重载每个方法的默认行为。</p>
<p>示例 10-14 中展示了如何为 <code>Summary</code> trait 的 <code>summarize</code> 方法指定一个默认的字符串值，而不是像示例 10-12 中那样只是定义方法签名：</p>
<p>文件名: src&#x2F;lib.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Summary</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">        <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;(Read more...)&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例 10-14：<code>Summary</code> trait 的定义，带有一个 <code>summarize</code> 方法的默认实现</p>
<p>如果想要对 <code>NewsArticle</code> 实例使用这个默认实现，而不是定义一个自己的实现，则可以通过 <code>impl Summary for NewsArticle &#123;&#125;</code> 指定一个空的 <code>impl</code> 块。</p>
<p>虽然我们不再直接为 <code>NewsArticle</code> 定义 <code>summarize</code> 方法了，但是我们提供了一个默认实现并且指定 <code>NewsArticle</code> 实现 <code>Summary</code> trait。因此，我们仍然可以对 <code>NewsArticle</code> 实例调用 <code>summarize</code> 方法，如下所示：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">article</span> = NewsArticle &#123;</span><br><span class="line">    headline: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Penguins win the Stanley Cup Championship!&quot;</span>),</span><br><span class="line">    location: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Pittsburgh, PA, USA&quot;</span>),</span><br><span class="line">    author: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Iceburgh&quot;</span>),</span><br><span class="line">    content: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;The Pittsburgh Penguins once again are the best</span></span><br><span class="line"><span class="string">    hockey team in the NHL.&quot;</span>),</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;New article available! &#123;&#125;&quot;</span>, article.<span class="title function_ invoke__">summarize</span>());</span><br></pre></td></tr></table></figure>

<p>这段代码会打印 <code>New article available! (Read more...)</code>。</p>
<p>为 <code>summarize</code> 创建默认实现并不要求对示例 10-13 中 <code>Tweet</code> 上的 <code>Summary</code> 实现做任何改变。其原因是重载一个默认实现的语法与实现没有默认实现的 trait 方法的语法一样。</p>
<p>默认实现允许调用相同 trait 中的其他方法，哪怕这些方法没有默认实现。如此，trait 可以提供很多有用的功能而只需要实现指定一小部分内容。例如，我们可以定义 <code>Summary</code> trait，使其具有一个需要实现的 <code>summarize_author</code> 方法，然后定义一个 <code>summarize</code> 方法，此方法的默认实现调用 <code>summarize_author</code> 方法：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Summary</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize_author</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">        <span class="built_in">format!</span>(<span class="string">&quot;(Read more from &#123;&#125;...)&quot;</span>, <span class="keyword">self</span>.<span class="title function_ invoke__">summarize_author</span>())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了使用这个版本的 <code>Summary</code>，只需在实现 trait 时定义 <code>summarize_author</code> 即可：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Summary</span> <span class="keyword">for</span> <span class="title class_">Tweet</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize_author</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">        <span class="built_in">format!</span>(<span class="string">&quot;@&#123;&#125;&quot;</span>, <span class="keyword">self</span>.username)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一旦定义了 <code>summarize_author</code>，我们就可以对 <code>Tweet</code> 结构体的实例调用 <code>summarize</code> 了，而 <code>summarize</code> 的默认实现会调用我们提供的 <code>summarize_author</code> 定义。因为实现了 <code>summarize_author</code>，<code>Summary</code> trait 就提供了 <code>summarize</code> 方法的功能，且无需编写更多的代码。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">tweet</span> = Tweet &#123;</span><br><span class="line">    username: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;horse_ebooks&quot;</span>),</span><br><span class="line">    content: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;of course, as you probably already know, people&quot;</span>),</span><br><span class="line">    reply: <span class="literal">false</span>,</span><br><span class="line">    retweet: <span class="literal">false</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;1 new tweet: &#123;&#125;&quot;</span>, tweet.<span class="title function_ invoke__">summarize</span>());</span><br></pre></td></tr></table></figure>

<p>这会打印出 <code>1 new tweet: (Read more from @horse_ebooks...)</code>。</p>
<p>请注意，无法从相同方法的重载实现中调用默认方法。</p>
<p>核心思想是：<strong><code>trait</code> 定义了行为，<code>trait bound</code> 则限制了泛型类型必须拥有这些行为。</strong></p>
<h3 id="1-将-Trait-作为函数参数"><a href="#1-将-Trait-作为函数参数" class="headerlink" title="1. 将 Trait 作为函数参数"></a>1. 将 Trait 作为函数参数</h3><p>想象一下，你有一个 <code>Summary</code> trait，它规定了任何实现它的类型都应该有一个 <code>summarize</code> 方法。</p>
<ul>
<li><p><strong><code>impl Trait</code> 语法（简单写法）：</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">notify</span>(item: <span class="keyword">impl</span> <span class="title class_">Summary</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Breaking news! &#123;&#125;&quot;</span>, item.<span class="title function_ invoke__">summarize</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这就像在说：“嘿，<code>notify</code> 函数，我不在乎你收到的是 <code>NewsArticle</code> 还是 <code>Tweet</code>，<strong>只要</strong>它能 <code>summarize</code> 就行！” 这种写法简洁明了，编译器会确保你传递进来的类型确实实现了 <code>Summary</code>。如果传了 <code>String</code> 或 <code>i32</code>，编译就会失败，因为它们没有 <code>summarize</code> 方法。</p>
</li>
</ul>
<h3 id="2-Trait-Bound-语法（更详细的写法）"><a href="#2-Trait-Bound-语法（更详细的写法）" class="headerlink" title="2. Trait Bound 语法（更详细的写法）"></a>2. Trait Bound 语法（更详细的写法）</h3><p><code>impl Trait</code> 只是一个语法糖，它的背后是更正式的 <strong>Trait Bound</strong> 语法。</p>
<ul>
<li><p><strong>基本等价写法：</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">notify</span>&lt;T: Summary&gt;(item: T) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Breaking news! &#123;&#125;&quot;</span>, item.<span class="title function_ invoke__">summarize</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这和上面的 <code>impl Trait</code> 效果一样，但是明确引入了一个<strong>泛型类型 <code>T</code></strong>，并用 <code>&lt;T: Summary&gt;</code> 表示 <code>T</code> 必须实现 <code>Summary</code>。</p>
</li>
<li><p><strong>强制多个参数类型一致：</strong> <code>Trait Bound</code> 的强大之处在于它可以让你强制多个泛型参数是<strong>同一个具体类型</strong>。</p>
<ul>
<li><p>如果你用 <code>impl Trait</code>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">notify</span>(item1: <span class="keyword">impl</span> <span class="title class_">Summary</span>, item2: <span class="keyword">impl</span> <span class="title class_">Summary</span>) &#123; <span class="comment">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure>

<p><code>item1</code> 可以是 <code>NewsArticle</code>，<code>item2</code> 可以是 <code>Tweet</code>，只要它们都能 <code>summarize</code> 就行。它们<strong>可以是不同类型</strong>。</p>
</li>
<li><p>如果你用 <code>Trait Bound</code>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">notify</span>&lt;T: Summary&gt;(item1: T, item2: T) &#123; <span class="comment">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure>

<p>这里 <code>item1</code> 和 <code>item2</code> 都被指定为泛型类型 <code>T</code>。这意味着，如果你给 <code>item1</code> 传了一个 <code>NewsArticle</code>，那么 <code>item2</code> <strong>也必须</strong>是 <code>NewsArticle</code>。它们<strong>必须是相同类型</strong>。</p>
</li>
</ul>
</li>
</ul>
<h3 id="3-指定多个-Trait-Bound"><a href="#3-指定多个-Trait-Bound" class="headerlink" title="3. + 指定多个 Trait Bound"></a>3. <code>+</code> 指定多个 Trait Bound</h3><p>如果一个类型需要同时实现多个 <code>trait</code> 呢？用 <code>+</code> 符号连接它们！</p>
<ul>
<li><p><strong>使用 <code>impl Trait</code>：</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">notify</span>(item: <span class="keyword">impl</span> <span class="title class_">Summary</span> + Display) &#123; <span class="comment">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure>

<p>这表示 <code>item</code> 既要能 <code>summarize</code>，也要能被 <code>Display</code>（也就是可以被格式化打印出来）。</p>
</li>
<li><p><strong>使用 <code>Trait Bound</code>：</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">notify</span>&lt;T: Summary + Display&gt;(item: T) &#123; <span class="comment">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure>

<p>效果一样，只是写法不同。</p>
</li>
</ul>
<h3 id="4-where-从句简化-Trait-Bound"><a href="#4-where-从句简化-Trait-Bound" class="headerlink" title="4. where 从句简化 Trait Bound"></a>4. <code>where</code> 从句简化 Trait Bound</h3><p>当你的函数有很多泛型参数，并且每个参数都有多个 <code>trait bound</code> 时，函数签名会变得非常长，难以阅读。<code>where</code> 从句就是为了解决这个问题。</p>
<ul>
<li><p><strong>没有 <code>where</code> 从句：</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">some_function</span>&lt;T: Display + <span class="built_in">Clone</span>, U: <span class="built_in">Clone</span> + <span class="built_in">Debug</span>&gt;(t: T, u: U) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123; <span class="comment">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure>

<p>你看，尖括号里一堆东西，函数名和参数列表离得好远。</p>
</li>
<li><p><strong>使用 <code>where</code> 从句：</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">some_function</span>&lt;T, U&gt;(t: T, u: U) <span class="punctuation">-&gt;</span> <span class="type">i32</span></span><br><span class="line">    <span class="keyword">where</span> T: Display + <span class="built_in">Clone</span>,</span><br><span class="line">          U: <span class="built_in">Clone</span> + <span class="built_in">Debug</span></span><br><span class="line">&#123; <span class="comment">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure>

<p>这样就清晰多了！<code>trait bound</code> 被移到了单独的 <code>where</code> 从句中，函数签名本身就简洁了。</p>
</li>
</ul>
<h3 id="5-返回实现了-Trait-的类型"><a href="#5-返回实现了-Trait-的类型" class="headerlink" title="5. 返回实现了 Trait 的类型"></a>5. 返回实现了 Trait 的类型</h3><p>你也可以让函数返回一个<strong>实现了特定 <code>trait</code> 的类型</strong>，而不需要暴露具体的类型是什么。</p>
<ul>
<li><p><strong>语法：</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">returns_summarizable</span>() <span class="punctuation">-&gt;</span> <span class="keyword">impl</span> <span class="title class_">Summary</span> &#123;</span><br><span class="line">    Tweet &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数承诺它会返回一个可以被“总结”的东西（<code>impl Summary</code>），但具体是 <code>Tweet</code> 还是 <code>NewsArticle</code>，函数调用方并不需要知道。这对于<strong>闭包</strong>和<strong>迭代器</strong>特别有用，因为它们的实际类型可能非常复杂，用 <code>impl Trait</code> 就能大大简化代码。</p>
</li>
<li><p><strong>重要限制：</strong> <code>returns_summarizable()</code> 这种写法<strong>只能返回单一的具体类型</strong>。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误示例！不能编译！</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">returns_summarizable</span>(switch: <span class="type">bool</span>) <span class="punctuation">-&gt;</span> <span class="keyword">impl</span> <span class="title class_">Summary</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> switch &#123;</span><br><span class="line">        NewsArticle &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Tweet &#123; <span class="comment">/* ... */</span> &#125; <span class="comment">// 这里返回了不同的类型</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>**你不能根据条件返回不同的实现了 <code>Summary</code> 的类型（比如有时返回 <code>NewsArticle</code>，有时返回 <code>Tweet</code>）。如果需要这样做，你得使用 <strong><code>trait object</code>（特性对象）</strong>，这是第 17 章会讲到的更高级概念。 **</p>
</li>
</ul>
<h3 id="6-修复-largest-函数"><a href="#6-修复-largest-函数" class="headerlink" title="6. 修复 largest 函数"></a>6. 修复 <code>largest</code> 函数</h3><p>回到最开始 <code>largest</code> 函数的错误：</p>
<ul>
<li><p><strong>问题一：不能比较 <code>T</code> 类型（<code>&gt;</code> 运算符）。</strong></p>
<ul>
<li><p>因为 <code>&gt;</code> 运算符是 <code>std::cmp::PartialOrd</code> 这个 <code>trait</code> 提供的。</p>
</li>
<li><p><strong>解决方案：</strong> 给 <code>T</code> 加上 <code>PartialOrd</code> 的 <strong>trait bound</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">largest</span>&lt;T: <span class="built_in">PartialOrd</span>&gt;(list: &amp;[T]) <span class="punctuation">-&gt;</span> T &#123; <span class="comment">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>问题二：不能移动非 <code>Copy</code> 类型的值（<code>list[0]</code> 和 <code>for &amp;item</code>）。</strong></p>
<ul>
<li><p><code>list[0]</code> 会把第一个元素“移动”出来，<code>for &amp;item</code> 也尝试“解引用并移动”。但如果 <code>T</code> 没有实现 <code>Copy</code> trait，这种移动是不被允许的（因为移动后原位置就“空”了，而切片 <code>&amp;[T]</code> 不允许这种操作）。像 <code>i32</code> 和 <code>char</code> 这种栈上数据默认是 <code>Copy</code> 的，但其他复杂类型可能不是。</p>
</li>
<li><p><strong>解决方案一（简单粗暴）：</strong> 给 <code>T</code> 再加上 <code>Copy</code> 的 <strong>trait bound</strong>。这样就限制了 <code>largest</code> 只能用于那些可以简单复制的类型。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">largest</span>&lt;T: <span class="built_in">PartialOrd</span> + <span class="built_in">Copy</span>&gt;(list: &amp;[T]) <span class="punctuation">-&gt;</span> T &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">largest</span> = list[<span class="number">0</span>]; <span class="comment">// 现在 T 保证是 Copy 的</span></span><br><span class="line">    <span class="keyword">for</span> &amp;item <span class="keyword">in</span> list.<span class="title function_ invoke__">iter</span>() &#123; <span class="comment">// 现在 &amp;item 可以拷贝一份</span></span><br><span class="line">        <span class="keyword">if</span> item &gt; largest &#123;</span><br><span class="line">            largest = item;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    largest</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>解决方案二（更通用但可能慢）：</strong> 如果不想限制 <code>Copy</code>，可以要求 <code>T</code> 实现 <code>Clone</code>，然后在需要的时候<strong>显式地克隆</strong>数据。但这可能会涉及堆内存分配，效率较低。</p>
</li>
<li><p><strong>解决方案三（最佳实践）：</strong> 返回一个<strong>引用</strong> <code>&amp;T</code>！这样就避免了移动或拷贝数据，直接操作原始数据的引用。你会被鼓励尝试自己实现这个版本。</p>
</li>
</ul>
</li>
</ul>
<h3 id="7-有条件地实现方法和-Blanket-Implementations"><a href="#7-有条件地实现方法和-Blanket-Implementations" class="headerlink" title="7. 有条件地实现方法和 Blanket Implementations"></a>7. 有条件地实现方法和 Blanket Implementations</h3><ul>
<li><p><strong>有条件实现方法：</strong></p>
<ul>
<li><p>你可以给一个泛型结构体（比如 <code>Pair&lt;T&gt;</code>）的 <code>impl</code> 块加上 <strong><code>trait bound</code></strong>。</p>
</li>
<li><p>这意味着：<code>Pair&lt;T&gt;</code> 总是有一个 <code>new</code> 方法，但它只有在 <code>T</code> 类型同时实现了 <code>Display</code> 和 <code>PartialOrd</code> 时，才会有 <code>cmp_display</code> 方法。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;T: Display + <span class="built_in">PartialOrd</span>&gt; Pair&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">cmp_display</span>(&amp;<span class="keyword">self</span>) &#123; <span class="comment">/* ... */</span> &#125; <span class="comment">// 只有当 T 满足条件时才有</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>Blanket Implementations（毯子实现&#x2F;覆盖实现）：</strong></p>
<ul>
<li><p>这是一个非常强大的功能！它允许你<strong>为所有满足特定 <code>trait bound</code> 的类型实现另一个 <code>trait</code></strong>。</p>
</li>
<li><p>标准库中就有很多例子，比如：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;T: Display&gt; <span class="built_in">ToString</span> <span class="keyword">for</span> <span class="title class_">T</span> &#123; <span class="comment">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure>

<p>这句话的意思是：“<strong>任何</strong>实现了 <code>Display</code> trait 的类型，都自动实现 <code>ToString</code> trait。”</p>
</li>
<li><p>这解释了为什么你可以直接对一个整数（比如 <code>3</code>）调用 <code>.to_string()</code>：<code>3</code> 是 <code>i32</code> 类型，<code>i32</code> 实现了 <code>Display</code>，所以根据这个“毯子实现”，<code>i32</code> 也就自动实现了 <code>ToString</code>。</p>
</li>
</ul>
</li>
</ul>
<h3 id="总结一下："><a href="#总结一下：" class="headerlink" title="总结一下："></a>总结一下：</h3><p><code>trait</code> 和 <code>trait bound</code> 是 Rust 泛型系统的基石。它们让你能够编写出：</p>
<ul>
<li><strong>灵活的代码：</strong> 可以处理多种不同类型。</li>
<li><strong>安全的代码：</strong> 编译器在编译时就检查类型是否满足所需行为，而不是等到运行时才报错。</li>
<li><strong>高性能的代码：</strong> 因为编译时已经确定了类型和行为，运行时不需要额外的检查开销。</li>
</ul>
<p>这就像是给你的泛型函数或类型打上了“能力标签”，只有拥有这些标签的类型才能被使用，确保了代码的正确性。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/07/28/RUST%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0%E4%B9%8B%E6%B3%9B%E5%9E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.png">
      <meta itemprop="name" content="Chillward">
      <meta itemprop="description" content="谁躺在漆黑的舞台上，用身体迎接着光芒">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chillward的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/07/28/RUST%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0%E4%B9%8B%E6%B3%9B%E5%9E%8B/" class="post-title-link" itemprop="url">RUST学习日记之泛型</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-07-28 11:02:52 / 修改时间：16:45:44" itemprop="dateCreated datePublished" datetime="2025-07-28T11:02:52+08:00">2025-07-28</time>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>6.9k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>13 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>之前拿C语言写泛型，可以说是格外吃力并且不好用，因为C语言是相对更低级的语言，语言特性上就没有泛型这么个东西，但是RUST是原生支持了泛型的，现在我们就来看一下。</p>
<blockquote>
<p>泛型是什么我这边就不介绍了，依旧是先来看一下官方文档的高速神言。</p>
</blockquote>
<h3 id="在函数定义中使用泛型"><a href="#在函数定义中使用泛型" class="headerlink" title="在函数定义中使用泛型"></a>在函数定义中使用泛型</h3><p>当使用泛型定义函数时，本来在函数签名中指定参数和返回值的类型的地方，会改用泛型来表示。采用这种技术，使得代码适应性更强，从而为函数的调用者提供更多的功能，同时也避免了代码的重复。</p>
<p>回到 <code>largest</code> 函数，示例 10-4 中展示了两个函数，它们的功能都是寻找 slice 中最大值。</p>
<p>文件名: src&#x2F;main.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">largest_i32</span>(list: &amp;[<span class="type">i32</span>]) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">largest</span> = list[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &amp;item <span class="keyword">in</span> list.<span class="title function_ invoke__">iter</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> item &gt; largest &#123;</span><br><span class="line">            largest = item;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    largest</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">largest_char</span>(list: &amp;[<span class="type">char</span>]) <span class="punctuation">-&gt;</span> <span class="type">char</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">largest</span> = list[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &amp;item <span class="keyword">in</span> list.<span class="title function_ invoke__">iter</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> item &gt; largest &#123;</span><br><span class="line">            largest = item;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    largest</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">number_list</span> = <span class="built_in">vec!</span>[<span class="number">34</span>, <span class="number">50</span>, <span class="number">25</span>, <span class="number">100</span>, <span class="number">65</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span> = <span class="title function_ invoke__">largest_i32</span>(&amp;number_list);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The largest number is &#123;&#125;&quot;</span>, result);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">char_list</span> = <span class="built_in">vec!</span>[<span class="string">&#x27;y&#x27;</span>, <span class="string">&#x27;m&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;q&#x27;</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span> = <span class="title function_ invoke__">largest_char</span>(&amp;char_list);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The largest char is &#123;&#125;&quot;</span>, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例 10-4：两个函数，不同点只是名称和签名类型</p>
<p><code>largest_i32</code> 函数是从示例 10-3 中摘出来的，它用来寻找 slice 中最大的 <code>i32</code>。<code>largest_char</code> 函数寻找 slice 中最大的 <code>char</code>。因为两者函数体的代码一致，我们可以定义一个函数，再引进泛型参数来消除这种重复。</p>
<p>为了参数化新函数中的这些类型，我们也需要为类型参数取个名字，道理和给函数的形参起名一样。任何标识符都可以作为类型参数的名字。这里选用 <code>T</code>，因为传统上来说，Rust 的参数名字都比较短，通常就只有一个字母，同时，Rust 类型名的命名规范是骆驼命名法（CamelCase）。<code>T</code> 作为 “type” 的缩写是大部分 Rust 开发者的首选。</p>
<p>如果要在函数体中使用参数，就必须在函数签名中声明它的名字，好让编译器知道这个名字指代的是什么。同理，当在函数签名中使用一个类型参数时，必须在使用它之前就声明它。为了定义泛型版本的 <code>largest</code> 函数，类型参数声明位于函数名称与参数列表中间的尖括号 <code>&lt;&gt;</code> 中，像这样：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">largest</span>&lt;T&gt;(list: &amp;[T]) <span class="punctuation">-&gt;</span> T &#123;</span><br></pre></td></tr></table></figure>

<p>可以这样理解这个定义：函数 <code>largest</code> 有泛型类型 <code>T</code>。它有个参数 <code>list</code>，其类型是元素为 <code>T</code> 的 slice。<code>largest</code> 函数的返回值类型也是 <code>T</code>。</p>
<p>示例 10-5 中的 <code>largest</code> 函数在它的签名中使用了泛型，统一了两个实现。该示例也展示了如何调用 <code>largest</code> 函数，把 <code>i32</code> 值的 slice 或 <code>char</code> 值的 slice 传给它。请注意这些代码还不能编译，不过稍后在本章会解决这个问题。</p>
<p>文件名: src&#x2F;main.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">largest</span>&lt;T&gt;(list: &amp;[T]) <span class="punctuation">-&gt;</span> T &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">largest</span> = list[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &amp;item <span class="keyword">in</span> list.<span class="title function_ invoke__">iter</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> item &gt; largest &#123;</span><br><span class="line">            largest = item;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    largest</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">number_list</span> = <span class="built_in">vec!</span>[<span class="number">34</span>, <span class="number">50</span>, <span class="number">25</span>, <span class="number">100</span>, <span class="number">65</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span> = <span class="title function_ invoke__">largest</span>(&amp;number_list);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The largest number is &#123;&#125;&quot;</span>, result);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">char_list</span> = <span class="built_in">vec!</span>[<span class="string">&#x27;y&#x27;</span>, <span class="string">&#x27;m&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;q&#x27;</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span> = <span class="title function_ invoke__">largest</span>(&amp;char_list);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The largest char is &#123;&#125;&quot;</span>, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例 10-5：一个使用泛型参数的 <code>largest</code> 函数定义，尚不能编译</p>
<p>如果现在就编译这个代码，会出现如下错误：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">error[E0369]: binary operation `&gt;` cannot be applied to type `T`</span><br><span class="line"> --&gt; src/main.rs:5:12</span><br><span class="line">  |</span><br><span class="line">5 |         if item &gt; largest &#123;</span><br><span class="line">  |            ^^^^^^^^^^^^^^</span><br><span class="line">  |</span><br><span class="line">  = note: an implementation of `std::cmp::PartialOrd` might be missing for `T`</span><br></pre></td></tr></table></figure>

<p>注释中提到了 <code>std::cmp::PartialOrd</code>，这是一个 <em>trait</em>。下一部分会讲到 trait。不过简单来说，这个错误表明 <code>largest</code> 的函数体不能适用于 <code>T</code> 的所有可能的类型。因为在函数体需要比较 <code>T</code> 类型的值，不过它只能用于我们知道如何排序的类型。为了开启比较功能，标准库中定义的 <code>std::cmp::PartialOrd</code> trait 可以实现类型的比较功能（查看附录 C 获取该 trait 的更多信息）。</p>
<p>标准库中定义的 <code>std::cmp::PartialOrd</code> trait 可以实现类型的比较功能。在 <a target="_blank" rel="noopener" href="https://rustwiki.org/zh-CN/book/ch10-02-traits.html#traits-as-parameters">“trait 作为参数”</a> 部分会讲解如何指定泛型实现特定的 trait，不过让我们先探索其他使用泛型参数的方法。</p>
<blockquote>
<p>别的地方都还挺好理解的，最后这个的意思大概是说可能有的数据类型没法使用 &gt;&#x3D; 之类的符号进行运算，然后因为Rust很严格，所以我们没法直接编译，需要告知编译器只有实现了对应特性的数据类型才能使用这个泛型函数</p>
</blockquote>
<h3 id="结构体定义中的泛型"><a href="#结构体定义中的泛型" class="headerlink" title="结构体定义中的泛型"></a>结构体定义中的泛型</h3><p>同样也可以用 <code>&lt;&gt;</code> 语法来定义结构体，它包含一个或多个泛型参数类型字段。示例 10-6 展示了如何定义和使用一个可以存放任何类型的 <code>x</code> 和 <code>y</code> 坐标值的结构体 <code>Point</code>：</p>
<p>文件名: src&#x2F;main.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span>&lt;T&gt; &#123;</span><br><span class="line">    x: T,</span><br><span class="line">    y: T,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">integer</span> = Point &#123; x: <span class="number">5</span>, y: <span class="number">10</span> &#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">float</span> = Point &#123; x: <span class="number">1.0</span>, y: <span class="number">4.0</span> &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例 10-6：<code>Point</code> 结构体存放了两个 <code>T</code> 类型的值 <code>x</code> 和 <code>y</code></p>
<p>其语法类似于函数定义中使用泛型。首先，必须在结构体名称后面的尖括号中声明泛型参数的名称。接着在结构体定义中可以指定具体数据类型的位置使用泛型类型。</p>
<p>注意 <code>Point&lt;T&gt;</code> 的定义中只使用了一个泛型类型，这个定义表明结构体 <code>Point&lt;T&gt;</code> 对于一些类型 <code>T</code> 是泛型的，而且字段 <code>x</code> 和 <code>y</code> <strong>都是</strong> 相同类型的，无论它具体是何类型。如果尝试创建一个有不同类型值的 <code>Point&lt;T&gt;</code> 的实例，像示例 10-7 中的代码就不能编译：</p>
<p>文件名: src&#x2F;main.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span>&lt;T&gt; &#123;</span><br><span class="line">    x: T,</span><br><span class="line">    y: T,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">wont_work</span> = Point &#123; x: <span class="number">5</span>, y: <span class="number">4.0</span> &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例 10-7：字段 <code>x</code> 和 <code>y</code> 的类型必须相同，因为他们都有相同的泛型类型 <code>T</code></p>
<p>在这个例子中，当把整型值 5 赋值给 <code>x</code> 时，就告诉了编译器这个 <code>Point&lt;T&gt;</code> 实例中的泛型 <code>T</code> 是整型的。接着指定 <code>y</code> 为 4.0，它被定义为与 <code>x</code> 相同类型，就会得到一个像这样的类型不匹配错误：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">error[E0308]: mismatched types</span><br><span class="line"> --&gt; src/main.rs:7:38</span><br><span class="line">  |</span><br><span class="line">7 |     let wont_work = Point &#123; x: 5, y: 4.0 &#125;;</span><br><span class="line">  |                                      ^^^ expected integer, found</span><br><span class="line">floating-point number</span><br><span class="line">  |</span><br><span class="line">  = note: expected type `&#123;integer&#125;`</span><br><span class="line">             found type `&#123;float&#125;`</span><br></pre></td></tr></table></figure>

<p>如果想要定义一个 <code>x</code> 和 <code>y</code> 可以有不同类型且仍然是泛型的 <code>Point</code> 结构体，我们可以使用多个泛型类型参数。在示例 10-8 中，我们修改 <code>Point</code> 的定义为拥有两个泛型类型 <code>T</code> 和 <code>U</code>。其中字段 <code>x</code> 是 <code>T</code> 类型的，而字段 <code>y</code> 是 <code>U</code> 类型的：</p>
<p>文件名: src&#x2F;main.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span>&lt;T, U&gt; &#123;</span><br><span class="line">    x: T,</span><br><span class="line">    y: U,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">both_integer</span> = Point &#123; x: <span class="number">5</span>, y: <span class="number">10</span> &#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">both_float</span> = Point &#123; x: <span class="number">1.0</span>, y: <span class="number">4.0</span> &#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">integer_and_float</span> = Point &#123; x: <span class="number">5</span>, y: <span class="number">4.0</span> &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例 10-8：使用两个泛型的 <code>Point</code>，这样 <code>x</code> 和 <code>y</code> 可能是不同类型</p>
<p>现在所有的 <code>Point</code> 实例都合法了！你可以在定义中使用任意多的泛型类型参数，不过太多的话，代码将难以阅读和理解。当你的代码中需要许多泛型类型时，它可能表明你的代码需要重构，分解成更小的结构。</p>
<blockquote>
<p>这一段还是挺好理解的，就不再展开阐述了</p>
</blockquote>
<h3 id="枚举定义中的泛型"><a href="#枚举定义中的泛型" class="headerlink" title="枚举定义中的泛型"></a>枚举定义中的泛型</h3><p>和结构体类似，枚举也可以在成员中存放泛型数据类型。第 6 章我们曾用过标准库提供的 <code>Option&lt;T&gt;</code> 枚举，这里再回顾一下：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Option</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="title function_ invoke__">Some</span>(T),</span><br><span class="line">    <span class="literal">None</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在这个定义应该更容易理解了。如你所见 <code>Option&lt;T&gt;</code> 是一个拥有泛型 <code>T</code> 的枚举，它有两个成员：<code>Some</code>，它存放了一个类型 <code>T</code> 的值，和不存在任何值的 <code>None</code>。通过 <code>Option&lt;T&gt;</code> 枚举可以表达有一个可能的值的抽象概念，同时因为 <code>Option&lt;T&gt;</code> 是泛型的，无论这个可能的值是什么类型都可以使用这个抽象。</p>
<p>枚举也可以拥有多个泛型类型。第 9 章使用过的 <code>Result</code> 枚举定义就是一个这样的例子：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Result</span>&lt;T, E&gt; &#123;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(T),</span><br><span class="line">    <span class="title function_ invoke__">Err</span>(E),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Result</code> 枚举有两个泛型类型，<code>T</code> 和 <code>E</code>。<code>Result</code> 有两个成员：<code>Ok</code>，它存放一个类型 <code>T</code> 的值，而 <code>Err</code> 则存放一个类型 <code>E</code> 的值。这个定义使得 <code>Result</code> 枚举能很方便的表达任何可能成功（返回 <code>T</code> 类型的值）也可能失败（返回 <code>E</code> 类型的值）的操作。实际上，这就是我们在示例 9-3 用来打开文件的方式：当成功打开文件的时候，<code>T</code> 对应的是 <code>std::fs::File</code> 类型；而当打开文件出现问题时，<code>E</code> 的值则是 <code>std::io::Error</code> 类型。</p>
<p>当你意识到代码中定义了多个结构体或枚举，它们不一样的地方只是其中的值的类型的时候，不妨通过泛型类型来避免重复。</p>
<blockquote>
<p>这个其实也还好</p>
</blockquote>
<h3 id="方法定义中的泛型"><a href="#方法定义中的泛型" class="headerlink" title="方法定义中的泛型"></a>方法定义中的泛型</h3><p>在为结构体和枚举实现方法时（像第 5 章那样），一样也可以用泛型。示例 10-9 中展示了示例 10-6 中定义的结构体 <code>Point&lt;T&gt;</code>，和在其上实现的名为 <code>x</code> 的方法。</p>
<p>文件名: src&#x2F;main.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span>&lt;T&gt; &#123;</span><br><span class="line">    x: T,</span><br><span class="line">    y: T,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Point&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">x</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;T &#123;</span><br><span class="line">        &amp;<span class="keyword">self</span>.x</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p</span> = Point &#123; x: <span class="number">5</span>, y: <span class="number">10</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;p.x = &#123;&#125;&quot;</span>, p.<span class="title function_ invoke__">x</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例 10-9：在 <code>Point&lt;T&gt;</code> 结构体上实现方法 <code>x</code>，它返回 <code>T</code> 类型的字段 <code>x</code> 的引用</p>
<p>这里在 <code>Point&lt;T&gt;</code> 上定义了一个叫做 <code>x</code> 的方法来返回字段 <code>x</code> 中数据的引用：</p>
<p>注意必须在 <code>impl</code> 后面声明 <code>T</code>，这样就可以在 <code>Point&lt;T&gt;</code> 上实现的方法中使用它了。在 <code>impl</code> 之后声明泛型 <code>T</code> ，这样 Rust 就知道 <code>Point</code> 的尖括号中的类型是泛型而不是具体类型。</p>
<p>例如，可以选择为 <code>Point&lt;f32&gt;</code> 实例实现方法，而不是为泛型 <code>Point</code> 实例。示例 10-10 展示了一个没有在 <code>impl</code> 之后（的尖括号）声明泛型的例子，这里使用了一个具体类型，<code>f32</code>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Point</span>&lt;<span class="type">f32</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">distance_from_origin</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">f32</span> &#123;</span><br><span class="line">        (<span class="keyword">self</span>.x.<span class="title function_ invoke__">powi</span>(<span class="number">2</span>) + <span class="keyword">self</span>.y.<span class="title function_ invoke__">powi</span>(<span class="number">2</span>)).<span class="title function_ invoke__">sqrt</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例 10-10：构建一个只用于拥有泛型参数 <code>T</code> 的结构体的具体类型的 <code>impl</code> 块</p>
<p>这段代码意味着 <code>Point&lt;f32&gt;</code> 类型会有一个方法 <code>distance_from_origin</code>，而其他 <code>T</code> 不是 <code>f32</code> 类型的 <code>Point&lt;T&gt;</code> 实例则没有定义此方法。这个方法计算点实例与坐标 (0.0, 0.0) 之间的距离，并使用了只能用于浮点型的数学运算符。</p>
<p>结构体定义中的泛型类型参数并不总是与结构体方法签名中使用的泛型是同一类型。示例 10-11 中在示例 10-8 中的结构体 <code>Point&lt;T, U&gt;</code> 上定义了一个方法 <code>mixup</code>。这个方法获取另一个 <code>Point</code> 作为参数，而它可能与调用 <code>mixup</code> 的 <code>self</code> 是不同的 <code>Point</code> 类型。这个方法用 <code>self</code> 的 <code>Point</code> 类型的 <code>x</code> 值（类型 <code>T</code>）和参数的 <code>Point</code> 类型的 <code>y</code> 值（类型 <code>W</code>）来创建一个新 <code>Point</code> 类型的实例：</p>
<p>文件名: src&#x2F;main.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span>&lt;T, U&gt; &#123;</span><br><span class="line">    x: T,</span><br><span class="line">    y: U,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T, U&gt; Point&lt;T, U&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">mixup</span>&lt;V, W&gt;(<span class="keyword">self</span>, other: Point&lt;V, W&gt;) <span class="punctuation">-&gt;</span> Point&lt;T, W&gt; &#123;</span><br><span class="line">        Point &#123;</span><br><span class="line">            x: <span class="keyword">self</span>.x,</span><br><span class="line">            y: other.y,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p1</span> = Point &#123; x: <span class="number">5</span>, y: <span class="number">10.4</span> &#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p2</span> = Point &#123; x: <span class="string">&quot;Hello&quot;</span>, y: <span class="string">&#x27;c&#x27;</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p3</span> = p1.<span class="title function_ invoke__">mixup</span>(p2);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;p3.x = &#123;&#125;, p3.y = &#123;&#125;&quot;</span>, p3.x, p3.y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例 10-11：方法使用了与结构体定义中不同类型的泛型</p>
<p>在 <code>main</code> 函数中，定义了一个有 <code>i32</code> 类型的 <code>x</code>（其值为 <code>5</code>）和 <code>f64</code> 的 <code>y</code>（其值为 <code>10.4</code>）的 <code>Point</code>。<code>p2</code> 则是一个有着字符串 slice 类型的 <code>x</code>（其值为 <code>&quot;Hello&quot;</code>）和 <code>char</code> 类型的 <code>y</code>（其值为 <code>c</code>）的 <code>Point</code>。在 <code>p1</code> 上以 <code>p2</code> 作为参数调用 <code>mixup</code> 会返回一个 <code>p3</code>，它会有一个 <code>i32</code> 类型的 <code>x</code>，因为 <code>x</code> 来自 <code>p1</code>，并拥有一个 <code>char</code> 类型的 <code>y</code>，因为 <code>y</code> 来自 <code>p2</code>。<code>println!</code> 会打印出 <code>p3.x = 5, p3.y = c</code>。</p>
<p>这个例子的目的是展示一些泛型通过 <code>impl</code> 声明而另一些通过方法定义声明的情况。这里泛型参数 <code>T</code> 和 <code>U</code> 声明于 <code>impl</code> 之后，因为他们与结构体定义相对应。而泛型参数 <code>V</code> 和 <code>W</code> 声明于 <code>fn mixup</code> 之后，因为他们只是相对于方法本身的。</p>
<blockquote>
<p>这段稍微有点绕，但是等到自己写代码用到的时候倒腾倒腾应该也还好</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/07/25/RUST%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0%E4%B9%8B%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.png">
      <meta itemprop="name" content="Chillward">
      <meta itemprop="description" content="谁躺在漆黑的舞台上，用身体迎接着光芒">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chillward的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/07/25/RUST%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0%E4%B9%8B%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/" class="post-title-link" itemprop="url">RUST学习日记之错误处理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-07-25 18:15:52" itemprop="dateCreated datePublished" datetime="2025-07-25T18:15:52+08:00">2025-07-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-07-27 15:43:51" itemprop="dateModified" datetime="2025-07-27T15:43:51+08:00">2025-07-27</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>12k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>23 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>以前一直是写C的，对于现代语言的错误处理一直是搞不太懂，不过目前看来Rust的错误处理看起来还是比Java顺眼一点的</p>
</blockquote>
<h2 id="panic与不可恢复的错误"><a href="#panic与不可恢复的错误" class="headerlink" title="panic与不可恢复的错误"></a>panic与不可恢复的错误</h2><p>panic就类似于程序崩溃，程序会直接崩溃掉，这种错误是无法被程序处理的</p>
<p>有的时候代码出问题了，而你对此束手无策。对于这种情况，Rust 有 <code>panic!</code>宏。当执行这个宏时，程序会打印出一个错误信息，展开并清理栈数据，然后接着退出。出现这种情况的场景通常是检测到一些类型的 bug，而且开发者并不清楚该如何处理它。</p>
<blockquote>
<p>当出现 panic 时，程序默认会开始 <strong>展开</strong>（<em>unwinding</em>），这意味着 Rust 会回溯栈并清理它遇到的每一个函数的数据，不过这个回溯并清理的过程有很多工作。另一种选择是直接 <strong>终止</strong>（<em>abort</em>），这会不清理数据就退出程序。那么程序所使用的内存需要由操作系统来清理。如果你需要项目的最终二进制文件越小越好，panic 时通过在 <em>Cargo.toml</em> 的 <code>[profile]</code> 部分增加 <code>panic = &#39;abort&#39;</code>，可以由展开切换为终止。例如，如果你想要在release模式中 panic 时直接终止：</p>
<figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[profile.release]</span></span><br><span class="line"><span class="attr">panic</span> = <span class="string">&#x27;abort&#x27;</span></span><br></pre></td></tr></table></figure></blockquote>
<p>让我们在一个简单的程序中调用 <code>panic!</code>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">panic!</span>(<span class="string">&quot;crash and burn&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行程序将会出现类似这样的输出：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ cargo run</span><br><span class="line">   Compiling panic v0.1.0 (file:///projects/panic)</span><br><span class="line">    Finished dev [unoptimized + debuginfo] target(s) in 0.25s</span><br><span class="line">     Running `target/debug/panic`</span><br><span class="line">thread &#x27;main&#x27; panicked at &#x27;crash and burn&#x27;, src/main.rs:2:5</span><br><span class="line">note: Run with `RUST_BACKTRACE=1` for a backtrace.</span><br></pre></td></tr></table></figure>

<p>最后两行包含 <code>panic!</code> 调用造成的错误信息。第一行显示了 panic 提供的信息并指明了源码中 panic 出现的位置：<em>src&#x2F;main.rs:2:5</em> 表明这是 <em>src&#x2F;main.rs</em> 文件的第二行第五个字符。</p>
<p>在这个例子中，被指明的那一行是我们代码的一部分，而且查看这一行的话就会发现 <code>panic!</code> 宏的调用。在其他情况下，<code>panic!</code> 可能会出现在我们的代码所调用的代码中。错误信息报告的文件名和行号可能指向别人代码中的 <code>panic!</code> 宏调用，而不是我们代码中最终导致 <code>panic!</code> 的那一行。我们可以使用 <code>panic!</code> 被调用的函数的 backtrace 来寻找代码中出问题的地方。下面我们会详细介绍 backtrace 是什么。</p>
<blockquote>
<p>backtrace宏的作用就是让我们可以找到“我们编写的代码中导致程序崩溃的地方”</p>
</blockquote>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    v[<span class="number">99</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是一个越界调用，在C语言中，这段代码会运行，然后给你一个错误的值，这是相当危险的</p>
<p>为了使程序远离这类漏洞，如果尝试读取一个索引不存在的元素，Rust 会停止执行并拒绝继续。尝试运行上面的程序会出现如下：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ cargo run</span><br><span class="line">   Compiling panic v0.1.0 (file:///projects/panic)</span><br><span class="line">    Finished dev [unoptimized + debuginfo] target(s) in 0.27s</span><br><span class="line">     Running `target/debug/panic`</span><br><span class="line">thread &#x27;main&#x27; panicked at &#x27;index out of bounds: the len is 3 but the index is 99&#x27;, libcore/slice/mod.rs:2448:10</span><br><span class="line">note: Run with `RUST_BACKTRACE=1` for a backtrace.</span><br></pre></td></tr></table></figure>

<p>这指向了一个不是我们编写的文件，<em>libcore&#x2F;slice&#x2F;mod.rs</em>。其为 Rust 源码中 <code>slice</code> 的实现。这是当对 vector <code>v</code> 使用 <code>[]</code> 时 <em>libcore&#x2F;slice&#x2F;mod.rs</em> 中会执行的代码，也是真正出现 <code>panic!</code> 的地方。</p>
<p>接下来的几行提醒我们可以设置 <code>RUST_BACKTRACE</code> 环境变量来得到一个 backtrace。<em>backtrace</em> 是一个执行到目前位置所有被调用的函数的列表。Rust 的 backtrace 跟其他语言中的一样：阅读 backtrace 的关键是从头开始读直到发现你编写的文件。这就是问题的发源地。这一行往上是你的代码所调用的代码；往下则是调用你的代码的代码。这些行可能包含核心 Rust 代码，标准库代码或用到的 crate 代码。让我们将 <code>RUST_BACKTRACE</code> 环境变量设置为任何不是 0 的值来获取 backtrace 看看。示例 9-2 展示了与你看到类似的输出：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">$ RUST_BACKTRACE=1 cargo run</span><br><span class="line">    Finished dev [unoptimized + debuginfo] target(s) in 0.00s</span><br><span class="line">     Running `target/debug/panic`</span><br><span class="line">thread &#x27;main&#x27; panicked at &#x27;index out of bounds: the len is 3 but the index is 99&#x27;, libcore/slice/mod.rs:2448:10</span><br><span class="line">stack backtrace:</span><br><span class="line">   0: std::sys::unix::backtrace::tracing::imp::unwind_backtrace</span><br><span class="line">             at libstd/sys/unix/backtrace/tracing/gcc_s.rs:49</span><br><span class="line">   1: std::sys_common::backtrace::print</span><br><span class="line">             at libstd/sys_common/backtrace.rs:71</span><br><span class="line">             at libstd/sys_common/backtrace.rs:59</span><br><span class="line">   2: std::panicking::default_hook::&#123;&#123;closure&#125;&#125;</span><br><span class="line">             at libstd/panicking.rs:211</span><br><span class="line">   3: std::panicking::default_hook</span><br><span class="line">             at libstd/panicking.rs:227</span><br><span class="line">   4: &lt;std::panicking::begin_panic::PanicPayload&lt;A&gt; as core::panic::BoxMeUp&gt;::get</span><br><span class="line">             at libstd/panicking.rs:476</span><br><span class="line">   5: std::panicking::continue_panic_fmt</span><br><span class="line">             at libstd/panicking.rs:390</span><br><span class="line">   6: std::panicking::try::do_call</span><br><span class="line">             at libstd/panicking.rs:325</span><br><span class="line">   7: core::ptr::drop_in_place</span><br><span class="line">             at libcore/panicking.rs:77</span><br><span class="line">   8: core::ptr::drop_in_place</span><br><span class="line">             at libcore/panicking.rs:59</span><br><span class="line">   9: &lt;usize as core::slice::SliceIndex&lt;[T]&gt;&gt;::index</span><br><span class="line">             at libcore/slice/mod.rs:2448</span><br><span class="line">  10: core::slice::&lt;impl core::ops::index::Index&lt;I&gt; for [T]&gt;::index</span><br><span class="line">             at libcore/slice/mod.rs:2316</span><br><span class="line">  11: &lt;alloc::vec::Vec&lt;T&gt; as core::ops::index::Index&lt;I&gt;&gt;::index</span><br><span class="line">             at liballoc/vec.rs:1653</span><br><span class="line">  12: panic::main</span><br><span class="line">             at src/main.rs:4</span><br><span class="line">  13: std::rt::lang_start::&#123;&#123;closure&#125;&#125;</span><br><span class="line">             at libstd/rt.rs:74</span><br><span class="line">  14: std::panicking::try::do_call</span><br><span class="line">             at libstd/rt.rs:59</span><br><span class="line">             at libstd/panicking.rs:310</span><br><span class="line">  15: macho_symbol_search</span><br><span class="line">             at libpanic_unwind/lib.rs:102</span><br><span class="line">  16: std::alloc::default_alloc_error_hook</span><br><span class="line">             at libstd/panicking.rs:289</span><br><span class="line">             at libstd/panic.rs:392</span><br><span class="line">             at libstd/rt.rs:58</span><br><span class="line">  17: std::rt::lang_start</span><br><span class="line">             at libstd/rt.rs:74</span><br><span class="line">  18: panic::main</span><br></pre></td></tr></table></figure>

<p>这种信息一般是从下往上读，直到找到我们自己编写的代码位置</p>
<blockquote>
<p>RUST_BACKTRACE&#x3D;1 cargo run</p>
</blockquote>
<p>我们可以通过终端传递这个环境变量的值来进入BACKTRACE。</p>
<hr>
<p>现在让我们回到C语言</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  <span class="comment">// 用于 printf</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits.h&gt;</span> <span class="comment">// 用于 INT_MIN</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 执行两个整数的除法。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param numerator 被除数。</span></span><br><span class="line"><span class="comment"> * @param denominator 除数。</span></span><br><span class="line"><span class="comment"> * @return int 如果除数不为零，返回计算出的商。</span></span><br><span class="line"><span class="comment"> * 如果除数为零，返回 INT_MIN 表示错误。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">safe_divide</span><span class="params">(<span class="type">int</span> numerator, <span class="type">int</span> denominator)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (denominator == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Error: Division by zero is not allowed.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> INT_MIN; <span class="comment">// 传播错误：返回一个特殊值表示失败</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> numerator / denominator; <span class="comment">// 成功：返回计算结果</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> result;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;--- 正常除法示例 ---\n&quot;</span>);</span><br><span class="line">    result = safe_divide(<span class="number">10</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span> (result != INT_MIN) &#123; <span class="comment">// 检查返回值是否是错误码</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;10 / 2 = %d\n&quot;</span>, result); <span class="comment">// 成功处理</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Error occurred during division.\n&quot;</span>); <span class="comment">// 错误处理</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n--- 除数为零示例 ---\n&quot;</span>);</span><br><span class="line">    result = safe_divide(<span class="number">10</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (result != INT_MIN) &#123; <span class="comment">// 检查返回值是否是错误码</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;10 / 0 = %d\n&quot;</span>, result); <span class="comment">// 理论上不会执行到这里</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Error occurred during division. Cannot divide by zero.\n&quot;</span>); <span class="comment">// 错误处理</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n--- 另一个正常除法示例 ---\n&quot;</span>);</span><br><span class="line">    result = safe_divide(<span class="number">-15</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">if</span> (result != INT_MIN) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;-15 / 3 = %d\n&quot;</span>, result);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Error occurred during division.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当我们写一个除法程序，当我们传”0”为除数，程序很明显不应该崩溃，而是该返回一个标记值来提醒调用者出错了，然后调用者再进行处理，这就是<strong>可恢复的错误</strong>以及<strong>错误的传播</strong>。</p>
<p>C语言中错误的传播相对原始，一般都是通过返回值层层传递，一旦有一层忘记处理这种情况，整个程序的稳定性就会受到极大的影响。 </p>
<p>在讨论Rust中错误的传播前，我们先来讨论Rust对于这种可恢复错误的处理方式。</p>
<hr>
<p>在 Rust 中，<code>Option&lt;T&gt;</code> 和 <code>Result&lt;T, E&gt;</code> 是两个非常核心的枚举（enum），它们是 Rust 强大的<strong>错误处理</strong>和<strong>存在性（presence）管理</strong>机制的基石。它们的设计理念是强制你在编译时处理可能缺失的值或可能发生的错误，从而避免了其他语言中常见的空指针异常和未处理的运行时错误。</p>
<h3 id="Option：处理值可能缺失的情况"><a href="#Option：处理值可能缺失的情况" class="headerlink" title="Option&lt;T&gt;：处理值可能缺失的情况"></a><code>Option&lt;T&gt;</code>：处理值可能缺失的情况</h3><p><code>Option&lt;T&gt;</code> 枚举用来表示一个值<strong>可能存在，也可能不存在</strong>的情况。它的定义如下：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Option</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="literal">None</span>, <span class="comment">// 值不存在</span></span><br><span class="line">    <span class="title function_ invoke__">Some</span>(T), <span class="comment">// 值存在，并包含类型 T 的数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>它解决什么问题？</strong></p>
<p>在许多其他语言（如 C++、Java、Python 等）中，你可能会使用 <code>NULL</code>、<code>null</code> 或 <code>None</code> 来表示一个变量没有值。然而，直接使用这些“空”值往往会导致运行时错误，比如著名的<strong>空指针异常（Null Pointer Exception）</strong>。因为你可能会忘记检查一个值是否为 <code>null</code>，然后尝试对其进行操作。</p>
<p><code>Option&lt;T&gt;</code> 强制你在编译时就处理值存在或不存在的两种情况。如果你尝试直接使用一个 <code>Option&lt;T&gt;</code> 中的值而不先确定它是否是 <code>Some(T)</code>，编译器会报错。</p>
<h3 id="Result：处理可能发生的错误"><a href="#Result：处理可能发生的错误" class="headerlink" title="Result&lt;T, E&gt;：处理可能发生的错误"></a><code>Result&lt;T, E&gt;</code>：处理可能发生的错误</h3><p><code>Result&lt;T, E&gt;</code> 枚举用来表示一个操作<strong>可能成功并返回一个值，也可能失败并返回一个错误</strong>。它的定义如下：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Result</span>&lt;T, E&gt; &#123;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(T),  <span class="comment">// 操作成功，并包含类型 T 的结果数据</span></span><br><span class="line">    <span class="title function_ invoke__">Err</span>(E), <span class="comment">// 操作失败，并包含类型 E 的错误数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>它解决什么问题？</strong></p>
<p>在 C 语言中，你通常通过返回值和错误码来表示函数成功或失败。在 Java&#x2F;Python 等语言中，则通常使用异常（exceptions）。然而，这些方式都有其弊端：</p>
<ul>
<li><strong>C 语言的错误码</strong>：容易被忽略，需要手动检查，且错误信息有限。</li>
<li><strong>异常</strong>：虽然方便，但可能会导致控制流难以预测（“goto 式的错误处理”），且编译器通常不会强制你捕获或声明异常，可能导致未处理的运行时崩溃。</li>
</ul>
<p><code>Result&lt;T, E&gt;</code> 强制你在编译时就考虑并处理成功和失败的两种情况，使得错误处理成为你代码类型系统的一部分。</p>
<p><strong>如何使用？</strong></p>
<p>与 <code>Option</code> 类似，你通常会使用 <code>match</code> 表达式、<code>if let</code> 或 <code>Result</code> 提供的各种方法（如 <code>is_ok()</code>, <code>is_err()</code>, <code>unwrap()</code>, <code>expect()</code>, <code>map_err()</code>, <code>and_then()</code>, <strong><code>?</code> 运算符</strong>等）来处理 <code>Result</code> 值。</p>
<p><strong>示例：</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File; <span class="comment">// 引入文件系统模块</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// 尝试打开一个不存在的文件</span></span><br><span class="line">    <span class="comment">// File::open 返回一个 Result&lt;File, std::io::Error&gt;</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">greeting_file</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">greeting_file</span> = <span class="keyword">match</span> greeting_file &#123;</span><br><span class="line">      <span class="title function_ invoke__">Ok</span>(file) =&gt; file,</span><br><span class="line">      <span class="title function_ invoke__">Err</span>(error) =&gt; &#123;</span><br><span class="line">         <span class="built_in">panic!</span>(<span class="string">&quot;Probled opening the file &#123;:?&#125;&quot;</span>,error) </span><br><span class="line">        &#125;, </span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果上面一行没有 panic，说明文件成功打开了</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;文件 &#x27;hello.txt&#x27; 已成功打开！&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意：如果 hello.txt 不存在，上面的 println! 永远不会执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是Rust中最简单的错误处理，通过match匹配Result&lt;&gt;成员来实现对于错误的处理，但是在上面那段程序中，当打开文件失败时，程序直接崩溃掉了，这很明显不是我们想要的结果，接下来我们引入下一个知识点 <strong>错误的匹配</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"><span class="keyword">use</span> std::io::ErrorKind;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span> = <span class="keyword">match</span> f &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(file) =&gt; file,</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(error) =&gt; <span class="keyword">match</span> error.<span class="title function_ invoke__">kind</span>() &#123;</span><br><span class="line">            ErrorKind::NotFound =&gt; <span class="keyword">match</span> File::<span class="title function_ invoke__">create</span>(<span class="string">&quot;hello.txt&quot;</span>) &#123;</span><br><span class="line">                <span class="title function_ invoke__">Ok</span>(fc) =&gt; fc,</span><br><span class="line">                <span class="title function_ invoke__">Err</span>(e) =&gt; <span class="built_in">panic!</span>(<span class="string">&quot;Problem creating the file: &#123;:?&#125;&quot;</span>, e),</span><br><span class="line">            &#125;,</span><br><span class="line">            other_error =&gt; <span class="built_in">panic!</span>(<span class="string">&quot;Problem opening the file: &#123;:?&#125;&quot;</span>, other_error),</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>File::open</code> 返回的 <code>Err</code> 成员中的值类型 <code>io::Error</code>，它是一个标准库中提供的结构体。这个结构体有一个返回 <code>io::ErrorKind</code> 值的 <code>kind</code> 方法可供调用。<code>io::ErrorKind</code> 是一个标准库提供的枚举，它的成员对应 <code>io</code> 操作可能导致的不同错误类型。我们感兴趣的成员是 <code>ErrorKind::NotFound</code>，它代表尝试打开的文件并不存在。这样，<code>match</code> 就匹配完 <code>f</code> 了，不过对于 <code>error.kind()</code> 还有一个内层 <code>match</code>。</p>
<p>我们希望在内层 <code>match</code> 中检查的条件是 <code>error.kind()</code> 的返回值是否为 <code>ErrorKind</code>的 <code>NotFound</code> 成员。如果是，则尝试通过 <code>File::create</code> 创建文件。然而因为 <code>File::create</code> 也可能会失败，还需要增加一个内层 <code>match</code> 语句。当文件不能被打开，会打印出一个不同的错误信息。外层 <code>match</code> 的最后一个分支保持不变，这样对任何除了文件不存在的错误会使程序 panic。</p>
<p>match确实是强大的，但是有时候我们确实是希望当出现错误时直接panic!掉，此时再写match会有点麻烦，Rust为我们提供了两个简写方法。</p>
<h3 id="unwrap和expect"><a href="#unwrap和expect" class="headerlink" title="unwrap和expect"></a>unwrap<code>和</code>expect</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;hello.txt&quot;</span>).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果调用这段代码时不存在 <em>hello.txt</em> 文件，我们将会看到一个 <code>unwrap</code> 调用 <code>panic!</code> 时提供的错误信息：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">thread &#x27;main&#x27; panicked at &#x27;called `Result::unwrap()` on an `Err` value: Error &#123;</span><br><span class="line">repr: Os &#123; code: 2, message: &quot;No such file or directory&quot; &#125; &#125;&#x27;,</span><br><span class="line">src/libcore/result.rs:906:4</span><br></pre></td></tr></table></figure>

<p>还有另一个类似于 <code>unwrap</code> 的方法它还允许我们选择 <code>panic!</code> 的错误信息：<code>expect</code>。使用 <code>expect</code> 而不是 <code>unwrap</code> 并提供一个好的错误信息可以表明你的意图并更易于追踪 panic 的根源。<code>expect</code> 的语法看起来像这样：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;hello.txt&quot;</span>).<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Failed to open hello.txt&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>expect</code> 与 <code>unwrap</code> 的使用方式一样：返回文件句柄或调用 <code>panic!</code> 宏。<code>expect</code> 在调用 <code>panic!</code> 时使用的错误信息将是我们传递给 <code>expect</code> 的参数，而不像 <code>unwrap</code> 那样使用默认的 <code>panic!</code> 信息。它看起来像这样：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">thread &#x27;main&#x27; panicked at &#x27;Failed to open hello.txt: Error &#123; repr: Os &#123; code:</span><br><span class="line">2, message: &quot;No such file or directory&quot; &#125; &#125;&#x27;, src/libcore/result.rs:906:4</span><br></pre></td></tr></table></figure>

<p>因为这个错误信息以我们指定的文本开始，<code>Failed to open hello.txt</code>，将会更容易找到代码中的错误信息来自何处。如果在多处使用 <code>unwrap</code>，则需要花更多的时间来分析到底是哪一个 <code>unwrap</code> 造成了 panic，因为所有的 <code>unwrap</code> 调用都打印相同的信息。</p>
<p>接下来我们就可以进入到下一个知识点 <strong>错误的传播</strong>，C语言一般都是通过返回值的层层传递来实现错误的传播。传播错误的好处就是这样能更好地控制代码调用，因为比起你代码所拥有的上下文，调用者可能拥有更多信息或逻辑来决定应该如何处理错误。</p>
<p>简单点说错误的传播就是把可能发生的错误返回给调用者，让调用者来处理而不是由被调用的函数来处理</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#![allow(unused)]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"><span class="keyword">use</span> std::io::Read;</span><br><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">read_username_from_file</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">String</span>, io::Error&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">f</span> = <span class="keyword">match</span> f &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(file) =&gt; file,</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(e) =&gt; <span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(e),</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> f.<span class="title function_ invoke__">read_to_string</span>(&amp;<span class="keyword">mut</span> s) &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(_) =&gt; <span class="title function_ invoke__">Ok</span>(s),</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(e) =&gt; <span class="title function_ invoke__">Err</span>(e),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先让我们看看函数的返回值：<code>Result&lt;String, io::Error&gt;</code>。这意味着函数返回一个 <code>Result&lt;T, E&gt;</code> 类型的值，其中泛型参数 <code>T</code> 的具体类型是 <code>String</code>，而 <code>E</code> 的具体类型是 <code>io::Error</code>。如果这个函数没有出任何错误成功返回，函数的调用者会收到一个包含 <code>String</code> 的 <code>Ok</code> 值 —— 函数从文件中读取到的用户名。如果函数遇到任何错误，函数的调用者会收到一个 <code>Err</code> 值，它储存了一个包含更多这个问题相关信息的 <code>io::Error</code> 实例。这里选择 <code>io::Error</code> 作为函数的返回值是因为它正好是函数体中那两个可能会失败的操作的错误返回值：<code>File::open</code> 函数和 <code>read_to_string</code> 方法。</p>
<p>函数体以 <code>File::open</code> 函数开头。接着使用 <code>match</code> 处理返回值 <code>Result</code>，类似于示例 9-4 中的 <code>match</code>，唯一的区别是当 <code>Err</code> 时不再调用 <code>panic!</code>，而是提早返回并将 <code>File::open</code> 返回的错误值作为函数的错误返回值传递给调用者。如果 <code>File::open</code> 成功了，我们将文件句柄储存在变量 <code>f</code> 中并继续。</p>
<p>接着我们在变量 <code>s</code> 中创建了一个新 <code>String</code> 并调用文件句柄 <code>f</code> 的 <code>read_to_string</code> 方法来将文件的内容读取到 <code>s</code> 中。<code>read_to_string</code> 方法也返回一个 <code>Result</code> 因为它也可能会失败：哪怕是 <code>File::open</code> 已经成功了。所以我们需要另一个 <code>match</code> 来处理这个 <code>Result</code>：如果 <code>read_to_string</code> 成功了，那么这个函数就成功了，并返回文件中的用户名，它现在位于被封装进 <code>Ok</code> 的 <code>s</code> 中。如果 <code>read_to_string</code> 失败了，则像之前处理 <code>File::open</code> 的返回值的 <code>match</code> 那样返回错误值。不过并不需要显式的调用 <code>return</code>，因为这是函数的最后一个表达式。</p>
<p>调用这个函数的代码最终会得到一个包含用户名的 <code>Ok</code> 值，或者一个包含 <code>io::Error</code> 的 <code>Err</code> 值。我们无从得知调用者会如何处理这些值。例如，如果他们得到了一个 <code>Err</code> 值，他们可能会选择 <code>panic!</code> 并使程序崩溃、使用一个默认的用户名或者从文件之外的地方寻找用户名。我们没有足够的信息知晓调用者具体会如何尝试，所以将所有的成功或失败信息向上传播，让他们选择合适的处理方法。</p>
<blockquote>
<p>这种写法是相当常见的，Rust也为我们提供了这种情况下可供使用的简写</p>
</blockquote>
<h3 id="传播错误的简写：-运算符"><a href="#传播错误的简写：-运算符" class="headerlink" title="传播错误的简写：? 运算符"></a>传播错误的简写：<code>?</code> 运算符</h3><p>示例 9-7 展示了一个 <code>read_username_from_file</code> 的实现，它实现了与示例 9-6 中的代码相同的功能，不过这个实现使用了 <code>?</code> 运算符：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"><span class="keyword">use</span> std::io::Read;</span><br><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">read_username_from_file</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">String</span>, io::Error&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">f</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;hello.txt&quot;</span>)?;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    f.<span class="title function_ invoke__">read_to_string</span>(&amp;<span class="keyword">mut</span> s)?;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例 9-7：一个使用 <code>?</code> 运算符向调用者返回错误的函数</p>
<p><code>Result</code> 值之后的 <code>?</code> 被定义为与示例 9-6 中定义的处理 <code>Result</code> 值的 <code>match</code> 表达式有着完全相同的工作方式。如果 <code>Result</code> 的值是 <code>Ok</code>，这个表达式将会返回 <code>Ok</code> 中的值而程序将继续执行。如果值是 <code>Err</code>，<code>Err</code> 将作为整个函数的返回值，就好像使用了 <code>return</code> 关键字一样，这样错误值就被传播给了调用者。</p>
<p>示例 9-6 中的 <code>match</code> 表达式与问号运算符所做的有一点不同：<code>?</code> 运算符所使用的错误值被传递给了 <code>from</code> 函数，它定义于标准库的 <code>From</code> trait 中，其用来将错误从一种类型转换为另一种类型。当 <code>?</code> 运算符调用 <code>from</code> 函数时，收到的错误类型被转换为由当前函数返回类型所指定的错误类型。这在当函数返回单个错误类型来代表所有可能失败的方式时很有用，即使其可能会因很多种原因失败。只要每一个错误类型都实现了 <code>from</code> 函数来定义如何将自身转换为返回的错误类型，<code>?</code> 运算符会自动处理这些转换。</p>
<p>在示例 9-7 的上下文中，<code>File::open</code> 调用结尾的 <code>?</code> 将会把 <code>Ok</code> 中的值返回给变量 <code>f</code>。如果出现了错误，<code>?</code> 运算符会提早返回整个函数并将一些 <code>Err</code> 值传播给调用者。同理也适用于 <code>read_to_string</code> 调用结尾的 <code>?</code>。</p>
<p>当你在一个不返回 <code>Result</code> 的函数中需要调用返回 <code>Result</code> 的函数时，文本提供了两种主要的修复方法：</p>
<ol>
<li><p><strong>修改当前函数的返回值类型为 <code>Result&lt;T, E&gt;</code></strong>： 这是最常见和推荐的方法，特别是当你的函数确实需要传播错误时。你将函数的签名从默认的 <code>()</code> 修改为 <code>Result&lt;T, E&gt;</code>，使得它能够兼容 <code>?</code> 运算符传播的错误。</p>
<p><strong>示例：</strong></p>
<p>Rust</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">use std::error::Error; // 引入 Error trait</span><br><span class="line">use std::fs::File;</span><br><span class="line"></span><br><span class="line">// 将 main 函数的返回值类型修改为 Result&lt;(), Box&lt;dyn Error&gt;&gt;</span><br><span class="line">fn main() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; &#123;</span><br><span class="line">    let f = File::open(&quot;hello.txt&quot;)?; // 现在 ? 运算符可以正常工作了</span><br><span class="line"></span><br><span class="line">    // ... 其他操作 ...</span><br><span class="line"></span><br><span class="line">    Ok(()) // 如果所有操作成功，返回 Ok(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong><code>-&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt;</code></strong>：这里 <code>main</code> 函数被声明为返回一个 <code>Result</code>。<ul>
<li><code>Ok(())</code> 表示成功，没有具体返回值。</li>
<li><code>Err(Box&lt;dyn Error&gt;)</code> 表示失败，并包含一个<strong>错误对象</strong>。</li>
</ul>
</li>
<li><strong><code>Box&lt;dyn Error&gt;</code></strong>：这被称为 <strong>“trait 对象”</strong>。它的作用是允许你返回<strong>任何实现了 <code>std::error::Error</code> 这个 trait 的错误类型</strong>。这是 Rust 处理“多种可能错误类型”的一种通用方法。在这里，你可以简单地理解为 <code>main</code> 函数现在可以返回任何类型的错误，只要这个错误实现了 <code>Error</code> trait。</li>
</ul>
</li>
<li><p><strong>在当前函数内使用 <code>match</code> 或 <code>Result</code> 的其他方法处理错误</strong>： 如果你不希望函数传播错误，或者函数不能修改返回值类型（例如，一些回调函数），那么你就必须在当前函数内部显式地处理 <code>Result</code>，而不是使用 <code>?</code> 运算符。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123; <span class="comment">// main 函数的返回值仍然是 ()</span></span><br><span class="line">    <span class="comment">// 使用 match 显式处理 File::open 返回的 Result</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span> = <span class="keyword">match</span> File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;hello.txt&quot;</span>) &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(file) =&gt; file,</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(e) =&gt; &#123;</span><br><span class="line">            <span class="built_in">eprintln!</span>(<span class="string">&quot;Error opening file: &#123;&#125;&quot;</span>, e); <span class="comment">// 打印错误到标准错误输出</span></span><br><span class="line">            <span class="keyword">return</span>; <span class="comment">// 如果发生错误，直接从 main 函数返回，程序终止</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;File opened successfully!&quot;</span>);</span><br><span class="line">    <span class="comment">// ... 继续使用 f ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，我们使用 <code>match</code> 语句来检查 <code>File::open</code> 的结果。如果它返回 <code>Err</code>，我们就打印错误信息并使用 <code>return;</code> 提前退出 <code>main</code> 函数。这样就没有错误需要被“传播”出 <code>main</code> 函数了。</p>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/07/25/RUST%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0%E4%B9%8B%E5%B8%B8%E8%A7%81%E9%9B%86%E5%90%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.png">
      <meta itemprop="name" content="Chillward">
      <meta itemprop="description" content="谁躺在漆黑的舞台上，用身体迎接着光芒">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chillward的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/07/25/RUST%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0%E4%B9%8B%E5%B8%B8%E8%A7%81%E9%9B%86%E5%90%88/" class="post-title-link" itemprop="url">RUST学习日记之常见集合</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-07-25 07:56:03 / 修改时间：09:33:23" itemprop="dateCreated datePublished" datetime="2025-07-25T07:56:03+08:00">2025-07-25</time>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>15k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>27 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>RUST标准库中给我们提供了很多集合,这里介绍三种最常见的:</p>
</blockquote>
<ol>
<li>vector</li>
<li>String</li>
<li>hash map</li>
</ol>
<p>可能是类似于CPP中的STL,标准库提供了一些别的数据类型,方便我们使用.</p>
<h2 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h2><p>第一个类型是 <code>Vec&lt;T&gt;</code>，也被称为 <em>vector</em>。vector 允许我们在一个单独的数据结构中储存多个值，所有值在内存中彼此相邻排列。vector 只能储存相同类型的值。它们在拥有一系列项的场景下非常实用，例如文件中的文本行或购物车中商品的价格。</p>
<h3 id="Vector的初始化"><a href="#Vector的初始化" class="headerlink" title="Vector的初始化"></a>Vector的初始化</h3><ol>
<li><code>  ler v:Vec[i32] = Vec::new();</code> 新建一个空的Vec来存储i32类型的值.</li>
<li><code>let v = vec![1,2,3];</code> 利用vec!宏来使用初始值来创建一个Vec.此时Rust可以自动推断出v的类型.</li>
</ol>
<h3 id="Vector的更新"><a href="#Vector的更新" class="headerlink" title="Vector的更新"></a>Vector的更新</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#![allow(unused)]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v</span> = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">v.<span class="title function_ invoke__">push</span>(<span class="number">5</span>);</span><br><span class="line">v.<span class="title function_ invoke__">push</span>(<span class="number">6</span>);</span><br><span class="line">v.<span class="title function_ invoke__">push</span>(<span class="number">7</span>);</span><br><span class="line">v.<span class="title function_ invoke__">push</span>(<span class="number">8</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>很明显,v.push是将值推入Vec中的方法</p>
<p>我们需要注意的一点是:与其他结构类似,当vector离开他的作用域时会被销毁,并且当存在一个有效的不可变引用时,是没办法通过push向vec中新增值的.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">first</span> = &amp;v[<span class="number">0</span>];</span><br><span class="line">v.<span class="title function_ invoke__">push</span>(<span class="number">6</span>);</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;The first element is: &#123;&#125;&quot;</span>, first);</span><br></pre></td></tr></table></figure>



<h3 id="Vector元素的读取"><a href="#Vector元素的读取" class="headerlink" title="Vector元素的读取"></a>Vector元素的读取</h3><ol>
<li>通过索引来读取值</li>
<li>通过.get来读取值</li>
</ol>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#![allow(unused)]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">third</span>: &amp;<span class="type">i32</span> = &amp;v[<span class="number">2</span>];</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;The third element is &#123;&#125;&quot;</span>, third);</span><br><span class="line"></span><br><span class="line"><span class="keyword">match</span> v.<span class="title function_ invoke__">get</span>(<span class="number">2</span>) &#123;</span><br><span class="line">    <span class="title function_ invoke__">Some</span>(third) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;The third element is &#123;&#125;&quot;</span>, third),</span><br><span class="line">    <span class="literal">None</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;There is no third element.&quot;</span>),</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里有两个需要注意的地方。首先，我们使用索引值 <code>2</code> 来获取第三个元素，索引是从 0 开始的。其次，这两个不同的获取第三个元素的方式分别为：使用 <code>&amp;</code> 和 <code>[]</code> 返回一个引用；或者使用 <code>get</code> 方法以索引作为参数来返回一个 <code>Option&lt;&amp;T&gt;</code>。</p>
<blockquote>
<p>使用.get方法可能是更优的,因为当索引越界时,.get方法会返回None,然后你就可以处理而不至于使程序崩溃</p>
</blockquote>
<h3 id="遍历Vector中的元素"><a href="#遍历Vector中的元素" class="headerlink" title="遍历Vector中的元素"></a>遍历Vector中的元素</h3><p>如果想要依次访问 vector 中的每一个元素，我们可以遍历其所有的元素而无需通过索引一次一个的访问。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">100</span>, <span class="number">32</span>, <span class="number">57</span>];</span><br><span class="line"><span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> &amp;v &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们也可以遍历可变 vector 的每一个元素的可变引用以便能改变他们。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">100</span>, <span class="number">32</span>, <span class="number">57</span>];</span><br><span class="line"><span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> &amp;<span class="keyword">mut</span> v &#123;</span><br><span class="line">    *i += <span class="number">50</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了修改可变引用所指向的值，在使用 <code>+=</code> 运算符之前必须使用解引用运算符（<code>*</code>）获取 <code>i</code> 中的值。</p>
<h3 id="使用枚举来储存多种类型"><a href="#使用枚举来储存多种类型" class="headerlink" title="使用枚举来储存多种类型"></a>使用枚举来储存多种类型</h3><p>在本章的开始，我们提到 vector 只能储存相同类型的值。这是很不方便的；绝对会有需要储存一系列不同类型的值的用例。幸运的是，枚举的成员都被定义为相同的枚举类型，所以当需要在 vector 中储存不同类型值时，我们可以定义并使用一个枚举！</p>
<p>例如，假如我们想要从电子表格的一行中获取值，而这一行的有些列包含数字，有些包含浮点值，还有些是字符串。我们可以定义一个枚举，其成员会存放这些不同类型的值，同时所有这些枚举成员都会被当作相同类型，那个枚举的类型。接着可以创建一个储存枚举值的 vector，这样最终就能够储存不同类型的值了。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">SpreadsheetCell</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Int</span>(<span class="type">i32</span>),</span><br><span class="line">    <span class="title function_ invoke__">Float</span>(<span class="type">f64</span>),</span><br><span class="line">    <span class="title function_ invoke__">Text</span>(<span class="type">String</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">row</span> = <span class="built_in">vec!</span>[</span><br><span class="line">    SpreadsheetCell::<span class="title function_ invoke__">Int</span>(<span class="number">3</span>),</span><br><span class="line">    SpreadsheetCell::<span class="title function_ invoke__">Text</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;blue&quot;</span>)),</span><br><span class="line">    SpreadsheetCell::<span class="title function_ invoke__">Float</span>(<span class="number">10.12</span>),</span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<p>Rust 在编译时就必须准确的知道 vector 中类型的原因在于它需要知道储存每个元素到底需要多少内存。第二个好处是可以准确的知道这个  vector 中允许什么类型。如果 Rust 允许 vector 存放任意类型，那么当对 vector  元素执行操作时一个或多个类型的值就有可能会造成错误。使用枚举外加 <code>match</code> 意味着 Rust 能在编译时就保证总是会处理所有可能的情况，正如第 6 章讲到的那样。</p>
<p>如果在编写程序时不能确切无遗地知道运行时会储存进 vector 的所有类型，枚举技术就行不通了。相反，你可以使用 trait 对象，第 17 章会讲到它。</p>
<p>现在我们了解了一些使用 vector 的最常见的方式，请一定去看看标准库中 <code>Vec</code> 定义的很多其他实用方法的 API 文档。例如，除了 <code>push</code> 之外还有一个 <code>pop</code> 方法，它会移除并返回 vector 的最后一个元素。</p>
<h2 id="String类型"><a href="#String类型" class="headerlink" title="String类型"></a>String类型</h2><p>在 Rust 中，字符串并非单一类型，而是通常指两种主要的 UTF-8 编码类型：<strong><code>str</code>（字符串 slice）</strong> 和 <strong><code>String</code></strong>。</p>
<p>具体来说，它涵盖了以下几个要点：</p>
<ul>
<li><strong><code>str</code> (字符串 slice)</strong>：<ul>
<li>这是 Rust <strong>核心语言</strong>中唯一的字符串类型。</li>
<li>它通常以 <strong>被借用的形式 <code>&amp;str</code></strong> 出现。</li>
<li><code>&amp;str</code> 是对储存在<strong>别处</strong>（例如程序二进制输出中的字符串字面量）的 UTF-8 编码字符串数据的<strong>引用</strong>。它们是不可变且固定大小的。</li>
</ul>
</li>
<li><strong><code>String</code></strong>：<ul>
<li>这是由 Rust <strong>标准库提供</strong>的类型，不属于核心语言。</li>
<li>它是一种<strong>可增长的、可变的、有所有权</strong>的 UTF-8 编码字符串类型。</li>
<li><code>String</code> 类型的数据存储在堆上，可以根据需要进行扩展和修改。</li>
</ul>
</li>
<li><strong>“字符串”的通用指代</strong>：<ul>
<li>当 Rust 开发者（Rustacean）提到“字符串”时，通常指的是 <strong><code>String</code> 和 <code>&amp;str</code> 这两种类型</strong>，而不是特指其中一个。</li>
<li>这两种类型在 Rust 标准库中都非常常用，且都使用 <strong>UTF-8 编码</strong>。</li>
</ul>
</li>
<li><strong>其他字符串类型</strong>：<ul>
<li>除了 <code>String</code> 和 <code>&amp;str</code>，Rust 标准库还提供了其他字符串类型，如 <code>OsString</code>、<code>OsStr</code>、<code>CString</code> 和 <code>CStr</code>。</li>
<li>这些类型通常以 <code>String</code> 或 <code>Str</code> 结尾，分别对应其所有权（<code>String</code> 变体）和可借用（<code>Str</code> 变体）的特性。</li>
<li>它们可能用于存储不同编码或内存表示形式的文本内容（例如与操作系统或 C 语言交互时）。</li>
</ul>
</li>
</ul>
<blockquote>
<p>官方文档下头这段写得还是很像人话的,我们之间复制过来,需要注意的是,rust中的字符串默认是UTF-8而不是ASCII,所以会出现一些在C语言中不会出现的问题,C语言中与之对应的知识是wchar,即宽字符.</p>
</blockquote>
<h3 id="新建字符串"><a href="#新建字符串" class="headerlink" title="新建字符串"></a><a target="_blank" rel="noopener" href="https://rustwiki.org/zh-CN/book/ch08-02-strings.html#%E6%96%B0%E5%BB%BA%E5%AD%97%E7%AC%A6%E4%B8%B2">新建字符串</a></h3><p>很多 <code>Vec</code> 可用的操作在 <code>String</code> 中同样可用，从 <code>new</code> 函数创建字符串开始，如示例 8-11 所示。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br></pre></td></tr></table></figure>

<p>示例 8-11：新建一个空的 <code>String</code></p>
<p>这新建了一个叫做 <code>s</code> 的空的字符串，接着我们可以向其中装载数据。通常字符串会有初始数据，因为我们希望一开始就有这个字符串。为此，可以使用 <code>to_string</code> 方法，它能用于任何实现了 <code>Display</code> trait 的类型，字符串字面量也实现了它。示例 8-12 展示了两个例子。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">data</span> = <span class="string">&quot;initial contents&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = data.<span class="title function_ invoke__">to_string</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 该方法也可直接用于字符串字面量：</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="string">&quot;initial contents&quot;</span>.<span class="title function_ invoke__">to_string</span>();</span><br></pre></td></tr></table></figure>

<p>示例 8-12：使用 <code>to_string</code> 方法从字符串字面量创建 <code>String</code></p>
<p>这些代码会创建包含 <code>initial contents</code> 的字符串。</p>
<p>也可以使用 <code>String::from</code> 函数来从字符串字面量创建 <code>String</code>。示例 8-13 中的代码等同于使用 <code>to_string</code>。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;initial contents&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>示例 8-13：使用 <code>String::from</code> 函数从字符串字面量创建 <code>String</code></p>
<p>因为字符串应用广泛，这里有很多不同的用于字符串的通用 API 可供选择。其中一些可能看起来多余，不过都有其用武之地！在这个例子中，<code>String::from</code> 和 <code>to_string</code> 最终做到了完全相同的事情，所以如何选择，就是风格问题了。</p>
<p>请记住，字符串是 UTF-8 编码的，所以可以包含任何正确编码的数据，如示例 8-14 所示。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">hello</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;السلام عليكم&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">hello</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Dobrý den&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">hello</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">hello</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;שָׁלוֹם&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">hello</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;नमस्ते&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">hello</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;こんにちは&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">hello</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;안녕하세요&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">hello</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;你好&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">hello</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Olá&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">hello</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Здравствуйте&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">hello</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hola&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>示例 8-14：在字符串中储存不同语言的问候语</p>
<p>所有这些都是有效的 <code>String</code> 值。</p>
<h3 id="更新字符串"><a href="#更新字符串" class="headerlink" title="更新字符串"></a><a target="_blank" rel="noopener" href="https://rustwiki.org/zh-CN/book/ch08-02-strings.html#%E6%9B%B4%E6%96%B0%E5%AD%97%E7%AC%A6%E4%B8%B2">更新字符串</a></h3><p><code>String</code> 的大小可以增加，其内容也可以改变，就像可以放入更多数据来改变 <code>Vec</code> 的内容一样。另外，可以方便的使用 <code>+</code> 运算符或 <code>format!</code> 宏来拼接 <code>String</code> 值。</p>
<h4 id="使用-push-str-和-push-附加字符串"><a href="#使用-push-str-和-push-附加字符串" class="headerlink" title="使用 push_str 和 push 附加字符串"></a><a target="_blank" rel="noopener" href="https://rustwiki.org/zh-CN/book/ch08-02-strings.html#%E4%BD%BF%E7%94%A8-push_str-%E5%92%8C-push-%E9%99%84%E5%8A%A0%E5%AD%97%E7%AC%A6%E4%B8%B2">使用 <code>push_str</code> 和 <code>push</code> 附加字符串</a></h4><p>可以通过 <code>push_str</code> 方法来附加字符串 slice，从而使 <code>String</code> 变长，如示例 8-15 所示。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line">s.<span class="title function_ invoke__">push_str</span>(<span class="string">&quot;bar&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>示例 8-15：使用 <code>push_str</code> 方法向 <code>String</code> 附加字符串 slice</p>
<p>执行这两行代码之后，<code>s</code> 将会包含 <code>foobar</code>。<code>push_str</code> 方法采用字符串 slice，因为我们并不需要获取参数的所有权。例如，示例 8-16 展示了如果将 <code>s2</code> 的内容附加到 <code>s1</code> 之后，自身不能被使用就糟糕了。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s2</span> = <span class="string">&quot;bar&quot;</span>;</span><br><span class="line">s1.<span class="title function_ invoke__">push_str</span>(s2);</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;s2 is &#123;&#125;&quot;</span>, s2);</span><br></pre></td></tr></table></figure>

<p>示例 8-16：将字符串 slice 的内容附加到 <code>String</code> 后使用它</p>
<p>如果 <code>push_str</code> 方法获取了 <code>s2</code> 的所有权，就不能在最后一行打印出其值了。好在代码如我们期望那样工作！</p>
<p><code>push</code> 方法被定义为获取一个单独的字符作为参数，并附加到 <code>String</code> 中。示例 8-17 展示了使用 <code>push</code> 方法将字母 <em>l</em> 加入 <code>String</code> 的代码。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;lo&quot;</span>);</span><br><span class="line">s.<span class="title function_ invoke__">push</span>(<span class="string">&#x27;l&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>示例 8-17：使用 <code>push</code> 将一个字符加入 <code>String</code> 值中</p>
<p>执行这些代码之后，<code>s</code> 将会包含 <code>lol</code>。</p>
<h4 id="使用-运算符或-format-宏拼接字符串"><a href="#使用-运算符或-format-宏拼接字符串" class="headerlink" title="使用 + 运算符或 format! 宏拼接字符串"></a><a target="_blank" rel="noopener" href="https://rustwiki.org/zh-CN/book/ch08-02-strings.html#%E4%BD%BF%E7%94%A8--%E8%BF%90%E7%AE%97%E7%AC%A6%E6%88%96-format-%E5%AE%8F%E6%8B%BC%E6%8E%A5%E5%AD%97%E7%AC%A6%E4%B8%B2">使用 <code>+</code> 运算符或 <code>format!</code> 宏拼接字符串</a></h4><p>通常你会希望将两个已知的字符串合并在一起。一种办法是像这样使用 <code>+</code> 运算符，如示例 8-18 所示。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello, &quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s2</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;world!&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s3</span> = s1 + &amp;s2; <span class="comment">// 注意 s1 被移动了，不能继续使用</span></span><br></pre></td></tr></table></figure>

<p>示例 8-18：使用 <code>+</code> 运算符将两个 <code>String</code> 值合并到一个新的 <code>String</code> 值中</p>
<p>执行完这些代码之后，字符串 <code>s3</code> 将会包含 <code>Hello, world!</code>。<code>s1</code> 在相加后不再有效的原因，和使用 <code>s2</code> 的引用的原因，与使用 <code>+</code> 运算符时调用的函数签名有关。<code>+</code> 运算符使用了 <code>add</code> 函数，这个函数签名看起来像这样：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">add</span>(<span class="keyword">self</span>, s: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br></pre></td></tr></table></figure>

<p>这并不是标准库中实际的签名；标准库中的 <code>add</code> 使用泛型定义。这里我们看到的 <code>add</code> 的签名使用具体类型代替了泛型，这也正是当使用 <code>String</code> 值调用这个方法会发生的。第 10 章会讨论泛型。这个签名提供了理解 <code>+</code> 运算那微妙部分的线索。</p>
<p>首先，<code>s2</code> 使用了 <code>&amp;</code>，意味着我们使用第二个字符串的 <strong>引用</strong> 与第一个字符串相加。这是因为 <code>add</code> 函数的 <code>s</code> 参数：只能将 <code>&amp;str</code> 和 <code>String</code> 相加，不能将两个 <code>String</code> 值相加。不过等一下 —— 正如 <code>add</code> 的第二个参数所指定的，<code>&amp;s2</code> 的类型是 <code>&amp;String</code> 而不是 <code>&amp;str</code>。那么为什么示例 8-18 还能编译呢？</p>
<p>之所以能够在 <code>add</code> 调用中使用 <code>&amp;s2</code> 是因为 <code>&amp;String</code> 可以被 <strong>强转</strong>（<em>coerced</em>）成 <code>&amp;str</code>。当 <code>add</code> 函数被调用时，Rust 使用了一个被称为 <strong>解引用强制转换</strong>（<em>deref coercion</em>）的技术，你可以将其理解为它把 <code>&amp;s2</code> 变成了 <code>&amp;s2[..]</code>。第 15 章会更深入的讨论解引用强制转换。因为 <code>add</code> 没有获取参数的所有权，所以 <code>s2</code> 在这个操作后仍然是有效的 <code>String</code>。</p>
<p>其次，可以发现签名中 <code>add</code> 获取了 <code>self</code> 的所有权，因为 <code>self</code> <strong>没有</strong> 使用 <code>&amp;</code>。这意味着示例 8-18 中的 <code>s1</code> 的所有权将被移动到 <code>add</code> 调用中，之后就不再有效。虽然 <code>let s3 = s1 + &amp;s2;</code> 看起来就像它会复制两个字符串并创建一个新的字符串，而实际上这个语句会获取 <code>s1</code> 的所有权，附加上从 <code>s2</code> 中拷贝的内容，并返回结果的所有权。换句话说，它看起来好像生成了很多拷贝，不过实际上并没有：这个实现比拷贝要更高效。</p>
<p>如果想要级联多个字符串，<code>+</code> 的行为就显得笨重了：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;tic&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s2</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;tac&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s3</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;toe&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = s1 + <span class="string">&quot;-&quot;</span> + &amp;s2 + <span class="string">&quot;-&quot;</span> + &amp;s3;</span><br></pre></td></tr></table></figure>

<p>这时 <code>s</code> 的内容会是 <code>tic-tac-toe</code>。在有这么多 <code>+</code> 和 <code>&quot;</code> 字符的情况下，很难理解具体发生了什么。对于更为复杂的字符串连接，可以使用 <code>format!</code> 宏：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;tic&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s2</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;tac&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s3</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;toe&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125;-&#123;&#125;-&#123;&#125;&quot;</span>, s1, s2, s3);</span><br></pre></td></tr></table></figure>

<p>这些代码也会将 <code>s</code> 设置为 “tic-tac-toe”。<code>format!</code> 与 <code>println!</code> 的工作原理相同，不过不同于将输出打印到屏幕上，它返回一个带有结果内容的 <code>String</code>。这个版本就好理解的多，并且不会获取任何参数的所有权。</p>
<h3 id="索引字符串"><a href="#索引字符串" class="headerlink" title="索引字符串"></a><a target="_blank" rel="noopener" href="https://rustwiki.org/zh-CN/book/ch08-02-strings.html#%E7%B4%A2%E5%BC%95%E5%AD%97%E7%AC%A6%E4%B8%B2">索引字符串</a></h3><p>在很多语言中，通过索引来引用字符串中的单独字符是有效且常见的操作。然而在 Rust 中，如果你尝试使用索引语法访问 <code>String</code> 的一部分，会出现一个错误。考虑一下如示例 8-19 中所示的无效代码。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">h</span> = s1[<span class="number">0</span>];</span><br></pre></td></tr></table></figure>

<p>示例 8-19：尝试对字符串使用索引语法</p>
<p>这段代码会导致如下错误：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">error[E0277]: the trait bound `std::string::String: std::ops::Index&lt;&#123;integer&#125;&gt;` is not satisfied</span><br><span class="line"> --&gt;</span><br><span class="line">  |</span><br><span class="line">3 |     let h = s1[0];</span><br><span class="line">  |             ^^^^^ the type `std::string::String` cannot be indexed by `&#123;integer&#125;`</span><br><span class="line">  |</span><br><span class="line">  = help: the trait `std::ops::Index&lt;&#123;integer&#125;&gt;` is not implemented for `std::string::String`</span><br></pre></td></tr></table></figure>

<p>错误和提示说明了全部问题：Rust 的字符串不支持索引。那么接下来的问题是，为什么不支持呢？为了回答这个问题，我们必须先聊一聊 Rust 是如何在内存中储存字符串的。</p>
<h4 id="内部表现"><a href="#内部表现" class="headerlink" title="内部表现"></a><a target="_blank" rel="noopener" href="https://rustwiki.org/zh-CN/book/ch08-02-strings.html#%E5%86%85%E9%83%A8%E8%A1%A8%E7%8E%B0">内部表现</a></h4><p><code>String</code> 是一个 <code>Vec&lt;u8&gt;</code> 的封装。让我们看看示例 8-14 中一些正确编码的字符串的例子。首先是这一个：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">len</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hola&quot;</span>).<span class="title function_ invoke__">len</span>();</span><br></pre></td></tr></table></figure>

<p>在这里，<code>len</code> 的值是 4 ，这意味着储存字符串 “Hola” 的 <code>Vec</code> 的长度是 4 个字节：这里每一个字母的 UTF-8 编码都占用 1 个字节。那下面这个例子又如何呢？（注意这个字符串中的首字母是西里尔字母的 Ze，而不是阿拉伯数字 3 。）</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">len</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Здравствуйте&quot;</span>).<span class="title function_ invoke__">len</span>();</span><br></pre></td></tr></table></figure>

<p>当问及这个字符是多长的时候有人可能会说是 12。然而，Rust 的回答是 24。这是使用 UTF-8 编码 “Здравствуйте”  所需要的字节数，这是因为每个 Unicode 标量值需要 2 个字节存储。因此一个字符串字节值的索引并不总是对应一个有效的 Unicode  标量值。作为演示，考虑如下无效的 Rust 代码：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">hello</span> = <span class="string">&quot;Здравствуйте&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">answer</span> = &amp;hello[<span class="number">0</span>];</span><br></pre></td></tr></table></figure>

<p><code>answer</code> 的值应该是什么呢？它应该是第一个字符 <code>З</code> 吗？当使用 UTF-8 编码时，<code>З</code> 的第一个字节 <code>208</code>，第二个是 <code>151</code>，所以 <code>answer</code> 实际上应该是 <code>208</code>，不过 <code>208</code> 自身并不是一个有效的字母。返回 <code>208</code> 可不是一个请求字符串第一个字母的人所希望看到的，不过它是 Rust 在字节索引 0 位置所能提供的唯一数据。用户通常不会想要一个字节值被返回，即便这个字符串只有拉丁字母： 即便 <code>&amp;&quot;hello&quot;[0]</code> 是返回字节值的有效代码，它也应当返回 <code>104</code> 而不是 <code>h</code>。为了避免返回意外的值并造成不能立刻发现的 bug，Rust 根本不会编译这些代码，并在开发过程中及早杜绝了误会的发生。</p>
<h4 id="字节、标量值和字形簇！天呐！"><a href="#字节、标量值和字形簇！天呐！" class="headerlink" title="字节、标量值和字形簇！天呐！"></a><a target="_blank" rel="noopener" href="https://rustwiki.org/zh-CN/book/ch08-02-strings.html#%E5%AD%97%E8%8A%82%E6%A0%87%E9%87%8F%E5%80%BC%E5%92%8C%E5%AD%97%E5%BD%A2%E7%B0%87%E5%A4%A9%E5%91%90">字节、标量值和字形簇！天呐！</a></h4><p>这引起了关于 UTF-8 的另外一个问题：从 Rust 的角度来讲，事实上有三种相关方式可以理解字符串：字节、标量值和字形簇（最接近人们眼中 <strong>字母</strong> 的概念）。</p>
<p>比如这个用梵文书写的印度语单词 “नमस्ते”，最终它储存在 vector 中的 <code>u8</code> 值看起来像这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[224, 164, 168, 224, 164, 174, 224, 164, 184, 224, 165, 141, 224, 164, 164, 224, 165, 135]</span><br></pre></td></tr></table></figure>

<p>这里有 18 个字节，也就是计算机最终会储存的数据。如果从 Unicode 标量值的角度理解它们，也就像 Rust 的 <code>char</code> 类型那样，这些字节看起来像这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&#x27;न&#x27;, &#x27;म&#x27;, &#x27;स&#x27;, &#x27;्&#x27;, &#x27;त&#x27;, &#x27;े&#x27;]</span><br></pre></td></tr></table></figure>

<p>这里有六个 <code>char</code>，不过第四个和第六个都不是字母，它们是发音符号本身并没有任何意义。最后，如果以字形簇的角度理解，就会得到人们所说的构成这个单词的四个字母：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&quot;न&quot;, &quot;म&quot;, &quot;स्&quot;, &quot;ते&quot;]</span><br></pre></td></tr></table></figure>

<p>Rust 提供了多种不同的方式来解释计算机储存的原始字符串数据，这样程序就可以选择它需要的表现方式，而无所谓是何种人类语言。</p>
<p>最后一个 Rust 不允许使用索引获取 <code>String</code> 字符的原因是，索引操作预期总是需要常数时间 (O(1))。但是对于 <code>String</code> 不可能保证这样的性能，因为 Rust 必须从开头到索引位置遍历来确定有多少有效的字符。</p>
<h3 id="字符串-slice"><a href="#字符串-slice" class="headerlink" title="字符串 slice"></a><a target="_blank" rel="noopener" href="https://rustwiki.org/zh-CN/book/ch08-02-strings.html#%E5%AD%97%E7%AC%A6%E4%B8%B2-slice">字符串 slice</a></h3><p>索引字符串通常是一个坏点子，因为字符串索引应该返回的类型是不明确的：字节值、字符、字形簇或者字符串  slice。因此，如果你真的希望使用索引创建字符串 slice 时，Rust 会要求你更明确一些。为了更明确索引并表明你需要一个字符串  slice，相比使用 <code>[]</code> 和单个值的索引，可以使用 <code>[]</code> 和一个 range 来创建含特定字节的字符串 slice：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">hello</span> = <span class="string">&quot;Здравствуйте&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = &amp;hello[<span class="number">0</span>..<span class="number">4</span>];</span><br></pre></td></tr></table></figure>

<p>这里，<code>s</code> 会是一个 <code>&amp;str</code>，它包含字符串的头 4 个字节。早些时候，我们提到了这些字母都是 2 个字节长的，所以这意味着 <code>s</code> 将会是 “Зд”。</p>
<p>如果获取 <code>&amp;hello[0..1]</code> 会发生什么呢？答案是：Rust 在运行时会 panic，就跟访问 vector 中的无效索引时一样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thread &#x27;main&#x27; panicked at &#x27;byte index 1 is not a char boundary; it is inside &#x27;З&#x27; (bytes 0..2) of `Здравствуйте`&#x27;, src/libcore/str/mod.rs:2188:4</span><br></pre></td></tr></table></figure>

<p>你应该小心谨慎的使用这个操作，因为这么做可能会使你的程序崩溃。</p>
<h3 id="遍历字符串的方法"><a href="#遍历字符串的方法" class="headerlink" title="遍历字符串的方法"></a><a target="_blank" rel="noopener" href="https://rustwiki.org/zh-CN/book/ch08-02-strings.html#%E9%81%8D%E5%8E%86%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%96%B9%E6%B3%95">遍历字符串的方法</a></h3><p>幸运的是，这里还有其他获取字符串元素的方式。</p>
<p>如果你需要操作单独的 Unicode 标量值，最好的选择是使用 <code>chars</code> 方法。对 “नमस्ते” 调用 <code>chars</code> 方法会将其分开并返回六个 <code>char</code> 类型的值，接着就可以遍历其结果来访问每一个元素了：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="variable">c</span> <span class="keyword">in</span> <span class="string">&quot;नमस्ते&quot;</span>.<span class="title function_ invoke__">chars</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这些代码会打印出如下内容：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">न</span><br><span class="line">म</span><br><span class="line">स</span><br><span class="line">्</span><br><span class="line">त</span><br><span class="line">े</span><br></pre></td></tr></table></figure>

<p><code>bytes</code> 方法返回每一个原始字节，这可能会适合你的使用场景：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="variable">b</span> <span class="keyword">in</span> <span class="string">&quot;नमस्ते&quot;</span>.<span class="title function_ invoke__">bytes</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这些代码会打印出组成 <code>String</code> 的 18 个字节：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">224</span></span><br><span class="line"><span class="number">164</span></span><br><span class="line"><span class="comment">// --snip--</span></span><br><span class="line"><span class="number">165</span></span><br><span class="line"><span class="number">135</span></span><br></pre></td></tr></table></figure>

<p>不过请记住有效的 Unicode 标量值可能会由不止一个字节组成。</p>
<p>从字符串中获取字形簇是很复杂的，所以标准库并没有提供这个功能。<a target="_blank" rel="noopener" href="https://crates.io/">crates.io</a> 上有些提供这样功能的 crate。</p>
<h3 id="字符串并不简单"><a href="#字符串并不简单" class="headerlink" title="字符串并不简单"></a><a target="_blank" rel="noopener" href="https://rustwiki.org/zh-CN/book/ch08-02-strings.html#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B9%B6%E4%B8%8D%E7%AE%80%E5%8D%95">字符串并不简单</a></h3><p>总而言之，字符串还是很复杂的。不同的语言选择了不同的向开发者展示其复杂性的方式。Rust 选择了以准确的方式处理 <code>String</code> 数据作为所有 Rust 程序的默认行为，这意味着开发者们必须更多的思考如何预先处理 UTF-8 数据。这种权衡取舍相比其他语言更多的暴露出了字符串的复杂性，不过也使你在开发生命周期后期免于处理涉及非 ASCII 字符的错误。</p>
<blockquote>
<p>哈希map,我在C语言编程时没怎么接触过这个东西,所以不太熟悉,等用到的时候再回来看吧</p>
</blockquote>
<h2 id="哈希-map-储存键值对"><a href="#哈希-map-储存键值对" class="headerlink" title="哈希 map 储存键值对"></a><a target="_blank" rel="noopener" href="https://rustwiki.org/zh-CN/book/ch08-03-hash-maps.html#%E5%93%88%E5%B8%8C-map-%E5%82%A8%E5%AD%98%E9%94%AE%E5%80%BC%E5%AF%B9">哈希 map 储存键值对</a></h2><p>最后介绍的常用集合类型是 <strong>哈希 map</strong>（<em>hash map</em>）。<code>HashMap&lt;K, V&gt;</code> 类型储存了一个键类型 <code>K</code> 对应一个值类型 <code>V</code> 的映射。它通过一个 <strong>哈希函数</strong>（<em>hashing function</em>）来实现映射，决定如何将键和值放入内存中。很多编程语言支持这种数据结构，不过通常有不同的名字：哈希、map、对象、哈希表或者关联数组，仅举几例。</p>
<p>哈希 map 可以用于需要任何类型作为键来寻找数据的情况，而不是像 vector 那样通过索引。例如，在一个游戏中，你可以将每个团队的分数记录到哈希 map 中，其中键是队伍的名字而值是每个队伍的分数。给出一个队名，就能得到他们的得分。</p>
<p>本章我们会介绍哈希 map 的基本 API，不过还有更多吸引人的功能隐藏于标准库在 <code>HashMap&lt;K, V&gt;</code> 上定义的函数中。一如既往请查看标准库文档来了解更多信息。</p>
<h3 id="新建一个哈希-map"><a href="#新建一个哈希-map" class="headerlink" title="新建一个哈希 map"></a><a target="_blank" rel="noopener" href="https://rustwiki.org/zh-CN/book/ch08-03-hash-maps.html#%E6%96%B0%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%93%88%E5%B8%8C-map">新建一个哈希 map</a></h3><p>可以使用 <code>new</code> 创建一个空的 <code>HashMap</code>，并使用 <code>insert</code> 增加元素。在示例 8-20 中我们记录两支队伍的分数，分别是蓝队和黄队。蓝队开始有 10 分而黄队开始有 50 分：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">scores</span> = HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line">scores.<span class="title function_ invoke__">insert</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Blue&quot;</span>), <span class="number">10</span>);</span><br><span class="line">scores.<span class="title function_ invoke__">insert</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Yellow&quot;</span>), <span class="number">50</span>);</span><br></pre></td></tr></table></figure>

<p>示例 8-20：新建一个哈希 map 并插入一些键值对</p>
<p>注意必须首先 <code>use</code> 标准库中集合部分的 <code>HashMap</code>。在这三个常用集合中，<code>HashMap</code> 是最不常用的，所以并没有被 prelude 自动引用。标准库中对 <code>HashMap</code> 的支持也相对较少，例如，并没有内建的构建宏。</p>
<p>像 vector 一样，哈希 map 将它们的数据储存在堆上，这个 <code>HashMap</code> 的键类型是 <code>String</code> 而值类型是 <code>i32</code>。类似于 vector，哈希 map 是同质的：所有的键必须是相同类型，值也必须都是相同类型。</p>
<p>另一个构建哈希 map 的方法是使用一个元组的 vector 的 <code>collect</code> 方法，其中每个元组包含一个键值对。<code>collect</code> 方法可以将数据收集进一系列的集合类型，包括 <code>HashMap</code>。例如，如果队伍的名字和初始分数分别在两个 vector 中，可以使用 <code>zip</code> 方法来创建一个元组的 vector，其中 “Blue” 与 10 是一对，依此类推。接着就可以使用 <code>collect</code> 方法将这个元组 vector 转换成一个 <code>HashMap</code>，如示例 8-21 所示：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">teams</span>  = <span class="built_in">vec!</span>[<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Blue&quot;</span>), <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Yellow&quot;</span>)];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">initial_scores</span> = <span class="built_in">vec!</span>[<span class="number">10</span>, <span class="number">50</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">scores</span>: HashMap&lt;_, _&gt; = teams.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">zip</span>(initial_scores.<span class="title function_ invoke__">iter</span>()).<span class="title function_ invoke__">collect</span>();</span><br></pre></td></tr></table></figure>

<p>示例 8-21：用队伍列表和分数列表创建哈希 map</p>
<p>这里 <code>HashMap&lt;_, _&gt;</code> 类型标注是必要的，因为 <code>collect</code> 有可能当成多种不同的数据结构，而除非显式指定否则 Rust 无从得知你需要的类型。但是对于键和值的类型参数来说，可以使用下划线占位，而 Rust 能够根据 vector 中数据的类型推断出 <code>HashMap</code> 所包含的类型。</p>
<h3 id="哈希-map-和所有权"><a href="#哈希-map-和所有权" class="headerlink" title="哈希 map 和所有权"></a><a target="_blank" rel="noopener" href="https://rustwiki.org/zh-CN/book/ch08-03-hash-maps.html#%E5%93%88%E5%B8%8C-map-%E5%92%8C%E6%89%80%E6%9C%89%E6%9D%83">哈希 map 和所有权</a></h3><p>对于像 <code>i32</code> 这样的实现了 <code>Copy</code> trait 的类型，其值可以拷贝进哈希 map。对于像 <code>String</code> 这样拥有所有权的值，其值将被移动而哈希 map 会成为这些值的所有者，如示例 8-22 所示：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">field_name</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Favorite color&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">field_value</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Blue&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">map</span> = HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line">map.<span class="title function_ invoke__">insert</span>(field_name, field_value);</span><br><span class="line"><span class="comment">// 这里 field_name 和 field_value 不再有效，</span></span><br><span class="line"><span class="comment">// 尝试使用它们看看会出现什么编译错误！</span></span><br></pre></td></tr></table></figure>

<p>示例 8-22：展示一旦键值对被插入后就为哈希 map 所拥有</p>
<p>当 <code>insert</code> 调用将 <code>field_name</code> 和 <code>field_value</code> 移动到哈希 map 中后，将不能使用这两个绑定。</p>
<p>如果将值的引用插入哈希 map，这些值本身将不会被移动进哈希 map。但是这些引用指向的值必须至少在哈希 map 有效时也是有效的。第 10 章 <a target="_blank" rel="noopener" href="https://rustwiki.org/zh-CN/book/ch10-03-lifetime-syntax.html#validating-references-with-lifetimes">“生命周期与引用有效性”</a> 部分将会更多的讨论这个问题。</p>
<h3 id="访问哈希-map-中的值"><a href="#访问哈希-map-中的值" class="headerlink" title="访问哈希 map 中的值"></a><a target="_blank" rel="noopener" href="https://rustwiki.org/zh-CN/book/ch08-03-hash-maps.html#%E8%AE%BF%E9%97%AE%E5%93%88%E5%B8%8C-map-%E4%B8%AD%E7%9A%84%E5%80%BC">访问哈希 map 中的值</a></h3><p>可以通过 <code>get</code> 方法并提供对应的键来从哈希 map 中获取值，如示例 8-23 所示：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">scores</span> = HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line">scores.<span class="title function_ invoke__">insert</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Blue&quot;</span>), <span class="number">10</span>);</span><br><span class="line">scores.<span class="title function_ invoke__">insert</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Yellow&quot;</span>), <span class="number">50</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">team_name</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Blue&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">score</span> = scores.<span class="title function_ invoke__">get</span>(&amp;team_name);</span><br></pre></td></tr></table></figure>

<p>示例 8-23：访问哈希 map 中储存的蓝队分数</p>
<p>这里，<code>score</code> 是与蓝队分数相关的值，应为 <code>Some(10)</code>。因为 <code>get</code> 返回 <code>Option&lt;V&gt;</code>，所以结果被装进 <code>Some</code>；如果某个键在哈希 map 中没有对应的值，<code>get</code> 会返回 <code>None</code>。这时就要用某种第 6 章提到的方法之一来处理 <code>Option</code>。</p>
<p>可以使用与 vector 类似的方式来遍历哈希 map 中的每一个键值对，也就是 <code>for</code> 循环：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">scores</span> = HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line">scores.<span class="title function_ invoke__">insert</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Blue&quot;</span>), <span class="number">10</span>);</span><br><span class="line">scores.<span class="title function_ invoke__">insert</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Yellow&quot;</span>), <span class="number">50</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (key, value) <span class="keyword">in</span> &amp;scores &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;: &#123;&#125;&quot;</span>, key, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这会以任意顺序打印出每一个键值对：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Yellow: <span class="number">50</span></span><br><span class="line">Blue: <span class="number">10</span></span><br></pre></td></tr></table></figure>

<h3 id="更新哈希-map"><a href="#更新哈希-map" class="headerlink" title="更新哈希 map"></a><a target="_blank" rel="noopener" href="https://rustwiki.org/zh-CN/book/ch08-03-hash-maps.html#%E6%9B%B4%E6%96%B0%E5%93%88%E5%B8%8C-map">更新哈希 map</a></h3><p>尽管键值对的数量是可以增长的，不过任何时候，每个键只能关联一个值。当我们想要改变哈希 map 中的数据时，必须决定如何处理一个键已经有值了的情况。可以选择完全无视旧值并用新值代替旧值。可以选择保留旧值而忽略新值，并只在键 <strong>没有</strong> 对应值时增加新值。或者可以结合新旧两值。让我们看看这分别该如何处理！</p>
<h4 id="覆盖一个值"><a href="#覆盖一个值" class="headerlink" title="覆盖一个值"></a><a target="_blank" rel="noopener" href="https://rustwiki.org/zh-CN/book/ch08-03-hash-maps.html#%E8%A6%86%E7%9B%96%E4%B8%80%E4%B8%AA%E5%80%BC">覆盖一个值</a></h4><p>如果我们插入了一个键值对，接着用相同的键插入一个不同的值，与这个键相关联的旧值将被替换。即便示例 8-24 中的代码调用了两次 <code>insert</code>，哈希 map 也只会包含一个键值对，因为两次都是对蓝队的键插入的值：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">scores</span> = HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line">scores.<span class="title function_ invoke__">insert</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Blue&quot;</span>), <span class="number">10</span>);</span><br><span class="line">scores.<span class="title function_ invoke__">insert</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Blue&quot;</span>), <span class="number">25</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, scores);</span><br></pre></td></tr></table></figure>

<p>示例 8-24：替换以特定键储存的值</p>
<p>这会打印出 <code>&#123;&quot;Blue&quot;: 25&#125;</code>。原始的值 <code>10</code> 则被覆盖了。</p>
<h4 id="只在键没有对应值时插入"><a href="#只在键没有对应值时插入" class="headerlink" title="只在键没有对应值时插入"></a><a target="_blank" rel="noopener" href="https://rustwiki.org/zh-CN/book/ch08-03-hash-maps.html#%E5%8F%AA%E5%9C%A8%E9%94%AE%E6%B2%A1%E6%9C%89%E5%AF%B9%E5%BA%94%E5%80%BC%E6%97%B6%E6%8F%92%E5%85%A5">只在键没有对应值时插入</a></h4><p>我们经常会检查某个特定的键是否有值，如果没有就插入一个值。为此哈希 map 有一个特有的 API，叫做 <code>entry</code>，它获取我们想要检查的键作为参数。<code>entry</code> 函数的返回值是一个枚举，<code>Entry</code>，它代表了可能存在也可能不存在的值。比如说我们想要检查黄队的键是否关联了一个值。如果没有，就插入值 50，对于蓝队也是如此。使用 entry API 的代码看起来像示例 8-25 这样：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">scores</span> = HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line">scores.<span class="title function_ invoke__">insert</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Blue&quot;</span>), <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">scores.<span class="title function_ invoke__">entry</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Yellow&quot;</span>)).<span class="title function_ invoke__">or_insert</span>(<span class="number">50</span>);</span><br><span class="line">scores.<span class="title function_ invoke__">entry</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Blue&quot;</span>)).<span class="title function_ invoke__">or_insert</span>(<span class="number">50</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, scores);</span><br></pre></td></tr></table></figure>

<p>示例 8-25：使用 <code>entry</code> 方法只在键没有对应一个值时插入</p>
<p><code>Entry</code> 的 <code>or_insert</code> 方法在键对应的值存在时就返回这个值的可变引用，如果不存在则将参数作为新值插入并返回新值的可变引用。这比编写自己的逻辑要简明的多，另外也与借用检查器结合得更好。</p>
<p>运行示例 8-25 的代码会打印出 <code>&#123;&quot;Yellow&quot;: 50, &quot;Blue&quot;: 10&#125;</code>。第一个 <code>entry</code> 调用会插入黄队的键和值 <code>50</code>，因为黄队并没有一个值。第二个 <code>entry</code> 调用不会改变哈希 map 因为蓝队已经有了值 <code>10</code>。</p>
<h4 id="根据旧值更新一个值"><a href="#根据旧值更新一个值" class="headerlink" title="根据旧值更新一个值"></a><a target="_blank" rel="noopener" href="https://rustwiki.org/zh-CN/book/ch08-03-hash-maps.html#%E6%A0%B9%E6%8D%AE%E6%97%A7%E5%80%BC%E6%9B%B4%E6%96%B0%E4%B8%80%E4%B8%AA%E5%80%BC">根据旧值更新一个值</a></h4><p>另一个常见的哈希 map 的应用场景是找到一个键对应的值并根据旧的值更新它。例如，示例 8-26  中的代码计数一些文本中每一个单词分别出现了多少次。我们使用哈希 map  以单词作为键并递增其值来记录我们遇到过几次这个单词。如果是第一次看到某个单词，就插入值 <code>0</code>。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">text</span> = <span class="string">&quot;hello world wonderful world&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">map</span> = HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="variable">word</span> <span class="keyword">in</span> text.<span class="title function_ invoke__">split_whitespace</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">count</span> = map.<span class="title function_ invoke__">entry</span>(word).<span class="title function_ invoke__">or_insert</span>(<span class="number">0</span>);</span><br><span class="line">    *count += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, map);</span><br></pre></td></tr></table></figure>

<p>示例 8-26：通过哈希 map 储存单词和计数来统计出现次数</p>
<p>这会打印出 <code>&#123;&quot;world&quot;: 2, &quot;hello&quot;: 1, &quot;wonderful&quot;: 1&#125;</code>，<code>or_insert</code> 方法事实上会返回这个键的值的一个可变引用（<code>&amp;mut V</code>）。这里我们将这个可变引用储存在 <code>count</code> 变量中，所以为了赋值必须首先使用星号（<code>*</code>）解引用 <code>count</code>。这个可变引用在 <code>for</code> 循环的结尾离开作用域，这样所有这些改变都是安全的并符合借用规则。</p>
<h3 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a><a target="_blank" rel="noopener" href="https://rustwiki.org/zh-CN/book/ch08-03-hash-maps.html#%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0">哈希函数</a></h3><p><code>HashMap</code> 默认使用一种 “密码学安全的”（“cryptographically strong” ）<a target="_blank" rel="noopener" href="https://rustwiki.org/zh-CN/book/ch08-03-hash-maps.html#siphash">1</a> 哈希函数，它可以抵抗拒绝服务（Denial of Service, DoS）攻击。然而这并不是可用的最快的算法，不过为了更高的安全性值得付出一些性能的代价。如果性能监测显示此哈希函数非常慢，以致于你无法接受，你可以指定一个不同的 <em>hasher</em> 来切换为其它函数。hasher 是一个实现了 <code>BuildHasher</code> trait 的类型。第 10 章会讨论 trait 和如何实现它们。你并不需要从头开始实现你自己的 hasher；<a target="_blank" rel="noopener" href="https://crates.io/">crates.io</a> 有其他人分享的实现了许多常用哈希算法的 hasher 的库。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/07/24/RUST%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0%E4%B9%8B%E6%A8%A1%E5%9D%9703/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.png">
      <meta itemprop="name" content="Chillward">
      <meta itemprop="description" content="谁躺在漆黑的舞台上，用身体迎接着光芒">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chillward的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/07/24/RUST%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0%E4%B9%8B%E6%A8%A1%E5%9D%9703/" class="post-title-link" itemprop="url">RUST学习日记之模块03</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-07-24 18:11:52 / 修改时间：19:07:46" itemprop="dateCreated datePublished" datetime="2025-07-24T18:11:52+08:00">2025-07-24</time>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>9.8k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>18 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>我们依旧先来欣赏一下官方的高速神言,这一节官方主要就是讲了一下 use as还有pub use这三个东西</p>
</blockquote>
<h2 id="使用-use-关键字将名称引入作用域"><a href="#使用-use-关键字将名称引入作用域" class="headerlink" title="使用 use 关键字将名称引入作用域"></a><a target="_blank" rel="noopener" href="https://rustwiki.org/zh-CN/book/ch07-04-bringing-paths-into-scope-with-the-use-keyword.html#%E4%BD%BF%E7%94%A8-use-%E5%85%B3%E9%94%AE%E5%AD%97%E5%B0%86%E5%90%8D%E7%A7%B0%E5%BC%95%E5%85%A5%E4%BD%9C%E7%94%A8%E5%9F%9F">使用 <code>use</code> 关键字将名称引入作用域</a></h2><p>到目前为止，似乎我们编写的用于调用函数的路径都很冗长且重复，并不方便。例如，示例 7-7 中，无论我们选择 <code>add_to_waitlist</code> 函数的绝对路径还是相对路径，每次我们想要调用 <code>add_to_waitlist</code> 时，都必须指定 <code>front_of_house</code> 和 <code>hosting</code>。幸运的是，有一种方法可以简化这个过程。我们可以使用 <code>use</code> 关键字将路径一次性引入作用域，然后调用该路径中的项，就如同它们是本地项一样。</p>
<p>在示例 7-11 中，我们将 <code>crate::front_of_house::hosting</code> 模块引入了 <code>eat_at_restaurant</code> 函数的作用域，而我们只需要指定 <code>hosting::add_to_waitlist</code> 即可在 <code>eat_at_restaurant</code> 中调用 <code>add_to_waitlist</code> 函数。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">mod</span> front_of_house &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">mod</span> hosting &#123;</span><br><span class="line">        <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">add_to_waitlist</span>() &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> crate::front_of_house::hosting;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">eat_at_restaurant</span>() &#123;</span><br><span class="line">    hosting::<span class="title function_ invoke__">add_to_waitlist</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例 7-11: 使用 <code>use</code> 将模块引入作用域</p>
<p>在作用域中增加 <code>use</code> 和路径类似于在文件系统中创建软连接（符号连接，symbolic link）。通过在 crate 根增加 <code>use crate::front_of_house::hosting</code>，现在 <code>hosting</code> 在作用域中就是有效的名称了，如同 <code>hosting</code> 模块被定义于 crate 根一样。通过 <code>use</code> 引入作用域的路径也会检查私有性，同其它路径一样。</p>
<p>你还可以使用 <code>use</code> 和相对路径来将一个项引入作用域。示例 7-12 展示了如何指定相对路径来取得与示例 7-11 中一样的行为。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">mod</span> front_of_house &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">mod</span> hosting &#123;</span><br><span class="line">        <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">add_to_waitlist</span>() &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> front_of_house::hosting;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">eat_at_restaurant</span>() &#123;</span><br><span class="line">    hosting::<span class="title function_ invoke__">add_to_waitlist</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例 7-12: 使用 <code>use</code> 和相对路径将模块引入作用域</p>
<h3 id="创建惯用的-use-路径"><a href="#创建惯用的-use-路径" class="headerlink" title="创建惯用的 use 路径"></a><a target="_blank" rel="noopener" href="https://rustwiki.org/zh-CN/book/ch07-04-bringing-paths-into-scope-with-the-use-keyword.html#%E5%88%9B%E5%BB%BA%E6%83%AF%E7%94%A8%E7%9A%84-use-%E8%B7%AF%E5%BE%84">创建惯用的 <code>use</code> 路径</a></h3><p>在示例 7-11 中，你可能会比较疑惑，为什么我们是指定 <code>use crate::front_of_house::hosting</code>，然后在 <code>eat_at_restaurant</code> 中调用 <code>hosting::add_to_waitlist</code>，而不是通过指定一直到 <code>add_to_waitlist</code> 函数的 <code>use</code> 路径来得到相同的结果，如示例 7-13 所示。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">mod</span> front_of_house &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">mod</span> hosting &#123;</span><br><span class="line">        <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">add_to_waitlist</span>() &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> crate::front_of_house::hosting::add_to_waitlist;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">eat_at_restaurant</span>() &#123;</span><br><span class="line">    <span class="title function_ invoke__">add_to_waitlist</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例 7-13: 使用 <code>use</code> 将 <code>add_to_waitlist</code> 函数引入作用域，这并不符合习惯</p>
<p>虽然示例 7-11 和 7-13 都完成了相同的任务，但示例 7-11 是使用 <code>use</code> 将函数引入作用域的习惯用法。使用 <code>use</code> 将函数的父模块引入作用域意味着我们必须在调用函数时指定父模块，这样可以清晰地表明函数不是在本地定义的，同时使完整路径的重复度最小化。示例 7-13 中的代码则未表明 <code>add_to_waitlist</code> 是在哪里被定义的。</p>
<p>另一方面，使用 <code>use</code> 引入结构体、枚举和其他项时，习惯是指定它们的完整路径。示例 7-14 展示了将 <code>HashMap</code> 结构体引入二进制 crate 作用域的习惯用法。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">map</span> = HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    map.<span class="title function_ invoke__">insert</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例 7-14: 将 <code>HashMap</code> 引入作用域的习惯用法</p>
<p>这种习惯用法背后没有什么硬性要求：它只是一种惯例，人们已经习惯了以这种方式阅读和编写 Rust 代码。</p>
<blockquote>
<p>其实也就说了这么些内容</p>
</blockquote>
<p><strong>使用 <code>use</code> 引入函数时，习惯上是将函数的父模块引入作用域。</strong> 这样，在调用函数时，你需要写 <code>父模块::函数名()</code>，比如 <code>hosting::add_to_waitlist()</code>。这样做的好处是，可以清晰地表明这个函数不是当前模块定义的，同时避免了每次都写完整的冗长路径。</p>
<p><strong>使用 <code>use</code> 引入结构体、枚举或其他项时，习惯上是直接引入到该项本身。</strong> 这样，你可以直接使用该项的名称，比如 <code>HashMap::new()</code>。</p>
<p>这个习惯用法有一个例外，那就是我们想使用 <code>use</code> 语句将两个具有相同名称的项带入作用域，因为 Rust 不允许这样做。示例 7-15 展示了如何将两个具有相同名称但不同父模块的 <code>Result</code> 类型引入作用域，以及如何引用它们。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">use</span> std::fmt;</span><br><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">function1</span>() <span class="punctuation">-&gt;</span> fmt::<span class="type">Result</span> &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">function2</span>() <span class="punctuation">-&gt;</span> io::<span class="type">Result</span>&lt;()&gt; &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例 7-15: 使用父模块将两个具有相同名称的类型引入同一作用域</p>
<p>如你所见，使用父模块可以区分这两个 <code>Result</code> 类型。如果我们是指定 <code>use std::fmt::Result</code> 和 <code>use std::io::Result</code>，我们将在同一作用域拥有了两个 <code>Result</code> 类型，当我们使用 <code>Result</code> 时，Rust 则不知道我们要用的是哪个。</p>
<blockquote>
<p>接下来就是引入 as</p>
</blockquote>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fmt::<span class="type">Result</span>;</span><br><span class="line"><span class="keyword">use</span> std::io::<span class="type">Result</span> <span class="keyword">as</span> IoResult;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">function1</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span> &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">function2</span>() <span class="punctuation">-&gt;</span> IoResult&lt;()&gt; &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　这个其实看两眼也就明白了,不用什么复杂的解释</p>
<p>然后还有pub use,我的理解就是你自己编写的模块中通过use引用了别的模块的内容,想要使这些内容可以被引用你模块的人使用的话,就需要pub use语句</p>
<blockquote>
<p>以下是ai给出的解释</p>
</blockquote>
<p><code>pub use</code> 的核心作用，正是你描述的这个场景：当你编写一个模块（或者库）时，你可能会<strong>在内部 <code>use</code> 其他模块或类型</strong>来方便自己使用。但是，如果你希望<strong>使用你这个模块的外部代码</strong>也能通过你的模块路径来访问这些被你 <code>use</code> 进来的内容，那么你就需要使用 <code>pub use</code>。</p>
<p>简单来说：</p>
<ul>
<li><strong><code>use</code>：</strong> 仅仅是你自己模块内部的“快捷方式”，方便你在本模块中使用。外部模块无法通过你的模块来访问这些被 <code>use</code> 进来的东西。</li>
<li><strong><code>pub use</code>：</strong> 不仅创建了内部的“快捷方式”，还<strong>公开了</strong>这个快捷方式。这样，外部模块就可以通过你的模块路径来访问这个被重导出的内容，就好像这些内容就是你模块自己定义的一样。</li>
</ul>
<p>这就像是你开了一家商店（你的模块），你从批发商那里进了些商品（其他模块的内容）。</p>
<ul>
<li>如果你只是自己用（<code>use</code>），这些商品就在你的库房里，只有你能看到。</li>
<li>但如果你想把这些商品摆在你的店里卖（<code>pub use</code>），那么顾客（外部代码）就可以通过你的商店来购买这些商品了，他们甚至不需要知道你最初是从哪个批发商那里进的货。</li>
</ul>
<p><code>pub use</code> 允许你提供一个更清晰、更简洁的 API 给你的用户，同时隐藏了你内部的组织结构,语法如下:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> front_of_house &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">mod</span> hosting &#123;</span><br><span class="line">        <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">add_to_waitlist</span>() &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">use</span> crate::front_of_house::hosting;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">eat_at_restaurant</span>() &#123;</span><br><span class="line">    hosting::<span class="title function_ invoke__">add_to_waitlist</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>还剩下一些杂七杂八的东西</p>
<p>下面是这段内容讲的三个主要“玩意儿”：</p>
<ul>
<li><p>你问得很好！这段内容主要围绕着如何在 Rust 项目中使用外部包（crate）以及如何优化 <code>use</code> 语句来管理这些引入的依赖。</p>
<p>下面是这段内容讲的三个主要“玩意儿”：</p>
<h3 id="1-如何使用外部包（Crate）"><a href="#1-如何使用外部包（Crate）" class="headerlink" title="1. 如何使用外部包（Crate）"></a>1. 如何使用外部包（Crate）</h3><p>Rust 项目使用 <strong>Cargo</strong> 这个构建系统和包管理器来管理依赖。</p>
<ul>
<li><p><strong>声明依赖：</strong> 当你需要使用一个外部包时（比如 <code>rand</code>），你需要在项目的 <code>Cargo.toml</code> 文件中的 <code>[dependencies]</code> 部分添加这个包的名称和版本号。Cargo 会自动从 <strong>crates.io</strong>（Rust 社区的包注册表）下载这个包及其所有必要的依赖。</p>
<p>Ini, TOML</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[dependencies]</span><br><span class="line">rand = &quot;0.8.3&quot; # 示例：声明对rand包的依赖</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>引入作用域：</strong> 仅仅声明依赖还不够。你还需要使用 <code>use</code> 关键字，以 <strong>绝对路径</strong> 的方式将外部包中你想要使用的特定项（函数、结构体、trait 等）引入到你的代码的作用域中，这样你才能直接使用它们。</p>
<p>Rust</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use rand::Rng; // 将rand包中的Rng trait引入作用域</span><br></pre></td></tr></table></figure>

<p>值得注意的是，<strong>标准库 (<code>std</code>)</strong> 也是一个特殊的外部 crate。虽然你不需要在 <code>Cargo.toml</code> 中声明它，但你仍然需要使用 <code>use</code> 语句来引入 <code>std</code> 中你想要使用的项，例如 <code>use std::collections::HashMap;</code>。</p>
</li>
</ul>
<h3 id="2-优化-use-语句：嵌套路径"><a href="#2-优化-use-语句：嵌套路径" class="headerlink" title="2. 优化 use 语句：嵌套路径"></a>2. 优化 <code>use</code> 语句：嵌套路径</h3><p>当你的代码需要从同一个模块或同一个包中引入多个项时，逐行 <code>use</code> 会让代码变得冗长。Rust 提供了 <strong>嵌套路径</strong> 的语法来简化这个过程。</p>
<ul>
<li><p><strong>基本嵌套：</strong> 如果多个项共享同一个路径前缀，你可以将它们用大括号 <code>&#123;&#125;</code> 包裹起来。</p>
<p>Rust</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 之前：</span><br><span class="line">// use std::cmp::Ordering;</span><br><span class="line">// use std::io;</span><br><span class="line"></span><br><span class="line">// 之后：一行搞定</span><br><span class="line">use std::&#123;cmp::Ordering, io&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>self</code> 关键字：</strong> 当你想引入一个模块本身，同时又想引入这个模块下的某个子项时，可以在嵌套路径中使用 <code>self</code> 关键字。</p>
<p>Rust</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 之前：</span><br><span class="line">// use std::io;</span><br><span class="line">// use std::io::Write;</span><br><span class="line"></span><br><span class="line">// 之后：一行搞定，同时引入了io模块和io::Write</span><br><span class="line">use std::io::&#123;self, Write&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="3-引入所有公有定义：Glob-运算符"><a href="#3-引入所有公有定义：Glob-运算符" class="headerlink" title="3. 引入所有公有定义：Glob 运算符 *"></a>3. 引入所有公有定义：Glob 运算符 <code>*</code></h3><p>如果你想将一个模块下所有 <strong>公有</strong> 的项都引入到当前作用域，可以使用 <strong>glob 运算符 <code>\*</code></strong>。</p>
<ul>
<li><p><strong>用法：</strong> 在路径的末尾加上 <code>*</code>。</p>
<p>Rust</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use std::collections::*; // 引入std::collections模块中所有的公有项</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>注意事项：</strong> 尽管方便，但使用 glob 运算符时需要<strong>谨慎</strong>。它会使代码的可读性降低，因为你很难一眼看出某个名称是来自哪里，可能会导致名称冲突。它通常在测试模块（为了方便测试所有功能）或特定模式（如 <code>prelude</code> 模式）中使用。</p>
</li>
</ul>
<p>这里还有，并提供了两种技巧 (<code>&#123;&#125;</code> 嵌套路径和 <code>*</code> glob 运算符) 来更简洁地管理 <code>use</code> 语句，从而提高代码的可读性和维护性。</p>
<p>这段代码展示了 Rust 中更细粒度的可见性控制，也就是如何使用 <code>pub(in path)</code>、<code>pub(self)</code> 和 <code>pub(super)</code> 来限制一个项（比如函数）的可见范围。</p>
<h3 id="深入理解-Rust-的可见性控制"><a href="#深入理解-Rust-的可见性控制" class="headerlink" title="深入理解 Rust 的可见性控制"></a>深入理解 Rust 的可见性控制</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个名为 `my_mod` 的模块</span></span><br><span class="line"><span class="keyword">mod</span> my_mod &#123;</span><br><span class="line">    <span class="comment">// 模块中的项默认具有私有的可见性</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">private_function</span>() &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;called `my_mod::private_function()`&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 `pub` 修饰语来改变默认可见性。</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">function</span>() &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;called `my_mod::function()`&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在同一模块中，项可以访问其它项，即使它是私有的。</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">indirect_access</span>() &#123;</span><br><span class="line">        <span class="built_in">print!</span>(<span class="string">&quot;called `my_mod::indirect_access()`, that\n&gt; &quot;</span>);</span><br><span class="line">        <span class="title function_ invoke__">private_function</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模块也可以嵌套</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">mod</span> nested &#123;</span><br><span class="line">        <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">function</span>() &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;called `my_mod::nested::function()`&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">#[allow(dead_code)]</span></span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">private_function</span>() &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;called `my_mod::nested::private_function()`&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用 `pub(in path)` 语法定义的函数只在给定的路径中可见。</span></span><br><span class="line">        <span class="comment">// `path` 必须是父模块（parent module）或祖先模块（ancestor module）</span></span><br><span class="line">        <span class="title function_ invoke__">pub</span>(<span class="keyword">in</span> crate::my_mod) <span class="keyword">fn</span> <span class="title function_">public_function_in_my_mod</span>() &#123;</span><br><span class="line">            <span class="built_in">print!</span>(<span class="string">&quot;called `my_mod::nested::public_function_in_my_mod()`, that\n &gt; &quot;</span>);</span><br><span class="line">            <span class="title function_ invoke__">public_function_in_nested</span>()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用 `pub(self)` 语法定义的函数则只在当前模块中可见。</span></span><br><span class="line">        <span class="title function_ invoke__">pub</span>(<span class="keyword">self</span>) <span class="keyword">fn</span> <span class="title function_">public_function_in_nested</span>() &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;called `my_mod::nested::public_function_in_nested&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用 `pub(super)` 语法定义的函数只在父模块中可见。</span></span><br><span class="line">        <span class="title function_ invoke__">pub</span>(<span class="keyword">super</span>) <span class="keyword">fn</span> <span class="title function_">public_function_in_super_mod</span>() &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;called my_mod::nested::public_function_in_super_mod&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">call_public_function_in_my_mod</span>() &#123;</span><br><span class="line">        <span class="built_in">print!</span>(<span class="string">&quot;called `my_mod::call_public_funcion_in_my_mod()`, that\n&gt; &quot;</span>);</span><br><span class="line">        nested::<span class="title function_ invoke__">public_function_in_my_mod</span>();</span><br><span class="line">        <span class="built_in">print!</span>(<span class="string">&quot;&gt; &quot;</span>);</span><br><span class="line">        nested::<span class="title function_ invoke__">public_function_in_super_mod</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// `pub(crate)` 使得函数只在当前 crate 中可见</span></span><br><span class="line">    <span class="title function_ invoke__">pub</span>(<span class="keyword">crate</span>) <span class="keyword">fn</span> <span class="title function_">public_function_in_crate</span>() &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;called `my_mod::public_function_in_crate()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 嵌套模块的可见性遵循相同的规则</span></span><br><span class="line">    <span class="keyword">mod</span> private_nested &#123;</span><br><span class="line">        <span class="meta">#[allow(dead_code)]</span></span><br><span class="line">        <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">function</span>() &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;called `my_mod::private_nested::function()`&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">function</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;called `function()`&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// 模块机制消除了相同名字的项之间的歧义。</span></span><br><span class="line">    <span class="title function_ invoke__">function</span>();</span><br><span class="line">    my_mod::<span class="title function_ invoke__">function</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 公有项，包括嵌套模块内的，都可以在父模块外部访问。</span></span><br><span class="line">    my_mod::<span class="title function_ invoke__">indirect_access</span>();</span><br><span class="line">    my_mod::nested::<span class="title function_ invoke__">function</span>();</span><br><span class="line">    my_mod::<span class="title function_ invoke__">call_public_function_in_my_mod</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// pub(crate) 项可以在同一个 crate 中的任何地方访问</span></span><br><span class="line">    my_mod::<span class="title function_ invoke__">public_function_in_crate</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// pub(in path) 项只能在指定的模块中访问</span></span><br><span class="line">    <span class="comment">// 报错！函数 `public_function_in_my_mod` 是私有的</span></span><br><span class="line">    <span class="comment">//my_mod::nested::public_function_in_my_mod();</span></span><br><span class="line">    <span class="comment">// 试一试 ^ 取消该行的注释</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模块的私有项不能直接访问，即便它是嵌套在公有模块内部的</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 报错！`private_function` 是私有的</span></span><br><span class="line">    <span class="comment">//my_mod::private_function();</span></span><br><span class="line">    <span class="comment">// 试一试 ^ 取消此行注释</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 报错！`private_function` 是私有的</span></span><br><span class="line">    <span class="comment">//my_mod::nested::private_function();</span></span><br><span class="line">    <span class="comment">// 试一试 ^ 取消此行的注释</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Error! `private_nested` is a private module</span></span><br><span class="line">    <span class="comment">//my_mod::private_nested::function();</span></span><br><span class="line">    <span class="comment">// 试一试 ^ 取消此行的注释</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>默认情况下，Rust 中的所有项（函数、结构体、枚举、模块等）都是私有的。要让它们在当前作用域之外可见，你需要使用 <code>pub</code> 关键字。然而，简单的 <code>pub</code> 意味着对<strong>所有</strong>外部代码都可见，这在某些情况下可能过于宽松。</p>
<p><code>pub(in path)</code>、<code>pub(self)</code> 和 <code>pub(super)</code> 提供了一种方式，让你能够更精确地控制项的可见性，而不是简单地“完全公开”或“完全私有”。</p>
<h4 id="1-pub-in-crate-my-mod-：指定路径可见性"><a href="#1-pub-in-crate-my-mod-：指定路径可见性" class="headerlink" title="1. pub(in crate::my_mod)：指定路径可见性"></a>1. <code>pub(in crate::my_mod)</code>：指定路径可见性</h4><p>这个语法允许你将一个项的可见性限制在指定的路径（模块）内部。</p>
<ul>
<li><p><strong><code>pub(in crate::my_mod) fn public_function_in_my_mod()</code></strong></p>
<ul>
<li>这意味着 <code>public_function_in_my_mod</code> 这个函数只在 <strong><code>crate::my_mod</code> 模块及其子模块内部可见和可调用</strong>。</li>
<li>在 <code>my_mod</code> 外部的代码，即使 <code>my_mod</code> 本身是公开的，也无法直接调用 <code>public_mod::nested::public_function_in_my_mod</code>。</li>
<li><code>path</code> 必须是该项的父模块或祖先模块。你不能指定一个与当前项没有继承关系的模块。</li>
</ul>
<p><strong>想象一下：</strong> 你有一个家族企业，<code>my_mod</code> 是总公司。这个函数就像是只有总公司内部的员工（包括子公司员工）才能使用的特定工具。外部客户即使知道总公司存在，也无法直接使用这个工具。</p>
</li>
</ul>
<h4 id="2-pub-self-：当前模块可见性"><a href="#2-pub-self-：当前模块可见性" class="headerlink" title="2. pub(self)：当前模块可见性"></a>2. <code>pub(self)</code>：当前模块可见性</h4><p><code>pub(self)</code> 将可见性限制在定义该项的<strong>当前模块</strong>内部。</p>
<ul>
<li><p><strong><code>pub(self) fn public_function_in_nested()</code></strong></p>
<ul>
<li>这意味着 <code>public_function_in_nested</code> 这个函数只在 <code>my_mod::nested</code> <strong>模块内部可见</strong>。</li>
<li>即使在 <code>my_mod</code> 模块内部（<code>nested</code> 的父模块），也无法直接调用 <code>public_function_in_nested</code>。只有在 <code>nested</code> 模块内部的代码才能调用它。</li>
</ul>
<p><strong>想象一下：</strong> <code>nested</code> 是公司里的一个特定部门。<code>public_function_in_nested</code> 就像是这个部门内部的专用流程，只有这个部门的员工才能使用。总公司或其他部门的员工都不能直接调用这个流程。</p>
</li>
</ul>
<h4 id="3-pub-super-：父模块可见性"><a href="#3-pub-super-：父模块可见性" class="headerlink" title="3. pub(super)：父模块可见性"></a>3. <code>pub(super)</code>：父模块可见性</h4><p><code>pub(super)</code> 将可见性限制在定义该项的<strong>父模块</strong>内部。</p>
<ul>
<li><p><strong><code>pub(super) fn public_function_in_super_mod()</code></strong></p>
<ul>
<li>这意味着 <code>public_function_in_super_mod</code> 这个函数只在 <code>my_mod</code> <strong>模块内部可见</strong>。</li>
<li>尽管它定义在 <code>nested</code> 模块中，但它只对 <code>nested</code> 的父模块（即 <code>my_mod</code>）可见。<code>nested</code> 模块内部也能调用它，因为父模块的可见性范围包含了子模块。</li>
</ul>
<p><strong>想象一下：</strong> 仍然是公司里的一个部门 <code>nested</code>。<code>public_function_in_super_mod</code> 就像是这个部门为总公司（<code>my_mod</code>）提供的内部服务，总公司可以直接调用，但其他部门或外部客户不能直接调用。</p>
</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">function</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;called `function()`&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">mod</span> cool &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">function</span>() &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;called `cool::function()`&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">mod</span> my &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">function</span>() &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;called `my::function()`&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">mod</span> cool &#123;</span><br><span class="line">        <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">function</span>() &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;called `my::cool::function()`&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">indirect_call</span>() &#123;</span><br><span class="line">        <span class="comment">// 让我们从这个作用域中访问所有名为 `function` 的函数！</span></span><br><span class="line">        <span class="built_in">print!</span>(<span class="string">&quot;called `my::indirect_call()`, that\n&gt; &quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// `self` 关键字表示当前的模块作用域——在这个例子是 `my`。</span></span><br><span class="line">        <span class="comment">// 调用 `self::function()` 和直接调用 `function()` 都得到相同的结果，</span></span><br><span class="line">        <span class="comment">// 因为他们表示相同的函数。</span></span><br><span class="line">        self::<span class="title function_ invoke__">function</span>();</span><br><span class="line">        <span class="title function_ invoke__">function</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 我们也可以使用 `self` 来访问 `my` 内部的另一个模块：</span></span><br><span class="line">        self::cool::<span class="title function_ invoke__">function</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// `super` 关键字表示父作用域（在 `my` 模块外面）。</span></span><br><span class="line">        super::<span class="title function_ invoke__">function</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 这将在 *crate* 作用域内绑定 `cool::function` 。</span></span><br><span class="line">        <span class="comment">// 在这个例子中，crate 作用域是最外面的作用域。</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">use</span> crate::cool::function <span class="keyword">as</span> root_function;</span><br><span class="line">            <span class="title function_ invoke__">root_function</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    my::<span class="title function_ invoke__">indirect_call</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这些细粒度的可见性控制非常有用，它们允许你：</p>
<ul>
<li><strong>封装内部实现细节：</strong> 将一些只应该在特定范围内部使用的函数或数据隐藏起来，避免外部滥用或不当修改。</li>
<li><strong>构建清晰的 API：</strong> 明确哪些部分是库的公共接口，哪些是内部辅助功能。</li>
<li><strong>增强代码安全性：</strong> 限制了对某些敏感操作的访问。</li>
</ul>
<p>RUST的这个模块管理系统真的挺复杂的,估计得在实战中用它两回才能真正学得会.</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/07/24/RUST%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0%E4%B9%8B%E6%A8%A1%E5%9D%9702/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.png">
      <meta itemprop="name" content="Chillward">
      <meta itemprop="description" content="谁躺在漆黑的舞台上，用身体迎接着光芒">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chillward的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/07/24/RUST%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0%E4%B9%8B%E6%A8%A1%E5%9D%9702/" class="post-title-link" itemprop="url">RUST学习日记之模块02</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-07-24 10:23:54 / 修改时间：18:10:05" itemprop="dateCreated datePublished" datetime="2025-07-24T10:23:54+08:00">2025-07-24</time>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>11k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>21 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="路径用于引用模块树中的项"><a href="#路径用于引用模块树中的项" class="headerlink" title="路径用于引用模块树中的项"></a>路径用于引用模块树中的项</h2><p>来看一下 Rust 如何在模块树中找到一个项的位置，我们使用路径的方式，就像在文件系统使用路径一样。如果我们想要调用一个函数，我们需要知道它的路径。</p>
<p>路径有两种形式：</p>
<ul>
<li><strong>绝对路径</strong>（<em>absolute path</em>）从 crate 根部开始，以 crate 名或者字面量 <code>crate</code> 开头。</li>
<li><strong>相对路径</strong>（<em>relative path</em>）从当前模块开始，以 <code>self</code>、<code>super</code> 或当前模块的标识符开头。</li>
</ul>
<p>绝对路径和相对路径都后跟一个或多个由双冒号（<code>::</code>）分割的标识符。</p>
<p>让我们回到示例 7-1。我们如何调用 <code>add_to_waitlist</code> 函数？还是同样的问题，<code>add_to_waitlist</code> 函数的路径是什么？在示例 7-3 中，我们通过删除一些模块和函数，稍微简化了一下我们的代码。我们在 crate 根部定义了一个新函数 <code>eat_at_restaurant</code>，并在其中展示调用 <code>add_to_waitlist</code> 函数的两种方法。<code>eat_at_restaurant</code> 函数是我们 crate 库的一个公共 API，所以我们使用 <code>pub</code> 关键字来标记它。在<a target="_blank" rel="noopener" href="https://rustwiki.org/zh-CN/book/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html#%E4%BD%BF%E7%94%A8-pub-%E5%85%B3%E9%94%AE%E5%AD%97%E6%9A%B4%E9%9C%B2%E8%B7%AF%E5%BE%84">“使用 <code>pub</code> 关键字暴露路径”</a>一节，我们将详细介绍 <code>pub</code>。注意，这个例子无法编译通过，我们稍后会解释原因。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">mod</span> front_of_house &#123;</span><br><span class="line">    <span class="keyword">mod</span> hosting &#123;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">add_to_waitlist</span>() &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">eat_at_restaurant</span>() &#123;</span><br><span class="line">    <span class="comment">// 绝对路径</span></span><br><span class="line">    crate::front_of_house::hosting::<span class="title function_ invoke__">add_to_waitlist</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 相对路径</span></span><br><span class="line">    front_of_house::hosting::<span class="title function_ invoke__">add_to_waitlist</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例 7-3: 使用绝对路径和相对路径来调用 <code>add_to_waitlist</code> 函数</p>
<p>第一种方式，我们在 <code>eat_at_restaurant</code> 中调用 <code>add_to_waitlist</code> 函数，使用的是绝对路径。<code>add_to_waitlist</code> 函数与 <code>eat_at_restaurant</code> 被定义在同一 crate 中，这意味着我们可以使用 <code>crate</code> 关键字为起始的绝对路径。</p>
<p>在 <code>crate</code> 后面，我们持续地嵌入模块，直到我们找到 <code>add_to_waitlist</code>。你可以想象出一个相同结构的文件系统，我们通过指定路径 <code>/front_of_house/hosting/add_to_waitlist</code> 来执行 <code>add_to_waitlist</code> 程序。我们使用 <code>crate</code> 从 crate 根部开始就类似于在 shell 中使用 <code>/</code> 从文件系统根开始。</p>
<p>第二种方式，我们在 <code>eat_at_restaurant</code> 中调用 <code>add_to_waitlist</code>，使用的是相对路径。这个路径以 <code>front_of_house</code> 为起始，这个模块在模块树中，与 <code>eat_at_restaurant</code> 定义在同一层级。与之等价的文件系统路径就是 <code>front_of_house/hosting/add_to_waitlist</code>。以名称为起始，意味着该路径是相对路径。</p>
<p>选择使用相对路径还是绝对路径，还是要取决于你的项目。取决于你是更倾向于将项的定义代码与使用该项的代码分开来移动，还是一起移动。举一个例子，如果我们要将 <code>front_of_house</code> 模块和 <code>eat_at_restaurant</code> 函数一起移动到一个名为 <code>customer_experience</code> 的模块中，我们需要更新 <code>add_to_waitlist</code> 的绝对路径，但是相对路径还是可用的。然而，如果我们要将 <code>eat_at_restaurant</code> 函数单独移到一个名为 <code>dining</code> 的模块中，还是可以使用原本的绝对路径来调用 <code>add_to_waitlist</code>，但是相对路径必须要更新。我们更倾向于使用绝对路径，因为把代码定义和项调用各自独立地移动是更常见的。</p>
<blockquote>
<p>官方依旧高速神言不说人话</p>
</blockquote>
<p>我们用 C 语言的例子来类比一下 Rust 中“把代码定义和项调用各自独立地移动是更常见的”这句话。</p>
<p>在 C 语言中，我们没有像 Rust 这样的模块系统，但我们可以用<strong>头文件（.h）</strong> 和 <strong>源文件（.c）</strong> 来类比“定义”和“调用”以及“路径”。</p>
<h3 id="C-语言中的类比"><a href="#C-语言中的类比" class="headerlink" title="C 语言中的类比"></a>C 语言中的类比</h3><p>想象你有两个 C 文件：</p>
<ol>
<li><p><strong><code>math_operations.h</code> 和 <code>math_operations.c</code></strong>：</p>
<ul>
<li><p><code>math_operations.h</code> (头文件)：声明了 <code>add</code> 函数。这就像 Rust 中一个模块的公开接口，告诉别人有这么一个函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// math_operations.h</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>; <span class="comment">// 这是函数的“定义”或“声明”</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>math_operations.c</code> (源文件)：实现了 <code>add</code> 函数。这是函数的具体“定义”所在。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// math_operations.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;math_operations.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong><code>main.c</code></strong>：</p>
<ul>
<li>这个文件会<strong>调用</strong> <code>add</code> 函数。</li>
</ul>
</li>
</ol>
<h4 id="场景一：类似-Rust-中的绝对路径（使用完整路径-包含完整头文件）"><a href="#场景一：类似-Rust-中的绝对路径（使用完整路径-包含完整头文件）" class="headerlink" title="场景一：类似 Rust 中的绝对路径（使用完整路径&#x2F;包含完整头文件）"></a>场景一：类似 Rust 中的<strong>绝对路径</strong>（使用完整路径&#x2F;包含完整头文件）</h4><p>在 <code>main.c</code> 中，如果你想要使用 <code>add</code> 函数，你会这么做：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;math_operations.h&quot;</span> <span class="comment">// 告诉编译器去哪里找 add 函数的声明</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> result = add(<span class="number">5</span>, <span class="number">3</span>); <span class="comment">// 调用 add 函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里，<code>#include &quot;math_operations.h&quot;</code> 就像 Rust 中的<strong>绝对路径</strong>。它明确地指明了 <code>add</code> 函数的声明在哪里可以找到。</p>
<ul>
<li><strong>如果我移动 <code>main.c</code> 文件（调用者）</strong>：假设你把 <code>main.c</code> 从项目的一个子目录移动到另一个子目录，只要 <code>math_operations.h</code> 的相对位置没有改变，或者你通过编译器的 <code>-I</code> 选项（include path）告诉了编译器 <code>math_operations.h</code> 的新位置，那么 <code>main.c</code> 中 <code>add(5, 3)</code> 的调用<strong>不需要修改</strong>。因为 <code>add</code> 函数的定义（和声明）本身没有移动。这和 Rust 中绝对路径的稳定性类似。</li>
</ul>
<h4 id="场景二：类似-Rust-中的相对路径（如果-C-语言有这种直接模块引用）"><a href="#场景二：类似-Rust-中的相对路径（如果-C-语言有这种直接模块引用）" class="headerlink" title="场景二：类似 Rust 中的相对路径（如果 C 语言有这种直接模块引用）"></a>场景二：类似 Rust 中的<strong>相对路径</strong>（如果 C 语言有这种直接模块引用）</h4><p>C 语言没有像 Rust 这样内建的相对模块路径引用机制。但我们可以想象一种情况，如果你需要在 <code>main.c</code> 中<strong>直接引用</strong> <code>add</code> 函数的定义，而不是通过头文件。这在 C 语言中是做不到的，但为了类比，我们可以假设：</p>
<p>如果 <code>main.c</code> 直接依赖于 <code>math_operations.c</code> 文件的<strong>相对位置</strong>来找到 <code>add</code> 函数的定义（这是个假设，C 实际编译不是这样做的）。那么：</p>
<ul>
<li><strong>如果我移动 <code>main.c</code> 文件（调用者）</strong>：<code>main.c</code> 的位置变了，它与 <code>math_operations.c</code> 的相对位置就可能变了。那么，原先的“相对路径”就失效了，你<strong>需要修改</strong> <code>main.c</code> 中引用 <code>add</code> 函数的方式。</li>
</ul>
<h3 id="“各自独立移动”的含义"><a href="#“各自独立移动”的含义" class="headerlink" title="“各自独立移动”的含义"></a>“各自独立移动”的含义</h3><p>回到 Rust 的语境：</p>
<p>“把代码定义和项调用各自独立地移动是更常见的”这句话意味着：</p>
<ol>
<li><strong>你更常会移动和重构使用某个功能（<code>add</code> 函数）的代码文件（<code>main.c</code>），而不是改变那个功能本身（<code>math_operations.c</code> 和 <code>math_operations.h</code>）的存放位置。</strong></li>
<li>当你移动 <code>main.c</code> 时，你希望它里面的 <code>add(5, 3)</code> 调用能够<strong>保持不变</strong>，而不需要每次移动都去修改它。</li>
</ol>
<p>因此，使用 <strong>绝对路径</strong>（类似 C 语言中 <code>#include &lt;library_header.h&gt;</code> 或者通过 <code>-I</code> 选项找到的头文件）会更稳定。因为它从一个固定的起点（Rust 的 crate 根部）开始寻找，<strong>不依赖于你当前调用代码（<code>main.c</code>）的位置</strong>。即使你把 <code>main.c</code> 移动到项目的其他地方，只要 <code>add</code> 函数的定义没有从它原来的“绝对位置”移动，那么对它的引用就依然有效。</p>
<p>而 <strong>相对路径</strong>，由于它的起点是“当前模块”，一旦你移动了当前模块，相对位置就变了，路径就可能失效，需要你手动更新。</p>
<p>所以，Rust 建议我们倾向于使用绝对路径，因为它在代码重构时，特别是当调用方代码移动时，能够减少你需要修改的引用路径的数量，从而提高代码的维护性和稳定性。</p>
<blockquote>
<p>简而言之就是绝对路径更好用,OK,接下来我们继续欣赏官方文档的高速神言</p>
</blockquote>
<p>让我们试着编译一下示例 7-3，并查明为何不能编译！示例 7-4 展示了这个错误。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ cargo build</span><br><span class="line">   Compiling restaurant v0.1.0 (file:///projects/restaurant)</span><br><span class="line">error[E0603]: module `hosting` is private</span><br><span class="line"> --&gt; src/lib.rs:9:28</span><br><span class="line">  |</span><br><span class="line">9 |     crate::front_of_house::hosting::add_to_waitlist();</span><br><span class="line">  |                            ^^^^^^^ private module</span><br><span class="line">  |</span><br><span class="line">note: the module `hosting` is defined here</span><br><span class="line"> --&gt; src/lib.rs:2:5</span><br><span class="line">  |</span><br><span class="line">2 |     mod hosting &#123;</span><br><span class="line">  |     ^^^^^^^^^^^</span><br><span class="line"></span><br><span class="line">error[E0603]: module `hosting` is private</span><br><span class="line">  --&gt; src/lib.rs:12:21</span><br><span class="line">   |</span><br><span class="line">12 |     front_of_house::hosting::add_to_waitlist();</span><br><span class="line">   |                     ^^^^^^^ private module</span><br><span class="line">   |</span><br><span class="line">note: the module `hosting` is defined here</span><br><span class="line">  --&gt; src/lib.rs:2:5</span><br><span class="line">   |</span><br><span class="line">2  |     mod hosting &#123;</span><br><span class="line">   |     ^^^^^^^^^^^</span><br><span class="line"></span><br><span class="line">For more information about this error, try `rustc --explain E0603`.</span><br><span class="line">error: could not compile `restaurant` due to 2 previous errors</span><br></pre></td></tr></table></figure>

<p>示例 7-4: 构建示例 7-3 出现的编译器错误</p>
<p>错误信息说 <code>hosting</code> 模块是私有的。换句话说，我们拥有 <code>hosting</code> 模块和 <code>add_to_waitlist</code> 函数的的正确路径，但是 Rust 不让我们使用，因为它不能访问私有片段。</p>
<p>模块不仅对于你组织代码很有用。他们还定义了 Rust 的 <em>私有性边界</em>（<em>privacy boundary</em>）：这条界线不允许外部代码了解、调用和依赖被封装的实现细节。所以，如果你希望创建一个私有函数或结构体，你可以将其放入模块。</p>
<p>Rust  中默认所有项（函数、方法、结构体、枚举、模块和常量）都是私有的。父模块中的项不能使用子模块中的私有项，但是子模块中的项可以使用他们父模块中的项。这是因为子模块封装并隐藏了他们的实现详情，但是子模块可以看到他们定义的上下文。继续拿餐馆作比喻，把私有性规则想象成餐馆的后台办公室：餐馆内的事务对餐厅顾客来说是不可知的，但办公室经理可以洞悉其经营的餐厅并在其中做任何事情。</p>
<p>Rust 选择以这种方式来实现模块系统功能，因此默认隐藏内部实现细节。这样一来，你就知道可以更改内部代码的哪些部分而不会破坏外部代码。你还可以通过使用 <code>pub</code> 关键字来创建公共项，使子模块的内部部分暴露给上级模块。</p>
<blockquote>
<p>接下来主要就是引出PUB关键字,需要注意PUB关键字对于结构体,枚举,函数的作用是不太一样的,需要分辨一下</p>
</blockquote>
<h3 id="使用-pub-关键字暴露路径"><a href="#使用-pub-关键字暴露路径" class="headerlink" title="使用 pub 关键字暴露路径"></a>使用 <code>pub</code> 关键字暴露路径</h3><p>让我们回头看一下示例 7-4 的错误，它告诉我们 <code>hosting</code> 模块是私有的。我们想让父模块中的 <code>eat_at_restaurant</code> 函数可以访问子模块中的 <code>add_to_waitlist</code> 函数，因此我们使用 <code>pub</code> 关键字来标记 <code>hosting</code> 模块，如示例 7-5 所示。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> front_of_house &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">mod</span> hosting &#123;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">add_to_waitlist</span>() &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">eat_at_restaurant</span>() &#123;</span><br><span class="line">    <span class="comment">// 绝对路径</span></span><br><span class="line">    crate::front_of_house::hosting::<span class="title function_ invoke__">add_to_waitlist</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 相对路径</span></span><br><span class="line">    front_of_house::hosting::<span class="title function_ invoke__">add_to_waitlist</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例 7-5: 使用 <code>pub</code> 关键字声明 <code>hosting</code> 模块使其可在 <code>eat_at_restaurant</code> 使用</p>
<p>不幸的是，示例 7-5 的代码编译仍然有错误，如示例 7-6 所示。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ cargo build</span><br><span class="line">   Compiling restaurant v0.1.0 (file:///projects/restaurant)</span><br><span class="line">error[E0603]: function `add_to_waitlist` is private</span><br><span class="line"> --&gt; src/lib.rs:9:37</span><br><span class="line">  |</span><br><span class="line">9 |     crate::front_of_house::hosting::add_to_waitlist();</span><br><span class="line">  |                                     ^^^^^^^^^^^^^^^ private function</span><br><span class="line">  |</span><br><span class="line">note: the function `add_to_waitlist` is defined here</span><br><span class="line"> --&gt; src/lib.rs:3:9</span><br><span class="line">  |</span><br><span class="line">3 |         fn add_to_waitlist() &#123;&#125;</span><br><span class="line">  |         ^^^^^^^^^^^^^^^^^^^^</span><br><span class="line"></span><br><span class="line">error[E0603]: function `add_to_waitlist` is private</span><br><span class="line">  --&gt; src/lib.rs:12:30</span><br><span class="line">   |</span><br><span class="line">12 |     front_of_house::hosting::add_to_waitlist();</span><br><span class="line">   |                              ^^^^^^^^^^^^^^^ private function</span><br><span class="line">   |</span><br><span class="line">note: the function `add_to_waitlist` is defined here</span><br><span class="line">  --&gt; src/lib.rs:3:9</span><br><span class="line">   |</span><br><span class="line">3  |         fn add_to_waitlist() &#123;&#125;</span><br><span class="line">   |         ^^^^^^^^^^^^^^^^^^^^</span><br><span class="line"></span><br><span class="line">For more information about this error, try `rustc --explain E0603`.</span><br><span class="line">error: could not compile `restaurant` due to 2 previous errors</span><br></pre></td></tr></table></figure>

<p>示例 7-6: 构建示例 7-5 出现的编译器错误</p>
<p>发生了什么？在 <code>mod hosting</code> 前添加了 <code>pub</code> 关键字，使其变成公有的。伴随着这种变化，如果我们可以访问 <code>front_of_house</code>，那我们也可以访问 <code>hosting</code>。但是 <code>hosting</code> 的 <strong>内容</strong>（<em>contents</em>） 仍然是私有的；这表明<strong>使模块公有并不使其内容也是公有的。模块上的 <code>pub</code> 关键字只允许其父模块引用它。</strong></p>
<p>示例 7-6 中的错误说，<code>add_to_waitlist</code> 函数是私有的。私有性规则不但应用于模块，还应用于结构体、枚举、函数和方法。</p>
<p>让我们继续将 <code>pub</code> 关键字放置在 <code>add_to_waitlist</code> 函数的定义之前，使其变成公有。如示例 7-7 所示。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">mod</span> front_of_house &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">mod</span> hosting &#123;</span><br><span class="line">        <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">add_to_waitlist</span>() &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">eat_at_restaurant</span>() &#123;</span><br><span class="line">    <span class="comment">// 绝对路径</span></span><br><span class="line">    crate::front_of_house::hosting::<span class="title function_ invoke__">add_to_waitlist</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 相对路径</span></span><br><span class="line">    front_of_house::hosting::<span class="title function_ invoke__">add_to_waitlist</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例 7-7: 为 <code>mod hosting</code> 和 <code>fn add_to_waitlist</code> 添加 <code>pub</code> 关键字使他们可以在 <code>eat_at_restaurant</code> 函数中被调用</p>
<p>现在代码可以编译通过了！让我们看看绝对路径和相对路径，并根据私有性规则，再检查一下为什么增加 <code>pub</code> 关键字使得我们可以在 <code>add_to_waitlist</code> 中调用这些路径。</p>
<p>在绝对路径，我们从 <code>crate</code>，也就是 crate 根部开始。然后 crate 根部中定义了 <code>front_of_house</code> 模块。<code>front_of_house</code> 模块不是公有的，不过因为 <code>eat_at_restaurant</code> 函数与 <code>front_of_house</code> 定义于同一模块中（即，<code>eat_at_restaurant</code> 和 <code>front_of_house</code> 是兄弟），我们可以从 <code>eat_at_restaurant</code> 中引用 <code>front_of_house</code>。接下来是使用 <code>pub</code> 标记的 <code>hosting</code> 模块。我们可以访问 <code>hosting</code> 的父模块，所以可以访问 <code>hosting</code>。最后，<code>add_to_waitlist</code> 函数被标记为 <code>pub</code> ，我们可以访问其父模块，所以这个函数调用是有效的！</p>
<p>在相对路径，其逻辑与绝对路径相同，除了第一步：不同于从 crate 根部开始，路径从 <code>front_of_house</code> 开始。<code>front_of_house</code> 模块与 <code>eat_at_restaurant</code> 定义于同一模块，所以从 <code>eat_at_restaurant</code> 中开始定义的该模块相对路径是有效的。接下来因为 <code>hosting</code> 和 <code>add_to_waitlist</code> 被标记为 <code>pub</code>，路径其余的部分也是有效的，因此函数调用也是有效的！</p>
<blockquote>
<p>我们来仔细讨论一下上面这段话</p>
</blockquote>
<p><strong><code>front_of_house</code> 在你提供的代码中不是私有的，它是默认公开的，因为它是直接在 <code>crate</code> 根部定义的。</strong></p>
<p>Rust 的访问规则有点绕，我们来具体解释一下：</p>
<h3 id="crate-根部定义的模块默认是公开的"><a href="#crate-根部定义的模块默认是公开的" class="headerlink" title="crate 根部定义的模块默认是公开的"></a><code>crate</code> 根部定义的模块默认是公开的</h3><p>当你直接在 <code>src/lib.rs</code> (或者 <code>src/main.rs</code>) 文件中定义一个模块时，比如 <code>mod front_of_house &#123;&#125;</code>，这个模块就是定义在 <code>crate</code> 的<strong>根部</strong>。</p>
<p><strong>在 <code>crate</code> 根部定义的项（包括模块），默认情况下是可以在整个 <code>crate</code> 内部被直接访问到的。</strong> 它们不需要 <code>pub</code> 关键字就可以被同一 <code>crate</code> 中的其他代码访问。<code>pub</code> 关键字的作用是让该项可以被<strong>外部 <code>crate</code></strong> (比如你的库被其他项目引用时) 访问，或者让该项可以被<strong>子模块之外的模块</strong>通过完整路径访问。</p>
<p>所以，<code>front_of_house</code> 模块虽然没有显式地写 <code>pub mod front_of_house &#123;&#125;</code>，但因为它直接位于 <code>crate</code> 根部，所以：</p>
<ol>
<li><strong><code>eat_at_restaurant</code> 函数</strong>（也在 <code>crate</code> 根部）可以直接看到并访问 <code>front_of_house</code>，因为它们是“兄弟”关系，都在最外层。</li>
<li><strong><code>crate::</code></strong> 作为绝对路径的起点，它自然也能直接“看到”它根部定义的所有内容，包括 <code>front_of_house</code>。</li>
</ol>
<h3 id="为什么会产生误解？"><a href="#为什么会产生误解？" class="headerlink" title="为什么会产生误解？"></a>为什么会产生误解？</h3><p>你可能误解了“私有”的含义。在 Rust 中，一个模块（或任何项）如果没有 <code>pub</code> 关键字，它通常表示该项只在其<strong>直接父模块内部</strong>可见和可访问。但是，这个规则对于 <strong><code>crate</code> 根部</strong>有点特殊。<code>crate</code> 根部本身就是最高层级，它里面定义的所有东西对于整个 <code>crate</code> 内部的代码来说，都是默认可访问的，除非它们被嵌套在某个私有模块内部。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong><code>front_of_house</code> 模块</strong>：因为它直接定义在 <code>crate</code> 根部（<code>src/lib.rs</code> 的顶层），所以默认情况下，这个 <code>crate</code> 内部的所有代码都可以直接看到并引用它。它不是“私有的”，而是对 <code>crate</code> 内部可见的。</li>
<li><strong><code>pub mod hosting</code></strong>：这里 <code>pub</code> 的作用是让 <code>hosting</code> 模块可以被 <code>front_of_house</code> 之外的代码（比如 <code>eat_at_restaurant</code>，它位于 <code>front_of_house</code> 的父级 <code>crate</code> 根部）访问。如果没有 <code>pub</code>，那么 <code>hosting</code> 默认就是私有的，只有 <code>front_of_house</code> 内部的代码才能访问它。</li>
<li><strong><code>pub fn add_to_waitlist()</code></strong>：函数默认是私有的。如果你想从它所在的模块外面调用它，就必须给它加上 <code>pub</code>。</li>
</ul>
<p>所以，<code>crate</code> 可以访问到 <code>front_of_house</code> 是因为 <code>front_of_house</code> 就在 <code>crate</code> 根部，并且对于 <code>crate</code> 内部是默认可见的。</p>
<blockquote>
<p>依旧AI大法</p>
</blockquote>
<hr>
<p>是的，<strong>默认情况下，模块外部无法直接访问 <code>front_of_house</code> 模块的内容。</strong></p>
<p>让我们用刚才的餐厅例子再来说明一下：</p>
<p>你的 Rust 项目是个大餐厅，<code>front_of_house</code> 是餐厅里“前厅”这个区域。</p>
<ul>
<li><strong>默认情况下（没有 <code>pub</code>）</strong>：这个“前厅”是餐厅内部的一个区域，它里面的具体设施（比如某个柜台、某个角落）默认都是“不对外开放”的。只有当你身处“前厅”内部，或者你被“前厅”的主管（父模块）特许，才能使用里面的东西。外部的顾客（其他 <code>crate</code>）或者甚至餐厅内部其他区域的员工（其他模块）都不能直接走进“前厅”去拿里面的东西，除非前厅的某个门是打开的（<code>pub</code>）。</li>
<li><strong>为什么 <code>crate::front_of_house</code> 可以访问到？</strong><ul>
<li>因为 <code>front_of_house</code> 是直接定义在你的 <code>crate</code>（也就是整个餐厅）的“大厅”（根部）里的。</li>
<li>所以，当你从“大厅”出发（<code>crate::</code>）时，你自然能看到“大厅”里所有的区域划分，包括 <code>front_of_house</code>。这就像你站在餐厅大堂中央，能看到哪里是“前厅”，哪里是“厨房”。</li>
<li>但是，能看到这个区域，不代表你就能直接使用这个区域里的所有东西。要使用里面的东西，里面的东西本身也必须是公开的。</li>
</ul>
</li>
</ul>
<p>所以，结论是：</p>
<p>如果你想让 <strong><code>front_of_house</code> 模块内部的</strong> 某个函数或结构体被**<code>front_of_house</code> 模块外部**的代码访问（比如被 <code>eat_at_restaurant</code> 访问，或者被另一个 <code>crate</code> 访问），那么：</p>
<ol>
<li><strong><code>front_of_house</code> 模块</strong>本身需要是可访问的（因为它直接在 <code>crate</code> 根部，所以它对 <code>crate</code> 内部是默认可见的）。</li>
<li><strong><code>front_of_house</code> 内部的子模块或函数&#x2F;结构体</strong>也必须使用 <strong><code>pub</code> 关键字</strong> 来声明，才能让外部通过完整路径访问到它们。</li>
</ol>
<p>这就是为什么在示例中，你不仅要给 <code>hosting</code> 加上 <code>pub</code>，还要给 <code>add_to_waitlist</code> 加上 <code>pub</code>，才能让 <code>eat_at_restaurant</code> 最终调用到它。</p>
<h3 id="使用-super-起始的相对路径"><a href="#使用-super-起始的相对路径" class="headerlink" title="使用 super 起始的相对路径"></a><a target="_blank" rel="noopener" href="https://rustwiki.org/zh-CN/book/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html#%E4%BD%BF%E7%94%A8-super-%E8%B5%B7%E5%A7%8B%E7%9A%84%E7%9B%B8%E5%AF%B9%E8%B7%AF%E5%BE%84">使用 <code>super</code> 起始的相对路径</a></h3><p>我们还可以使用 <code>super</code> 开头来构建从父模块开始的相对路径。这么做类似于文件系统中以 <code>..</code> 开头的语法。我们为什么要这样做呢？</p>
<p>考虑一下示例 7-8 中的代码，它模拟了厨师更正了一个错误订单，并亲自将其提供给客户的情况。<code>fix_incorrect_order</code> 函数通过指定的 <code>super</code> 起始的 <code>serve_order</code> 路径，来调用 <code>serve_order</code> 函数：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">serve_order</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">mod</span> back_of_house &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">fix_incorrect_order</span>() &#123;</span><br><span class="line">        <span class="title function_ invoke__">cook_order</span>();</span><br><span class="line">        super::<span class="title function_ invoke__">serve_order</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">cook_order</span>() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例 7-8: 使用以 <code>super</code> 开头的相对路径从父目录开始调用函数</p>
<p><code>fix_incorrect_order</code> 函数在 <code>back_of_house</code> 模块中，所以我们可以使用 <code>super</code> 进入 <code>back_of_house</code> 父模块，也就是本例中的 <code>crate</code> 根。在这里，我们可以找到 <code>serve_order</code>。成功！我们认为 <code>back_of_house</code> 模块和 <code>serve_order</code> 函数之间可能具有某种关联关系，并且，如果我们要重新组织这个 crate 的模块树，需要一起移动它们。因此，我们使用 <code>super</code>，这样一来，如果这些代码被移动到了其他模块，我们只需要更新很少的代码。</p>
<h3 id="创建公有的结构体和枚举"><a href="#创建公有的结构体和枚举" class="headerlink" title="创建公有的结构体和枚举"></a><a target="_blank" rel="noopener" href="https://rustwiki.org/zh-CN/book/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html#%E5%88%9B%E5%BB%BA%E5%85%AC%E6%9C%89%E7%9A%84%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E6%9E%9A%E4%B8%BE">创建公有的结构体和枚举</a></h3><p>我们还可以使用 <code>pub</code> 来设计公有的结构体和枚举，不过有一些额外的细节需要注意。如果我们在一个结构体定义的前面使用了 <code>pub</code> ，这个结构体会变成公有的，但是这个结构体的字段仍然是私有的。我们可以根据情况决定每个字段是否公有。在示例 7-9 中，我们定义了一个公有结构体 <code>back_of_house::Breakfast</code>，其中有一个公有字段 <code>toast</code> 和私有字段 <code>seasonal_fruit</code>。这个例子模拟的情况是，在一家餐馆中，顾客可以选择随餐附赠的面包类型，但是厨师会根据季节和库存情况来决定随餐搭配的水果。餐馆可用的水果变化是很快的，所以顾客不能选择水果，甚至无法看到他们将会得到什么水果。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">mod</span> back_of_house &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Breakfast</span> &#123;</span><br><span class="line">        <span class="keyword">pub</span> toast: <span class="type">String</span>,</span><br><span class="line">        seasonal_fruit: <span class="type">String</span>,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">impl</span> <span class="title class_">Breakfast</span> &#123;</span><br><span class="line">        <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">summer</span>(toast: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> Breakfast &#123;</span><br><span class="line">            Breakfast &#123;</span><br><span class="line">                toast: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(toast),</span><br><span class="line">                seasonal_fruit: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;peaches&quot;</span>),</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">eat_at_restaurant</span>() &#123;</span><br><span class="line">    <span class="comment">// 在夏天点一份黑麦面包作为早餐</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">meal</span> = back_of_house::Breakfast::<span class="title function_ invoke__">summer</span>(<span class="string">&quot;Rye&quot;</span>);</span><br><span class="line">    <span class="comment">// 更改我们想要的面包</span></span><br><span class="line">    meal.toast = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Wheat&quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;I&#x27;d like &#123;&#125; toast please&quot;</span>, meal.toast);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果取消下一行的注释，将会导致编译失败；我们不被允许</span></span><br><span class="line">    <span class="comment">// 看到或更改随餐搭配的季节水果</span></span><br><span class="line">    <span class="comment">// meal.seasonal_fruit = String::from(&quot;blueberries&quot;);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例 7-9: 带有公有和私有字段的结构体</p>
<p>因为 <code>back_of_house::Breakfast</code> 结构体的 <code>toast</code> 字段是公有的，所以我们可以在 <code>eat_at_restaurant</code> 中使用点号来随意的读写 <code>toast</code> 字段。注意，我们不能在 <code>eat_at_restaurant</code> 中使用 <code>seasonal_fruit</code> 字段，因为 <code>seasonal_fruit</code> 是私有的。尝试去除那一行修改 <code>seasonal_fruit</code> 字段值的代码的注释，看看你会得到什么错误！</p>
<p>还请注意一点，因为 <code>back_of_house::Breakfast</code> 具有私有字段，所以这个结构体需要提供一个公共的关联函数来构造 <code>Breakfast</code> 的实例（这里我们命名为 <code>summer</code>）。如果 <code>Breakfast</code> 没有这样的函数，我们将无法在 <code>eat_at_restaurant</code> 中创建 <code>Breakfast</code> 实例，因为我们不能在 <code>eat_at_restaurant</code> 中设置私有字段 <code>seasonal_fruit</code> 的值。</p>
<p>与之相反，如果我们将枚举设为公有，则它的所有成员都将变为公有。我们只需要在 <code>enum</code> 关键字前面加上 <code>pub</code>，就像示例 7-10 展示的那样。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">mod</span> back_of_house &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">enum</span> <span class="title class_">Appetizer</span> &#123;</span><br><span class="line">        Soup,</span><br><span class="line">        Salad,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">eat_at_restaurant</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">order1</span> = back_of_house::Appetizer::Soup;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">order2</span> = back_of_house::Appetizer::Salad;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例 7-10: 设计公有枚举，使其所有成员公有</p>
<p>因为我们创建了名为 <code>Appetizer</code> 的公有枚举，所以我们可以在 <code>eat_at_restaurant</code> 中使用 <code>Soup</code> 和 <code>Salad</code> 成员。如果枚举成员不是公有的，那么枚举会显得用处不大；给枚举的所有成员挨个添加 <code>pub</code> 是很令人恼火的，因此枚举成员默认就是公有的。结构体通常使用时，不必将它们的字段公有化，因此结构体遵循常规，内容全部是私有的，除非使用 <code>pub</code> 关键字。</p>
<p>还有一种使用 <code>pub</code> 的场景我们还没有涉及到，那就是我们最后要讲的模块功能：<code>use</code> 关键字。我们将先单独介绍 <code>use</code>，然后展示如何结合使用 <code>pub</code> 和 <code>use</code>。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Chillward"
      src="/uploads/avatar.png">
  <p class="site-author-name" itemprop="name">Chillward</p>
  <div class="site-description" itemprop="description">谁躺在漆黑的舞台上，用身体迎接着光芒</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">17</span>
          <span class="site-state-item-name">博客</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/zh-CN" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Chillward</span>
</div>
  <div class="powered-by">
    <!--由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动 -->
  </div>

<!-- 网站运行时间的设置 -->
<span id="timeDate">载入天数...</span>
<span id="times">载入时分秒...</span>
<script>
    var now = new Date();
    function createtime() {
        var grt= new Date("07/16/2025 10:00:00"); //此处修改你的建站时间或者网站上线时间
        now.setTime(now.getTime()+250);
        days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days);
        hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours);
        if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);
        mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;}
        seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
        snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;}
        document.getElementById("timeDate").innerHTML = "本站已安全运行 "+dnum+" 天 ";
        document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒.";
    }
setInterval("createtime()",250);
</script>
        








	 </div>
    </footer>
  </div>

  
  <script size="300" alpha="0.6" zIndex="-1" src="/lib/canvas-ribbon/canvas-ribbon.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/pjax/pjax.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/lozad@1/dist/lozad.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/pangu@4/dist/browser/pangu.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  




  
<script src="/js/local-search.js"></script>











<script data-pjax>
if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.initialize({
      theme    : 'dark',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    });
  }, window.mermaid);
}
</script>


    <div id="pjax">
  

  

    </div>
</body>
</html>
